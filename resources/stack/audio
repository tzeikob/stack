#!/usr/bin/env bash

source /opt/stack/utils

require "libpulse"
require "jq"

prompt () {
  local QUERY='.[] | select(.state == "RUNNING")'
  local SINK=$(pactl --format=json list sinks | jq -r "$QUERY")

  local STATUS="${YE}none$RS"

  if [ -n "$SINK" ]; then
    local PORT=$(echo "$SINK" | jq -r '.active_port')
    local MUTE=$(echo "$SINK" | jq -r '.mute')
    local DB=$(echo "$SINK" | jq -r '.volume | keys[0] as $k | .[$k].db' | awk '{print $1$2}')

    STATUS="$YE${PORT}$RS"

    if [ "$MUTE" = "true" ]; then
      STATUS+=" ${MA}muted$RS"
    elif [[ "$DB" =~ ^(-|0.00) ]]; then
      STATUS+=" $GR${DB}$RS"
    else
      STATUS+=" $MA${DB}$RS"
    fi
  fi

  read -rep "[audio:${STATUS}] " REPLY
}

show_status () {
  local QUERY='("'
  QUERY+='Server:       \(.server_name)\n'
  QUERY+='Path:         \(.server_string)\n'
  QUERY+='Version:      \(.server_version)\n'
  QUERY+='Local:        \(.is_local)\n'
  QUERY+='Client:       \(.client_index)\n'
  QUERY+='Sample:       \(.default_sample_specification)\n'
  QUERY+='Channel:      \(.default_channel_map)\n'
  QUERY+='Sink:         \(.default_sink_name)\n'
  QUERY+='Sources:      \(.default_source_name)\n'
  QUERY+='Cookie:       \(.cookie)")'

  pactl --format=json info | jq -r "$QUERY"
  
  QUERY='.[] | ("\n'
  QUERY+='Card:         \(.index)\n'
  QUERY+='Name:         \(.name)\n'
  QUERY+='Device:       \(.properties."device.name")\n'
  QUERY+='Nick:         \(.properties."device.nick")\n'
  QUERY+='Vendor:       \(.properties."device.vendor.name")\n'
  QUERY+='Product:      \(.properties."device.product.name")\n'
  QUERY+='Driver:       \(.driver)\n'
  QUERY+='API:          \(.properties."device.api")\n'
  QUERY+='Form:         \(.properties."device.form_factor")\n'
  QUERY+='Bus:          \(.properties."device.bus")\n'
  QUERY+='ACP:          \(.properties."api.alsa.use-acp")\n'
  QUERY+='Auto Profile: \(.properties."api.acp.auto-profile")\n'
  QUERY+='Auto Port:    \(.properties."api.acp.auto-port")\n'
  QUERY+='Profile:      \(.active_profile)")'

  pactl --format=json list cards | jq -r "$QUERY"
}

show_card () {
  local CARD=$1

  if [ -z "$CARD" ]; then
    echo "Missing name or id argument"
    return 1
  fi

  local FIELD="name"
  local VALUE="\"${CARD}\""

  if [[ "$CARD" =~ ^[0-9]+$ ]]; then
    FIELD="index"
    VALUE=$CARD
  fi

  local QUERY=".[] | select(.${FIELD}==${VALUE})"
  CARD=$(pactl --format=json list cards | jq -er "$QUERY" || echo "$?")

  if [[ "$CARD" =~ ^[0-9]+$ ]]; then
    echo "Unable to find the card with $FIELD $VALUE"
    return 1
  fi

  QUERY='("Index:              \(.index)\n'
  QUERY+='Name:               \(.name)\n'
  QUERY+='Driver:             \(.driver)\n'
  QUERY+='Owner:              \(.owner_module)\n'
  QUERY+='Enum API:           \(.properties."device.enum.api")\n'
  QUERY+='Device API:         \(.properties."device.api")\n'
  QUERY+='Media Class:        \(.properties."media.class")\n'
  QUERY+='API Alsa Path:      \(.properties."api.alsa.path")\n'
  QUERY+='API Alsa Card:      \(.properties."api.alsa.card")\n'
  QUERY+='API Alsa Card Name: \(.properties."api.alsa.card.name")\n'
  QUERY+='Card Long Name:     \(.properties."api.alsa.card.longname")\n'
  QUERY+='Usec:               \(.properties."device.plugged.usec")\n'
  QUERY+='Bus Path:           \(.properties."device.bus_path")\n'
  QUERY+='SysFS Path:         \(.properties."sysfs.path")\n'
  QUERY+='Bus:                \(.properties."device.bus")\n'
  QUERY+='Subsystem:          \(.properties."device.subsystem")\n'
  QUERY+='Vendor ID:          \(.properties."device.vendor.id")\n'
  QUERY+='Vendor Name:        \(.properties."device.vendor.name")\n'
  QUERY+='Product ID:         \(.properties."device.product.id")\n'
  QUERY+='Product Name:       \(.properties."device.product.name")\n'
  QUERY+='Form Factor:        \(.properties."device.form_factor")\n'
  QUERY+='Device Name:        \(.properties."device.name")\n'
  QUERY+='Description:        \(.properties."device.description")\n'
  QUERY+='Nick:               \(.properties."device.nick")\n'
  QUERY+='Use ACP:            \(.properties."api.alsa.use-acp")\n'
  QUERY+='Auto Profile:       \(.properties."api.acp.auto-profile")\n'
  QUERY+='Auto Port:          \(.properties."api.acp.auto-port")\n'
  QUERY+='Reserve Devicel:    \(.properties."api.dbus.ReserveDevice1")\n'
  QUERY+='Factory:            \(.properties."factory.id")\n'
  QUERY+='Client ID:          \(.properties."client.id")\n'
  QUERY+='Object ID:          \(.properties."object.id")\n'
  QUERY+='Object Serial:      \(.properties."object.serial")\n'
  QUERY+='Object Path:        \(.properties."object.path")\n'
  QUERY+='Alsa Card:          \(.properties."alsa.card")\n'
  QUERY+='Active Profile:     \(.active_profile)")'

  echo "$CARD" | jq -r "$QUERY"

  echo -e "\nProfiles:"
  QUERY='.profiles | " \(keys[])"'

  echo "$CARD" | jq -r "$QUERY"

  echo -e "\nPorts:"
  QUERY='.ports | to_entries[] | " \(.key) [\(.value.type)]"'

  echo "$CARD" | jq -r "$QUERY"
}

list_cards () {
  local CARDS=$(pactl --format=json list cards)
  
  local QUERY='.[] | ("\n'
  QUERY+='ID:     \(.index)\n'
  QUERY+='Name:   \(.name)\n'
  QUERY+='Bus:    \(.properties."device.bus")\n'
  QUERY+='Nick:   \(.properties."device.nick")\n'
  QUERY+='Vendor: \(.properties."device.vendor.name")")'

  echo "$CARDS" | jq -r "$QUERY" | tail -n +2
}

list_profiles () {
  local CARD=$1

  if [ -z "$CARD" ]; then
    echo "Missing name or id argument"
    return 1
  fi

  local FIELD="name"
  local VALUE="\"${CARD}\""

  if [[ "$CARD" =~ ^[0-9]+$ ]]; then
    FIELD="index"
    VALUE=$CARD
  fi

  local QUERY=".[] | select(.${FIELD}==${VALUE})"
  CARD=$(pactl --format=json list cards | jq -er "$QUERY" || echo "$?")

  if [[ "$CARD" =~ ^[0-9]+$ ]]; then
    echo "Unable to find the card with $FIELD $VALUE"
    return 1
  fi

  QUERY='.profiles | keys[]'
  echo "$CARD" | jq -r "$QUERY"
}

list_outputs () {
  local SINKS=$(pactl --format=json list sinks)

  if [ -z "$SINKS" ]; then
    echo "No outputs have been found"
    return 1
  fi

  local QUERY='.[] |= . + {"sink": .name} |'
  QUERY+='map((.ports[] + {index, sink, mute, properties})) |'
  QUERY+='.[] | ("\n'
  QUERY+='ID:        \(.index)\n'
  QUERY+='Sink:      \(.sink)\n'
  QUERY+='Name:      \(.name)\n'
  QUERY+='Type:      \(.type)\n'
  QUERY+='Nick:      \(.properties."device.nick")\n'
  QUERY+='Mute:      \(.mute)\n'
  QUERY+='Available: \(.availability)")'

  echo "$SINKS" | jq -r "$QUERY" | tail -n +2
}

list_inputs () {
  local SOURCES=$(pactl --format=json list sources)

  if [ -z "$SOURCES" ]; then
    echo "No inputs have been found"
    return 1
  fi

  local QUERY='.[] |= . + {"source": .name} |'
  QUERY+='map((.ports[] + {index, source, mute, properties})) |'
  QUERY+='.[] | ("\n'
  QUERY+='ID:        \(.index)\n'
  QUERY+='Source:    \(.source)\n'
  QUERY+='Name:      \(.name)\n'
  QUERY+='Type:      \(.type)\n'
  QUERY+='Nick:      \(.properties."device.nick")\n'
  QUERY+='Mute:      \(.mute)\n'
  QUERY+='Available: \(.availability)")'

  echo "$SOURCES" | jq -r "$QUERY" | tail -n +2
}

list_playbacks () {
  local FILTER=$1

  local SINK_INPUTS=$(pactl --format=json list sink-inputs)

  if [ -z "$SINK_INPUTS" ]; then
    echo "No playbacks have been found"
    return 1
  fi

  local QUERY='.[] |'
  QUERY+='select(.properties."application.name"|test("'$FILTER'"; "i")) |'
  QUERY+='("\n'
  QUERY+='Sink:    \(.index)\n'
  QUERY+='Name:    \(.properties."application.name")\n'
  QUERY+='Process: \(.properties."application.process.id")\n'
  QUERY+='Media:   \(.properties."media.name")\n'
  QUERY+='Mute:    \(.mute)")'

  echo "$SINK_INPUTS" | jq -r "$QUERY" | tail -n +2
}

set_profile () {
  local CARD=$1
  local PROFILE=$2

  if [ -z "$CARD" ]; then
    echo "Missing the card argument"
    return 1
  fi

  if [ -z "$PROFILE" ]; then
    echo "Missing the profile argument"
    return 1
  fi

  pactl set-card-profile "$CARD" "$PROFILE" &> /dev/null && sleep 0.1 &&
    echo "Audio profile has been set to $PROFILE" ||
    echo "Unable to set the audio profile"
}

set_output () {
  local INDEX=$1
  local VOLUME=$2

  if [ -z "$INDEX" ]; then
    echo "Missing the output name or id argument"
    return 1
  fi

  if [ -z "$VOLUME" ]; then
    echo "Missing the volume argument"
    return 1
  elif [[ ! "$VOLUME" =~ ^[0-9]{1,3}$ ]]; then
    echo "Invalid volume argument: '$VOLUME'"
    return 1
  elif ! (($VOLUME >= 0 && $VOLUME <= 150)); then
    echo "Volume is out of the valid range: '$VOLUME'"
    return 1
  fi

  if [ $VOLUME -gt 0 ]; then
    pactl set-sink-mute "$INDEX" 0 &&
    pactl set-sink-volume "$INDEX" "$VOLUME%" && sleep 0.1 &&
      echo "Volume set to $VOLUME for the output $INDEX" ||
      echo "Unable to set the volume"
  else
    pactl set-sink-mute "$INDEX" 1 && sleep 0.1 &&
      echo "Output $INDEX set to mute" ||
      echo "Unable to set output to mute"
  fi
}

set_input () {
  local INDEX=$1
  local VOLUME=$2

  if [ -z "$INDEX" ]; then
    echo "Missing the input name or id argument"
    return 1
  fi

  if [ -z "$VOLUME" ]; then
    echo "Missing the volume argument"
    return 1
  elif [[ ! "$VOLUME" =~ ^[0-9]{1,3}$ ]]; then
    echo "Invalid volume argument: '$VOLUME'"
    return 1
  elif ! (($VOLUME >= 0 && $VOLUME <= 150)); then
    echo "Volume is out of the valid range: '$VOLUME'"
    return 1
  fi
  
  if [ $VOLUME -gt 0 ]; then
    pactl set-source-mute "$INDEX" 0 &&
    pactl set-source-volume "$INDEX" "$VOLUME%" && sleep 0.1 &&
      echo "Volume set to $VOLUME for the input $INDEX" ||
      echo "Unable to set the volume"
  else
    pactl set-source-mute "$INDEX" 1 && sleep 0.1 &&
      echo "Input $INDEX set to mute" ||
      echo "Unable to set input to mute"
  fi
}

set_mute () {
  local SUBJECT=$1
  local MUTE=$2

  if [ -z "$SUBJECT" ]; then
    echo "Missing the subject argument"
    return 1
  elif [[ ! "$SUBJECT" =~ ^(all|outputs|inputs)$ ]]; then
    echo "Invalid subject argument: '$SUBJECT'"
    return 1
  fi

  if [ -z "$MUTE" ]; then
    echo "Missing the mute argument"
    return 1
  elif [[ ! "$MUTE" =~ ^(1|0)$ ]]; then
    echo "Invalid mute argument: '$MUTE'"
    return 1
  fi

  if [[ "$SUBJECT" =~ (all|outputs) ]]; then
    local SINKS=($(pactl --format=json list sinks | jq -r .[].name))

    local INDEX=0
    while [ $INDEX -lt ${#SINKS[@]} ]; do
      pactl set-sink-mute "${SINKS[INDEX]}" "$MUTE" && sleep 0.1
      INDEX=$((INDEX + 1))
    done
  fi

  if [[ "$SUBJECT" =~ (all|inputs) ]]; then
    local SOURCES=($(pactl --format=json list sources | jq -r .[].name))

    local INDEX=0
    while [ $INDEX -lt ${#SOURCES[@]} ]; do
      pactl set-source-mute "${SOURCES[INDEX]}" "$MUTE" && sleep 0.1
      INDEX=$((INDEX + 1))
    done
  fi
}

help () {
  local FRM=" %-32s\t%s\n"

  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf "$FRM" \
    "help" "Show this help message." \
    "show status" "Show an overall report of the system's audio." \
    "show card <name|id>" "Show data for the card with the given name or id." \
    "" "" \
    "list cards" "List all the audio cards plugged to the system." \
    "list profiles <name|id>" "List the profiles of the given audio card." \
    "list outputs" "List all output audio streams." \
    "list inputs" "List all input audio streams." \
    "list playbacks [<filter>]" "List any active audio playbacks." \
    "" "" \
    "set profile <name|id> <profile>" "Set the audio profile of the given card." \
    "set output <name|id> <volume>" "Set the volume of the given output, 0 to mute." \
    "set input <name|id> <volume>" "Set the volume of the given input, 0 to mute." \
    "mute all|outputs|inputs" "Mute all, output or input audio streams." \
    "unmute all|outputs|inputs" "Unmute all, outputs or inputs audio streams."

  echo -e "\nOBJECTS"
  printf "$FRM" \
    "status" "The status of the system's audio." \
    "card" "An audio card." \
    "profile" "An audio profile of a card." \
    "output" "An output audio stream (speaker)." \
    "input" "An input audio stream (microphone)." \
    "playback" "An application or process streaming audio."
}

loop () {
  clear

  while true; do
    prompt && history -s "$REPLY"

    set -f
    local OLD_IFS=$IFS && IFS=$'\n'
    local CMD=($(xargs -n1 <<< "$REPLY"))
    IFS=$OLD_IFS && set +f

    if [ "${CMD[0]}" = "help" ]; then
      help
      continue
    elif [ "${CMD[0]}" = "clear" ]; then
      clear
      continue
    elif [ "${CMD[0]}" = "quit" ]; then
      break
    elif [ -z "${CMD[0]}" ]; then
      continue
    fi

    case "${CMD[0]}" in
      "show")
        case "${CMD[1]}" in
          "status") show_status;;
          "card") show_card "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "list")
        case "${CMD[1]}" in
          "cards") list_cards;;
          "profiles") list_profiles "${CMD[2]}";;
          "outputs") list_outputs;;
          "inputs") list_inputs;;
          "playbacks") list_playbacks "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "set")
        case "${CMD[1]}" in
          "profile") set_profile "${CMD[2]}" "${CMD[3]}";;
          "output") set_output "${CMD[2]}" "${CMD[3]}";;
          "input") set_input "${CMD[2]}" "${CMD[3]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "mute")
        case "${CMD[1]}" in
          "all") set_mute "all" 1;;
          "outputs") set_mute "outputs" 1;;
          "inputs") set_mute "inputs" 1;;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "unmute")
        case "${CMD[1]}" in
          "all") set_mute "all" 0;;
          "outputs") set_mute "outputs" 0;;
          "inputs") set_mute "inputs" 0;;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      *) echo "Unknown or invalid command: '$REPLY'";; 
    esac
  done

  clear
}

loop
