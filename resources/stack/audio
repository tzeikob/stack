#!/usr/bin/env bash

set -o pipefail
source /opt/stack/utils

require "libpulse"
require "jq"

card () {
  local VALUE=$1

  local KEY="index"
  if [[ ! "$VALUE" =~ ^[0-9]+$ ]]; then
    KEY="name"
    VALUE="\"$VALUE\""
  fi

  local QUERY=".[]|select(.${KEY}==${VALUE})"
  local CARD=$(pactl --format=json list cards | jq -cer "$QUERY" || echo "err:$?")

  if [[ "$CARD" =~ ^err: ]]; then
    return 1
  fi

  echo "$CARD"
}

pick_card () {
  local QUERY='[.[]|("\(.properties."device.nick")'$KVS'\(.index)")]|join("'$AES'")'
  local CARDS="$(pactl --format=json list cards | jq -cer "$QUERY")"

  local LEN=$(count "$CARDS")

  if [ ! $LEN -gt 0 ]; then
    echo "No audio cards have found"
    return 1
  fi
  
  pick_one "Select an audio card:" "$CARDS" "vertical-4"
}

pick_profile () {
  local CARD=$1

  local QUERY="[.profiles|to_entries|.[]|"
  QUERY+='("\(.value.description)'$KVS'\(.key)")]|join("'$AES'")'

  local PROFILES="$(echo "$CARD" | jq -cer "$QUERY")"
  local LEN=$(count "$PROFILES")

  if [ ! $LEN -gt 0 ]; then
    echo "No audio profiles found for card $ID"
    return 1
  fi
  
  pick_one "Select an audio profile:" "$PROFILES" "vertical-5"
}

pick_module () {
  local TYPE=$1

  local QUERY='[.[]|=.|map((.ports[] + {index, properties}))|.[]|'
  QUERY+='{index: .index, type: .type, device: .properties."device.nick"}]|to_entries|[.[]|'
  QUERY+='("\(.value.device) [\(.value.type)]'$KVS'\(.value.index)")]|join("'$AES'")'

  local MODULES="$(pactl --format=json list "$TYPE"s | jq -cer "$QUERY")"
  local LEN=$(count "$MODULES")

  if [ ! $LEN -gt 0 ]; then
    echo "No $TYPE audio modules have found"
    return 1
  fi
  
  pick_one "Select an audio module:" "$MODULES" "vertical-5"
}

prompt () {
  local DEFAULT="$(pactl get-default-sink)"
  local QUERY='.[]|select(.name == "'$DEFAULT'")|.active_port'
  local SINK=$(pactl --format=json list sinks | jq -cer "$QUERY")
  [ "$SINK" = "null" ] && SINK="off"

  local STATUS="$YE${SINK}$RS"

  read -rep "[audio:${STATUS}] " REPLY
}

show_status () {
  systemctl --user status --lines 0 --no-pager pipewire-pulse.service
  echo

  local QUERY='("'
  QUERY+='Server:    \(.server_name)\n'
  QUERY+='Path:      \(.server_string)\n'
  QUERY+='Version:   \(.server_version)\n'
  QUERY+='Local:     \(.is_local)\n'
  QUERY+='Client:    \(.client_index)\n'
  QUERY+='Sample:    \(.default_sample_specification)\n'
  QUERY+='Channels:  \(.default_channel_map)")'

  pactl --format=json info | jq -cr "$QUERY"

  echo -n "Cards:     "
  QUERY='[.[]|.active_profile as $p|{device: .properties."device.nick",'
  QUERY+='profile: (.profiles|to_entries|.[]|select(.key==$p)|.value.description)}|'
  QUERY+='("\(.device) [\(.profile)]")]|join("\n           ")'

  pactl --format=json list cards | jq -cr "$QUERY"

  local SINK_NAME=$(pactl get-default-sink)
  QUERY='.[]|select(.name == "'$SINK_NAME'")|'
  QUERY+='{n: .active_port, d: .description, m: .mute, v: (.volume|keys[0] as $k|.[$k].db|gsub("\\s+";""))}|("\n'
  QUERY+='Output:    \(.n)\n'
  QUERY+='Desc:      \(.d)\n'
  QUERY+='Muted:     \(.m)\n'
  QUERY+='Volume:    \(.v)")'

  pactl --format=json list sinks | jq -cr "$QUERY"

  local SOURCE_NAME=$(pactl get-default-source)
  QUERY='.[]|select(.name == "'$SOURCE_NAME'")|'
  QUERY+='{n: .active_port, d: .description, m: .mute, v: (.volume|keys[0] as $k|.[$k].db|gsub("\\s+";""))}|("\n'
  QUERY+='Input:     \(.n)\n'
  QUERY+='Desc:      \(.d)\n'
  QUERY+='Muted:     \(.m)\n'
  QUERY+='Volume:    \(.v)")'

  pactl --format=json list sources | jq -cr "$QUERY"
}

show_logs () {
  systemctl --user status --no-pager pipewire-pulse.service | tail -n +12
}

show_card () {
  local ID=$1

  if [ -z "$ID" ]; then
    pick_card || return 1
    [ -z "$REPLY" ] && return

    ID="$(value "$REPLY")"
  fi

  local CARD=$(card "$ID" || echo "err:$?")

  if [[ "$CARD" =~ ^err: ]]; then
    echo "Unable to find audio card $ID"
    return 1
  fi

  local QUERY='("'
  QUERY+='ID:             \(.index)\n'
  QUERY+='Device:         \(.properties."device.name")\n'
  QUERY+='Name:           \(.name)\n'
  QUERY+='Desc:           \(.properties."device.description")\n'
  QUERY+='Model:          \(.properties."device.nick")\n'
  QUERY+='Product:        \(.properties."device.product.name") [\(.properties."device.product.id")]\n'
  QUERY+='Vendor:         \(.properties."device.vendor.name") [\(.properties."device.vendor.id")]\n'
  QUERY+='Alsa Path:      \(.properties."api.alsa.path")\n'
  QUERY+='Alsa Card:      \(.properties."api.alsa.card.name") [\(.properties."api.alsa.card")]\n'
  QUERY+='Driver:         \(.driver)\n'
  QUERY+='Form:           \(.properties."device.form_factor")\n'
  QUERY+='Bus:            \(.properties."device.bus" | ascii_upcase)\n'
  QUERY+='Bus Path:       \(.properties."device.bus_path")\n'
  QUERY+='API:            \(.properties."device.api")\n'
  QUERY+='Usec:           \(.properties."device.plugged.usec")\n'
  QUERY+='SysFS Path:     \(.properties."sysfs.path")\n'
  QUERY+='Subsystem:      \(.properties."device.subsystem")\n'
  QUERY+='ACP:            \(.properties."api.alsa.use-acp")\n'
  QUERY+='Devicel:        \(.properties."api.dbus.ReserveDevice1")\n'
  QUERY+='Object Path:    \(.properties."object.path")\n'
  QUERY+='Profile:        \(.active_profile)")'
  echo "$CARD" | jq -cr "$QUERY"

  QUERY='.profiles|[keys[]]|join("\n                ")'
  echo -n "Profiles:       "
  echo "$CARD" | jq -cr "$QUERY"

  QUERY='[.ports|to_entries[]|"\(.key) [\(.value.type)]"]|join("\n                ")'
  echo -n "Ports:          "
  echo "$CARD" | jq -cr "$QUERY"
}

restart () {
  echo "Restarting the audio server..."
  systemctl --user restart pipewire.socket && sleep 0.5 &&
  echo "Pipewire socket restarted" &&
  systemctl --user restart pipewire.service && sleep 0.5 &&
  echo "Pipewire service restarted" &&
  systemctl --user restart pipewire-session-manager.service && sleep 0.5 &&
  systemctl --user restart pipewire-media-session.service && sleep 0.5 &&
  systemctl --user restart pipewire-pulse.socket && sleep 0.5 &&
  echo "Pulse socket restarted" &&
  systemctl --user restart pipewire-pulse.service && sleep 0.5 &&
  echo "Pulse service restarted" &&
  echo "Audio server has been restarted" &&
  (~/.config/polybar/launch &> /dev/null &) ||
    echo "An error occurred restarting the audio server"
}

list_cards () {
  local CARDS="$(pactl --format=json list cards)"
  local COUNT=$(echo "$CARDS" | jq -cer '.|length')

  if [ ! $COUNT -gt 0 ]; then
    echo "No audio cards have found"
    return
  fi

  local QUERY='.[]|.active_profile as $p|. +'
  QUERY+='{profile: (.profiles|to_entries|.[]|select(.key==$p)|.value.description)}|("\n'
  QUERY+='ID:      \(.index)\n'
  QUERY+='Name:    \(.name)\n'
  QUERY+='Bus:     \(.properties."device.bus" | ascii_upcase)\n'
  QUERY+='Profile: \(.profile)\n'
  QUERY+='Product: \(.properties."device.nick")\n'
  QUERY+='Vendor:  \(.properties."device.vendor.name")")'

  echo "$CARDS" | jq -cr "$QUERY" | tail -n +2
}

list_ports () {
  local TYPE=$1

  if [[ ! "$TYPE" =~ ^(sink|source)$ ]]; then
    echo "Invalid audio module type argument"
    return 1
  fi

  local MODULES="$(pactl --format=json list "$TYPE"s)"
  local COUNT=$(echo "$MODULES" | jq -cer '.|length')

  if [ ! $COUNT -gt 0 ]; then
    echo "No $TYPE audio modules have found"
    return
  fi

  local QUERY='.[]|= . + {"module_name": .name}|'
  QUERY+='map((.ports[] + {index, module_name, description, state, mute, properties,'
  QUERY+='volume: (.volume|keys[0] as $k|.[$k].db|gsub("\\s+";""))}))|'
  QUERY+='.[]|("\n'
  QUERY+='ID:      \(.index)\n'
  QUERY+='Name:    \(.module_name)\n'
  QUERY+='Desc:    \(.description)\n'
  QUERY+='Handle:  \(.name)\n'
  QUERY+='Type:    \(.type)\n'
  QUERY+='Mute:    \(.mute)\n'
  QUERY+='Volume:  \(.volume)\n'
  QUERY+='State:   \(.state|ascii_downcase)\n'
  QUERY+='Status:  \(.availability)\n'
  QUERY+='Device:  \(.properties."device.nick")")'

  echo "$MODULES" | jq -cer "$QUERY" | tail -n +2
}

list_playbacks () {
  local NAME=$1

  local SINK_INPUTS="$(pactl --format=json list sink-inputs)"

  local QUERY='[.[]|select(.properties."application.name"|test("'${NAME}'"; "i"))]'
  local COUNT=$(echo "$SINK_INPUTS" | jq -cr "$QUERY|length")

  if [ ! $COUNT -gt 0 ]; then
    echo "No playbacks have found $([ -n "$NAME" ] && echo "for $NAME")"
    return
  fi

  QUERY+='|.[]|("\n'
  QUERY+='ID:       \(.index)\n'
  QUERY+='Process:  \(.properties."application.process.id")\n'
  QUERY+='Name:     \(.properties."application.name")\n'
  QUERY+='Media:    \(.properties."media.name")\n'
  QUERY+='Mute:     \(.mute)\n'
  QUERY+='Volume:   \(.volume|keys[0] as $k|.[$k].db|gsub("\\s+";""))")'

  echo "$SINK_INPUTS" | jq -cr "$QUERY" | tail -n +2
}

set_profile () {
  local ID=$1
  local PROFILE=$2

  if [ -z "$ID" ]; then
    pick_card || return 1
    [ -z "$REPLY" ] && return

    ID="$(value "$REPLY")"
  fi

  local CARD=$(card "$ID" || echo "err:$?")

  if [[ "$CARD" =~ ^err: ]]; then
    echo "Unable to find audio card $ID"
    return 1
  fi

  if [ -z "$PROFILE" ]; then
    pick_profile "$CARD" || return 1
    [ -z "$REPLY" ] && return
    
    PROFILE="$(value "$REPLY")"
  fi

  pactl set-card-profile "$ID" "$PROFILE" && sleep 0.1 &&
    echo "Audio profile has been set successfully" ||
    echo "Failed to set the audio profile"
}

set_default () {
  local TYPE=$1
  local MODULE=$2

  if [[ ! "$TYPE" =~ ^(sink|source)$ ]]; then
    echo "Invalid audio module type argument"
    return 1
  fi

  if [ -z "$MODULE" ]; then
    pick_module "$TYPE" || return 1
    [ -z "$REPLY" ] && return

    MODULE="$(value "$REPLY")"
  fi

  pactl set-default-$TYPE "$MODULE" && sleep 0.1 &&
    echo "Active $TYPE has been set successfully" ||
    echo "Failed to set the active $TYPE"
}

turn_default () {
  local TYPE=$1
  local TO=$2

  if [[ ! "$TYPE" =~ ^(sink|source)$ ]]; then
    echo "Invalid audio module type argument"
    return 1
  fi

  if [[ ! "$TO" =~ ^(up|down|mute|unmute|[0-9]+)$ ]]; then
    echo "Invalid volume argument"
    return 1
  elif [[ "$TO" =~ ^[0-9]+$ ]] && ! (($TO >= 0 && $TO <= 150)); then
    echo "Volume is out of the valid [0,150] range"
    return 1
  fi

  local MODULE="$(pactl get-default-$TYPE)"
  
  if [ "$TO" = "mute" ]; then
    pactl set-${TYPE}-mute "$MODULE" 1 && sleep 0.1 &&
      echo "Active $TYPE volume set to mute" ||
      echo "Failed to set active $TYPE to mute"
    return
  elif [ "$TO" = "unmute" ]; then
    pactl set-${TYPE}-mute "$MODULE" 0 && sleep 0.1 &&
      echo "Active $TYPE volume set to unmute" ||
      echo "Failed to set active $TYPE to unmute"
    return
  fi

  local VOLUME=$TO

  if [ "$TO" = "up" ]; then
    VOLUME="+5"
  elif [ "$TO" = "down" ]; then
    VOLUME="-5"
  fi

  pactl set-${TYPE}-mute "$MODULE" 0 &&
  pactl set-${TYPE}-volume "$MODULE" "${VOLUME}%" && sleep 0.1 &&
    echo "Active $TYPE volume set to ${VOLUME}%" ||
    echo "Failed to set the volume of active $TYPE"
}

set_mute () {
  local TYPE=$1
  local MUTE=$2

  if [[ ! "$TYPE" =~ ^(sink|source)$ ]]; then
    echo "Invalid audio module type argument"
    return 1
  fi

  if [[ ! "$MUTE" =~ ^(1|0)$ ]]; then
    echo "Invalid mute argument"
    return 1
  fi

  local MODULES="$(pactl --format=json list "$TYPE"s | jq -cer '[.[].name]|join("'$AES'")')"
  local LEN=$(count "$MODULES")

  if [ ! $LEN -gt 0 ]; then
    echo "No $TYPE audio modules have found"
    return 1
  fi

  local STATUS="mute"
  [ $MUTE = 0 ] && STATUS="unmute"

  local INDEX=0
  for ((INDEX=0; INDEX<$LEN; INDEX++)); do
    local MODULE="$(element "$MODULES" "$INDEX" | value)"

    pactl set-$TYPE-mute "$MODULE" "$MUTE" && sleep 0.1 &&
      echo "Module $MODULE set to $STATUS" ||
      echo "Module $MODULE failed to $STATUS"
  done
}

help () {
  if [ "$1" = "once" ]; then
    echo "Usage: audio COMMAND [OBJECT] [ARGUMENTS]..."

    echo -e "\nCOMMANDS"
    printf " %-12s\t%s\n" \
      "help" "Show this help message." \
      "" "" \
      "set profile" "Set the active profile of an audio card." \
      "set output" "Set the active audio output." \
      "" "" \
      "up" "Increase the volume of active audio output." \
      "down" "Decrease the volume of active audio output." \
      "mute" "Mute the active audio output." \
      "unmute" "Unmute the active audio output." \
      "" "" \
      "restart" "Restart the audio server."

    return
  fi

  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf " %-32s\t%s\n" \
    "help" "Show this help message." \
    "show status" "Show a report of the system's audio." \
    "show logs" "Show the logs of the audio service." \
    "show card [<id>]" "Show the data of the given audio card." \
    "" "" \
    "list cards" "List all audio cards of the system." \
    "list outputs" "List all audio output ports." \
    "list inputs" "List all audio input ports." \
    "list playbacks [<name>]" "List all active playbacks or by application name." \
    "" "" \
    "set profile [<card> [<name>]]" "Set the active profile of an audio card." \
    "set output [<id>]" "Set the active audio output." \
    "set input [<id>]" "Set the active audio input." \
    "" "" \
    "turn output|input <volume>" "Turn the volume of active output/input to," \
    "" "up/down, mute/unmute or a percentage value." \
    "mute outputs|inputs" "Mute all audio outputs or inputs." \
    "unmute outputs|inputs" "Unmute all audio outputs or inputs." \
    "" "" \
    "restart" "Restart the audio server."
}

loop () {
  clear

  while true; do
    prompt && history -s "$REPLY"

    set -f
    set_separator "line"
    local CMD=($(xargs -n1 <<< "$REPLY"))
    restore_separator && set +f

    if [ "${CMD[0]}" = "help" ]; then
      help
      continue
    elif [ "${CMD[0]}" = "clear" ]; then
      clear
      continue
    elif [ "${CMD[0]}" = "quit" ]; then
      break
    elif [ -z "${CMD[0]}" ]; then
      continue
    fi

    case "${CMD[0]}" in
      "show")
        case "${CMD[1]}" in
          "status") show_status;;
          "logs") show_logs;;
          "card") show_card "${CMD[2]}";;
          *) echo "Unknown or invalid command";;
        esac;;
      "restart") restart;;
      "list")
        case "${CMD[1]}" in
          "cards") list_cards;;
          "outputs") list_ports sink;;
          "inputs") list_ports "source";;
          "playbacks") list_playbacks "${CMD[2]}";;
          *) echo "Unknown or invalid command";;
        esac;;
      "set")
        case "${CMD[1]}" in
          "profile") set_profile "${CMD[2]}" "${CMD[3]}";;
          "output") set_default sink "${CMD[2]}";;
          "input") set_default "source" "${CMD[2]}";;
          *) echo "Unknown or invalid command";;
        esac;;
      "turn")
        case "${CMD[1]}" in
          "output") turn_default sink "${CMD[2]}";;
          "input") turn_default "source" "${CMD[2]}";;
          *) echo "Unknown or invalid command";;
        esac;;
      "mute")
        case "${CMD[1]}" in
          "outputs") set_mute sink 1;;
          "inputs") set_mute "source" 1;;
          *) echo "Unknown or invalid command";;
        esac;;
      "unmute")
        case "${CMD[1]}" in
          "outputs") set_mute sink 0;;
          "inputs") set_mute "source" 0;;
          *) echo "Unknown or invalid command";;
        esac;;
      *) echo "Unknown or invalid command";; 
    esac
  done

  clear
}

once () {
  case "$1" in
    "help") help once;;
    "restart") restart;;
    "set")
      case "$2" in
        "profile") set_profile;;
        "output") set_default sink;;
        *) abort "Unknown or invalid command";; 
      esac;;
    "mute") turn_default sink mute;;
    "unmute") turn_default sink unmute;;
    "up") turn_default sink up;;
    "down") turn_default sink down;;
    *) abort "Unknown or invalid command";; 
  esac
}

if [ $# = 0 ]; then
  loop
else
  once "$@"
fi
