#!/usr/bin/env bash

set -o pipefail

source /opt/stack/utils

require "libpulse"
require "jq"

pick_card () {
  local QUERY='sort_by(.index) | to_entries | .[]'
  QUERY+='| ("\(.key)|\(.value.index)|\(.value.properties."device.nick")")'
  local CARDS=$(pactl --format=json list cards | jq -cer "$QUERY" | sed -r 's/\s+/_/g' || echo "err:$?")
  
  if [[ "$CARDS" =~ ^err: ]]; then
    echo "Unable to find audio cards"
    return 1
  fi
  
  CARDS=($CARDS)

  if [ ! ${#CARDS[@]} -gt 0 ]; then
    echo "No audio cards have found"
    return 1
  fi
  
  pick "Select an audio card:" "${CARDS[@]}"
  REPLY=$(echo "${CARDS[$REPLY]}" | cut -d '|' -f 2)
}

pick_profile () {
  local CARD=$1

  local KEY="index"
  local VALUE=$CARD

  if [[ ! "$CARD" =~ ^[0-9]+$ ]]; then
    KEY="name"
    VALUE="\"${CARD}\""
  fi

  local QUERY="[.[] | select(.${KEY}==${VALUE}) | .profiles | to_entries | .[]"
  QUERY+='| {name: .key, desc: .value.description}] | to_entries | .[]'
  QUERY+='| ("\(.key)|\(.value.name)|\(.value.desc)")'
  local PROFILES=$(pactl --format=json list cards | jq -cer "$QUERY" | sed -r 's/\s+/_/g' || echo "err:$?")
  
  if [[ "$PROFILES" =~ ^err: ]]; then
    echo "Unable to find audio profiles for card: '$CARD'"
    return 1
  fi
  
  PROFILES=($PROFILES)

  if [ ! ${#PROFILES[@]} -gt 0 ]; then
    echo "No audio profiles have found"
    return 1
  fi
  
  pick "Select an audio profile:" "${PROFILES[@]}"
  REPLY=$(echo "${PROFILES[$REPLY]}" | cut -d '|' -f 2)
}

pick_module () {
  local TYPE=$1

  local QUERY='[.[] |= . | map((.ports[] + {index, properties}))'
  QUERY+='| .[] | {index: .index, type: .type, device: .properties."device.nick"}]'
  QUERY+='| sort_by(.index) | to_entries | .[]'
  QUERY+='| ("\(.key)|\(.value.index)|\(.value.device)_[\(.value.type)]")'

  local MODULES=$(pactl --format=json list "$TYPE"s | jq -cer "$QUERY" | sed -r 's/\s+/_/g' || echo "err:$?")
  
  if [[ "$MODULES" =~ ^err: ]]; then
    echo "Unable to find audio $TYPE modules"
    return 1
  fi
  
  MODULES=($MODULES)

  if [ ! ${#MODULES[@]} -gt 0 ]; then
    echo "No audio $TYPE modules have found"
    return 1
  fi
  
  pick "Select an audio module:" "${MODULES[@]}"
  REPLY=$(echo "${MODULES[$REPLY]}" | cut -d '|' -f 2)
}

prompt () {
  local CARDS=$(pactl --format=json list short cards | jq -cer '.|length' || echo "err:$?")

  if [[ "$CARDS" =~ ^err: ]] || [ $CARDS = 0 ]; then
    read -rep "[audio:${RE}none$RS] " REPLY
    return 1
  fi

  local DEFAULT=$(pactl get-default-sink || echo "err:$?")

  if [[ "$DEFAULT" =~ ^err: ]]; then
    read -rep "[audio:${RE}none$RS] " REPLY
    return 1
  fi

  local QUERY='.[] | select(.name == "'$DEFAULT'")'
  local SINK=$(pactl --format=json list sinks | jq -cer "$QUERY" || echo "err:$?")

  if [[ "$SINK" =~ ^err: ]]; then
    read -rep "[audio:${RE}none$RS] " REPLY
    return 1
  fi

  local PORT=$(echo "$SINK" | jq -cr '.active_port')
  local MUTE=$(echo "$SINK" | jq -cr '.mute')
  local DB=$(echo "$SINK" | jq -cr '.volume | keys[0] as $k | .[$k].db' | awk '{print $1$2}')

  local STATUS="$YE${PORT}$RS"

  if [ "$MUTE" = "true" ]; then
    STATUS+=" ${MA}muted$RS"
  elif [[ "$DB" =~ ^(-|0.00) ]]; then
    STATUS+=" $GR${DB}$RS"
  else
    STATUS+=" $MA${DB}$RS"
  fi

  read -rep "[audio:${STATUS}] " REPLY
}

show_status () {
  systemctl --user status --lines 0 --no-pager pipewire.service
  echo
  systemctl --user status --lines 0 --no-pager pipewire-pulse.service
  echo

  local QUERY='("'
  QUERY+='Server:    \(.server_name)\n'
  QUERY+='Path:      \(.server_string)\n'
  QUERY+='Version:   \(.server_version)\n'
  QUERY+='Local:     \(.is_local)\n'
  QUERY+='Client:    \(.client_index)\n'
  QUERY+='Sample:    \(.default_sample_specification)\n'
  QUERY+='Channels:  \(.default_channel_map)\n'
  QUERY+='Sink:      \(.default_sink_name)\n'
  QUERY+='Source:    \(.default_source_name)")'

  pactl --format=json info | jq -cr "$QUERY"

  echo -n "Cards:     "
  QUERY='[.[] | .active_profile as $p |'
  QUERY+='{device: .properties."device.nick",'
  QUERY+='profile: (.profiles | to_entries | .[] | select(.key==$p) | .value.description)}'
  QUERY+='| ("\(.device) [\(.profile)]")] | join("\n           ")'

  pactl --format=json list cards | jq -cr "$QUERY"
}

show_logs () {
  echo "Pipewire Service:"
  echo "-----------------"
  systemctl --user status --no-pager pipewire.service | tail -n +12

  echo -e "\nPulse Service:"
  echo "--------------"
  systemctl --user status --no-pager pipewire-pulse.service | tail -n +12
}

show_card () {
  local CARD=$1

  if [ -z "$CARD" ]; then
    pick_card || return 1
    CARD=$REPLY
  fi

  local KEY="index"
  local VALUE=$CARD

  if [[ ! "$CARD" =~ ^[0-9]+$ ]]; then
    KEY="name"
    VALUE="\"${CARD}\""
  fi

  local QUERY=".[] | select(.${KEY}==${VALUE})"
  CARD=$(pactl --format=json list cards | jq -cer "$QUERY" || echo "err:$?")

  if [[ "$CARD" =~ ^err: ]]; then
    echo "Unable to find audio cards"
    return 1
  fi

  QUERY='("ID:                 \(.index)\n'
  QUERY+='Name:               \(.name)\n'
  QUERY+='Driver:             \(.driver)\n'
  QUERY+='Owner:              \(.owner_module)\n'
  QUERY+='Enum API:           \(.properties."device.enum.api")\n'
  QUERY+='Device API:         \(.properties."device.api")\n'
  QUERY+='Media Class:        \(.properties."media.class")\n'
  QUERY+='API Alsa Path:      \(.properties."api.alsa.path")\n'
  QUERY+='API Alsa Card:      \(.properties."api.alsa.card")\n'
  QUERY+='API Alsa Card Name: \(.properties."api.alsa.card.name")\n'
  QUERY+='Card Long Name:     \(.properties."api.alsa.card.longname")\n'
  QUERY+='Usec:               \(.properties."device.plugged.usec")\n'
  QUERY+='Bus Path:           \(.properties."device.bus_path")\n'
  QUERY+='SysFS Path:         \(.properties."sysfs.path")\n'
  QUERY+='Bus:                \(.properties."device.bus" | ascii_upcase)\n'
  QUERY+='Subsystem:          \(.properties."device.subsystem")\n'
  QUERY+='Vendor ID:          \(.properties."device.vendor.id")\n'
  QUERY+='Vendor Name:        \(.properties."device.vendor.name")\n'
  QUERY+='Product ID:         \(.properties."device.product.id")\n'
  QUERY+='Product Name:       \(.properties."device.product.name")\n'
  QUERY+='Form Factor:        \(.properties."device.form_factor")\n'
  QUERY+='Device Name:        \(.properties."device.name")\n'
  QUERY+='Description:        \(.properties."device.description")\n'
  QUERY+='Model:              \(.properties."device.nick")\n'
  QUERY+='Use ACP:            \(.properties."api.alsa.use-acp")\n'
  QUERY+='Auto Profile:       \(.properties."api.acp.auto-profile")\n'
  QUERY+='Auto Port:          \(.properties."api.acp.auto-port")\n'
  QUERY+='Reserve Devicel:    \(.properties."api.dbus.ReserveDevice1")\n'
  QUERY+='Factory:            \(.properties."factory.id")\n'
  QUERY+='Client ID:          \(.properties."client.id")\n'
  QUERY+='Object ID:          \(.properties."object.id")\n'
  QUERY+='Object Serial:      \(.properties."object.serial")\n'
  QUERY+='Object Path:        \(.properties."object.path")\n'
  QUERY+='Alsa Card:          \(.properties."alsa.card")\n'
  QUERY+='Active Profile:     \(.active_profile)")'
  echo "$CARD" | jq -cr "$QUERY"

  echo -e "\nProfiles:"
  echo "$CARD" | jq -cr '.profiles | " \(keys[])"'

  echo -e "\nPorts:"
  echo "$CARD" | jq -cr '.ports | to_entries[] | " \(.key) [\(.value.type)]"'
}

restart () {
  echo "Restarting the audio server..."
  systemctl --user restart pipewire.socket && sleep 0.5 &&
  echo " Pipewire socket restarted" &&
  systemctl --user restart pipewire.service && sleep 0.5 &&
  echo " Pipewire service restarted" &&
  systemctl --user restart pipewire-session-manager.service && sleep 0.5 &&
  systemctl --user restart pipewire-media-session.service && sleep 0.5 &&
  systemctl --user restart pipewire-pulse.socket && sleep 0.5 &&
  echo " Pulse socket restarted" &&
  systemctl --user restart pipewire-pulse.service && sleep 0.5 &&
  echo " Pulse service restarted" &&
  echo "Audio server has been restarted" &&
  polybar-msg cmd restart ||
    echo "An error occurred restarting the audio server"
}

list_cards () {
  local CARDS=$(pactl --format=json list cards || echo "err:$?")

  if [[ "$CARDS" =~ ^err: ]]; then
    echo "Unable to find audio cards"
    return 1
  fi

  local COUNT=$(echo "$CARDS" | jq -cer '.|length')

  if [ ! $COUNT -gt 0 ]; then
    echo "No audio cards have found"
    return
  fi

  local QUERY='.[] | .active_profile as $p'
  QUERY+='| . + {profile: (.profiles | to_entries | .[] | select(.key==$p) | .value.description)}'
  QUERY+='| ("\n'
  QUERY+='ID:      \(.index)\n'
  QUERY+='Name:    \(.name)\n'
  QUERY+='Device:  \(.properties."device.nick")\n'
  QUERY+='Vendor:  \(.properties."device.vendor.name")\n'
  QUERY+='Bus:     \(.properties."device.bus" | ascii_upcase)\n'
  QUERY+='Profile: \(.profile)")'

  echo "$CARDS" | jq -cr "$QUERY" | tail -n +2
}

list_profiles () {
  local CARD=$1

  if [ -z "$CARD" ]; then
    pick_card || return 1
    CARD=$REPLY
  fi

  local KEY="index"
  local VALUE=$CARD

  if [[ ! "$CARD" =~ ^[0-9]+$ ]]; then
    KEY="name"
    VALUE="\"${CARD}\""
  fi

  local QUERY=".[] | select(.${KEY}==${VALUE})"
  CARD=$(pactl --format=json list cards | jq -cer "$QUERY" || echo "err:$?")

  if [[ "$CARD" =~ ^err: ]]; then
    VALUE=$(echo $VALUE | tr -d '"')
    echo "Unable to find audio card: '$VALUE'"
    return 1
  fi

  local PROFILES=$(echo "$CARD" | jq -cr '.profiles | length')

  if [ ! $PROFILES -gt 0 ]; then
    echo "No audio profiles have found"
    return
  fi

  QUERY='.profiles | to_entries | .[] | ("\n'
  QUERY+='ID:     \(.key)\n'
  QUERY+='Desc:   \(.value.description)")'

  echo "$CARD" | jq -cr "$QUERY" | tail -n +2
}

list_ports () {
  local TYPE=$1

  if [[ ! "$TYPE" =~ ^(sinks|sources)$ ]]; then
    echo "Invalid module type argument"
    return 1
  fi

  local MODULES=$(pactl --format=json list "$TYPE" || echo "err:$?")

  if [[ "$MODULES" =~ ^err: ]]; then
    echo "Unable to find audio $TYPE modules"
    return 1
  fi

  local COUNT=$(echo "$MODULES" | jq -cer '.|length')

  if [ ! $COUNT -gt 0 ]; then
    echo "No audio $TYPE modules have found"
    return
  fi

  local QUERY='.[] |= . + {"module_name": .name} |'
  QUERY+='map((.ports[] + {index, module_name, description, state, mute, properties})) |'
  QUERY+='.[] | ("\n'
  QUERY+='ID:      \(.index)\n'
  QUERY+='Name:    \(.module_name)\n'
  QUERY+='Desc:    \(.description)\n'
  QUERY+='Handle:  \(.name)\n'
  QUERY+='Type:    \(.type)\n'
  QUERY+='Device:  \(.properties."device.nick")\n'
  QUERY+='Mute:    \(.mute)\n'
  QUERY+='State:   \(.state | ascii_downcase)\n'
  QUERY+='Status:  \(.availability)")'

  echo "$MODULES" | jq -cer "$QUERY" | tail -n +2
}

list_playbacks () {
  local NAME=$1

  local SINK_INPUTS=$(pactl --format=json list sink-inputs || echo "err:$?")

  if [[ "$SINK_INPUTS" =~ ^err: ]]; then
    echo "Unable to find audio playbacks"
    return 1
  fi

  local QUERY='[.[] | select(.properties."application.name"|test("'${NAME}'"; "i"))]'
  local COUNT=$(echo "$SINK_INPUTS" | jq -cr "$QUERY | length")

  if [ ! $COUNT -gt 0 ]; then
    echo "No audio playbacks have found"
    return
  fi

  QUERY+='|.[]|("\n'
  QUERY+='ID:       \(.index)\n'
  QUERY+='Process:  \(.properties."application.process.id")\n'
  QUERY+='Name:     \(.properties."application.name")\n'
  QUERY+='Media:    \(.properties."media.name")\n'
  QUERY+='Mute:     \(.mute)")'

  echo "$SINK_INPUTS" | jq -cr "$QUERY" | tail -n +2
}

set_profile () {
  local CARD=$1
  local PROFILE=$2

  if [ -z "$CARD" ]; then
    pick_card || return 1
    CARD=$REPLY
  fi

  if [ -z "$PROFILE" ]; then
    pick_profile "$CARD" || return 1
    PROFILE=$REPLY
  fi

  pactl set-card-profile "$CARD" "$PROFILE" && sleep 0.1 &&
    echo "Audio profile has been set successfully" ||
    echo "Unable to set the audio profile"
}

set_default () {
  local TYPE=$1
  local MODULE=$2

  if [[ ! "$TYPE" =~ ^(sink|source)$ ]]; then
    echo "Invalid module type argument"
    return 1
  fi

  if [ -z "$MODULE" ]; then
    pick_module "$TYPE" || return 1
    MODULE=$REPLY
  fi

  pactl set-default-$TYPE "$MODULE" && sleep 0.1 &&
    echo "Current $TYPE has been set successfully" ||
    echo "Unable to set the current $TYPE"
}

turn_default () {
  local TYPE=$1
  local TO=$2

  if [[ ! "$TYPE" =~ ^(sink|source)$ ]]; then
    echo "Invalid module type argument"
    return 1
  fi

  if [[ ! "$TO" =~ ^(up|down|mute|unmute|[0-9]+)$ ]]; then
    echo "Invalid volume argument: '$TO'"
    return 1
  elif [[ "$TO" =~ ^[0-9]+$ ]] && ! (($TO >= 0 && $TO <= 150)); then
    echo "Volume is out of the valid range: '$TO'"
    return 1
  fi

  local MODULE=$(pactl get-default-$TYPE || echo "err:$?")

  if [[ "$MODULE" =~ ^err: ]]; then
    echo "Unable to resolve current $TYPE module"
    return 1
  fi
  
  if [ "$TO" = "mute" ]; then
    pactl set-${TYPE}-mute "$MODULE" 1 && sleep 0.1 &&
      echo "Current $TYPE volume set to mute" ||
      echo "Unable to set current $TYPE to mute"
    return
  elif [ "$TO" = "unmute" ]; then
    pactl set-${TYPE}-mute "$MODULE" 0 && sleep 0.1 &&
      echo "Current $TYPE volume set to unmute" ||
      echo "Unable to set current $TYPE to unmute"
    return
  fi

  local VOLUME=$TO

  if [ "$TO" = "up" ]; then
    VOLUME="+5"
  elif [ "$TO" = "down" ]; then
    VOLUME="-5"
  fi

  pactl set-${TYPE}-mute "$MODULE" 0 &&
  pactl set-${TYPE}-volume "$MODULE" "${VOLUME}%" && sleep 0.1 &&
    echo "Current $TYPE volume set to ${VOLUME}%" ||
    echo "Unable to set current $TYPE volume"
}

set_mute () {
  local TYPE=$1
  local MUTE=$2

  if [[ ! "$TYPE" =~ ^(sinks|sources)$ ]]; then
    echo "Invalid module type argument: '$TYPE'"
    return 1
  fi

  if [[ ! "$MUTE" =~ ^(1|0)$ ]]; then
    echo "Invalid mute argument: '$MUTE'"
    return 1
  fi

  local MODULES=$(pactl --format=json list "$TYPE" | jq -cer '.[].name' || echo "err:$?")

  if [[ "$MODULES" =~ ^err: ]]; then
    echo "Unable to find audio $TYPE modules"
    return 1
  fi

  MODULES=($MODULES)
  local LEN=${#MODULES[@]}

  if [ ! $LEN -gt 0 ]; then
    echo "No $TYPE audio modules have found"
    return 1
  fi

  local MUTE_TEXT="mute"
  [ $MUTE = 0 ] && MUTE_TEXT="unmute"

  local INDEX=0
  local SUCCEED=0
  while [ $INDEX -lt $LEN ]; do
    local MODULE=${MODULES[INDEX]}

    pactl set-${TYPE::-1}-mute "$MODULE" "$MUTE" && sleep 0.1 &&
      SUCCEED=$((SUCCEED + 1)) ||
      echo "Unable to $MUTE_TEXT $TYPE module: '$MODULE'"

    INDEX=$((INDEX + 1))
  done

  if [ $SUCCEED = $LEN ]; then
    echo "All $TYPE audio modules set to $MUTE_TEXT"
  else
    echo "$TYPE audio modules have been partially $MUTE_TEXT"
  fi
}

help () {
  local FRM=" %-32s\t%s\n"

  if [ "$1" = "once" ]; then
    echo "Usage: audio COMMAND"

    echo -e "\nCOMMANDS"
    printf "$FRM" \
      "help" "Show this message." \
      "restart" "Restart the audio server." \
      "set profile" "Set the profile of an audio card." \
      "set output" "Set the current audio output." \
      "" "" \
      "mute" "Mute current output audio." \
      "unmute" "Unmute current output audio." \
      "up" "Increase output audio volume." \
      "down" "Decrease output audio volume."

    return
  fi

  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf "$FRM" \
    "help" "Show this help message." \
    "show status" "Show a report of the audio services." \
    "show logs" "Show the journal logs of audio services." \
    "show card <card>" "Show the data of the given card." \
    "restart" "Restart the audio server." \
    "" "" \
    "list cards" "List the cards plugged to the system." \
    "list profiles <card>" "List the profiles of the given card." \
    "list outputs" "List the ports of output modules." \
    "list inputs" "List the ports of input modules." \
    "list playbacks [<name>]" "List all active playbacks or those" \
    "" "which contain the given name filter." \
    "" "" \
    "set profile [<card> [<profile>]]" "Set the profile of the given card." \
    "set output <output>" "Set current output to the given output." \
    "set input <input>" "Set current input to the given input." \
    "" "" \
    "turn output up|down|<volume>" "Turn the volume of the current output." \
    "turn input up|down|<volume>" "Turn the volume of the current input." \
    "mute output|input" "Mute the current output or input." \
    "unmute output|input" "Unmute the current output or input." \
    "mute outputs|inputs" "Mute all output or input audio modules." \
    "unmute outputs|inputs" "Unmute all output or input audio modules."

  echo -e "\nOBJECTS"
  printf "$FRM" \
    "status" "The status of the system's audio." \
    "card" "An audio card." \
    "profile" "An audio profile of a card." \
    "output" "An output audio port (speaker)." \
    "input" "An input audio port (microphone)." \
    "playback" "An application or process streaming audio."
}

loop () {
  clear

  while true; do
    prompt && history -s "$REPLY"

    set -f
    local OLD_IFS=$IFS && IFS=$'\n'
    local CMD=($(xargs -n1 <<< "$REPLY"))
    IFS=$OLD_IFS && set +f

    if [ "${CMD[0]}" = "help" ]; then
      help
      continue
    elif [ "${CMD[0]}" = "clear" ]; then
      clear
      continue
    elif [ "${CMD[0]}" = "quit" ]; then
      break
    elif [ -z "${CMD[0]}" ]; then
      continue
    fi

    case "${CMD[0]}" in
      "show")
        case "${CMD[1]}" in
          "status") show_status;;
          "logs") show_logs;;
          "card") show_card "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "restart") restart;;
      "list")
        case "${CMD[1]}" in
          "cards") list_cards;;
          "profiles") list_profiles "${CMD[2]}";;
          "outputs") list_ports "sinks";;
          "inputs") list_ports "sources";;
          "playbacks") list_playbacks "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "set")
        case "${CMD[1]}" in
          "profile") set_profile "${CMD[2]}" "${CMD[3]}";;
          "output") set_default "sink" "${CMD[2]}";;
          "input") set_default "source" "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "turn")
        case "${CMD[1]}" in
          "output") turn_default "sink" "${CMD[2]}";;
          "input") turn_default "source" "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "mute")
        case "${CMD[1]}" in
          "output") turn_default "sink" "mute";;
          "outputs") set_mute "sinks" 1;;
          "input") turn_default "source" "mute";;
          "inputs") set_mute "sources" 1;;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "unmute")
        case "${CMD[1]}" in
          "output") turn_default "sink" "unmute";;
          "outputs") set_mute "sinks" 0;;
          "input") turn_default "source" "unmute";;
          "inputs") set_mute "sources" 0;;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      *) echo "Unknown or invalid command: '$REPLY'";; 
    esac
  done

  clear
}

once () {
  local CMD=$1

  case "$CMD" in
    "help") help "once";;
    "restart") restart;;
    "set")
      case "$2" in
        "profile") set_profile;;
        "output") set_default "sink";;
        *) abort "Unknown or invalid command: '$1'";; 
      esac;;
    "mute") turn_default "sink" "mute";;
    "unmute") turn_default "sink" "unmute";;
    "up") turn_default "sink" "up";;
    "down") turn_default "sink" "down";;
    *) abort "Unknown or invalid command: '$1'";; 
  esac
}

if [ $# = 0 ]; then
  loop
else
  once "$@"
fi
