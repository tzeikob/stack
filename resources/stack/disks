#!/bin/bash

set -o pipefail
source /opt/stack/utils

require "udisks2"
require "glib2"
require "nmap"
require "smbclient"
require "smartmontools"

# Returns the list of block devices of the given
# types being in the given status.
# Arguments:
#  type:   a comma-sep list of disk, part, rom or all
#  status: mounted, unmounted or all
# Outputs:
#  A json array list of device objects.
find_devices () {
  local type="${1}"
  local status="${2}"

  local query='.blockdevices[]'

  if [[ -n "${type}" ]] && [[ "${type}" != "all" ]]; then
    query+="$(echo "${type}" | awk -F',' '{
      criteria=""
      for (i=1; i<=NF; i++) {
        if (i > 1) criteria=criteria " or "
        criteria=criteria "(.type == \"" $i "\")"
      }
      print "|select(" criteria ")"
    }')"
  fi
  
  if [[ "${status}" == "mounted" ]]; then
    query+='|select(.mountpoints != [null])'
  elif [[ "${status}" == "unmounted" ]]; then
    query+='|select(.mountpoints == [null])'
  fi

  query="[${query}]"

  local fields='PATH,TYPE,VENDOR,LABEL,SIZE,MOUNTPOINT,'
  fields+='MOUNTPOINTS,RM,RO,FSTYPE,MODEL'

  lsblk -J -o "${fields}" | jq -cer "${query}" || return 1
}

# Returns the device with the given path.
# Arguments:
#  path: the device path
# Outputs:
#  A json object of a device.
find_device () {
  local path="${1}"

  local fields='NAME,PATH,LABEL,UUID,VENDOR,MODEL,REV,'
  fields+='SERIAL,TYPE,TRAN,RM,RO,HOTPLUG,FSTYPE,FSVER,'
  fields+='SIZE,FSAVAIL,FSUSED,FSUSE%,MOUNTPOINT,MOUNTPOINTS,STATE'

  lsblk -J -o "${fields}" "${path}" | jq -cer '.blockdevices[0]' || return 1
}

# Returns the list of any detected hosts in the
# local network.
# Arguments:
#  None
# Outputs:
#  A json array list of host objects.
find_hosts () {
  local route=''
  route="$(ip route get 1.1.1.1)" || return 1

  local cidr=''
  cidr="$(echo "${route}" | awk '/via/{print $3}' |
    head -n 1 | sed -r 's/(\.[0-9]{1,3}$)/.0\/24/')" || return 1

  local map=''
  map="$(nmap -n -sn "${cidr}" -oG -)" || return 1

  local ips=''
  ips="$(echo "${map}" | awk '/Up$/{print $2}')" || return 1

  local ip=''
  local hosts=''

  while read -r ip; do
    local host_map=''
    host_map="$(nmap --host-timeout 5 "${ip}" -oG -)" || continue

    hosts+="$(echo "${host_map}" | awk '/Host.*Up/{
      gsub(/(\(|\))/,"",$3);
      print "{\"ip\":\""$2"\",\"name\":\""$3"\"},"
    }')"
  done <<< "${ips}"

  # Remove the extra comma after the last element
  if [[ -n "${hosts}" ]]; then
    hosts="${hosts::-1}"
  fi

  echo "[${hosts}]"
}

# Returns the list of shared folders of the given
# host available in the local network.
# Arguments:
#  host:      the name or ip of a host
#  username:  the name of the user
#  workgroup: the group of the user
#  password:  the password of the user
# Outputs:
#  A json list of folder objects.
find_shared_folders () {
  local host="${1}"
  local username="${2}"
  local workgroup="${3}"
  local password="${4}"

  local folders=''
  folders="$(smbclient -L "${host}" -U "${username}" -W "${workgroup}" --password="${password}" |
    awk '/Disk/{print "{\"name\":\""$1"\",\"type\":\""$2"\"},"}')" || return 1

  # Remove the extra comma after the last element
  if [[ -n "${folders}" ]]; then
    folders="${folders::-1}"
  fi

  echo "[${folders}]"
}

# Shows a menu asking the user to select one device, where the
# answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  type:   a comma-sep list of disk, part, rom or all
#  status: mounted, unmounted or all
# Outputs:
#  A menu of devices.
pick_device () {
  local type="${1}"
  local status="${2}"

  local devices=''
  devices="$(find_devices "${type}" "${status}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find devices"
    return 2
  fi

  local len=0
  len="$(count "${devices}")" || return 1
  
  if [[ ${len} -eq 0 ]]; then
    echo "No devices have found"
    return 2
  fi

  local value=''
  value+='\(.path) ['
  value+='\(if .vendor then "\(.vendor|gsub("^\\s+|\\s+$";"")) " else "" end)'
  value+='\(if .label then "\(.label) " else "" end)'
  value+='\(.size)]'

  local query=''
  query="[.[]|{key: .path, value: \"${value}\"}]"

  devices="$(echo "${devices}" | jq -cer "${query}")" || return 1

  pick_one "Select a device:" "${devices}" "vertical" || return $?
}

# Shows a menu asking the user to select one host, where the
# answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of host names.
pick_host () {
  echo "Searching hosts in local network..."

  local hosts=''
  hosts="$(find_hosts)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find hosts"
    return 2
  fi

  local len=0
  len="$(count "${hosts}")" || return 1
  
  if [[ ${len} -eq 0 ]]; then
    echo "No hosts have found"
    return 2
  fi

  local query=''
  query='[.[]|{key: .ip, value: "\(.ip) [\(.name)]"}]'

  hosts="$(echo "${hosts}" | jq -cer "${query}")" || return 1

  pick_one "Select a host:" "${hosts}" "vertical" || return $?
}

# Shows a prompt status and asks user to enter the
# next command, which is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A minimal prompt status line.
prompt () {
  local query='.[]|select(.mountpoint == "/")|.path'

  local status=''
  status="$(find_devices "part" "mounted" | jq -cer "${query}")"

  if [[ $? -ne 0 ]]; then
    status='none'
  fi

  read -rep "[disks:${status}] " REPLY
}

# Shows a short status of the disks and filesystem.
# Arguments:
#  None
# Outputs:
#  A list of disks and filesystem data.
show_status () {
  local query='.[]|select(.mountpoint == "/" or .mountpoint == "/home")|.path'

  local part_paths=''
  part_paths="$(find_devices "part" | jq -cer "${query}")" || return 1

  local query=''
  query+='Partition:    \(.path):\(.mountpoint)\n'
  query+='File System:  \(.fstype|ascii_upcase) v\(.fsver)\n'
  query+='Total Size:   \(.size)\n'
  query+='Free Space:   \(.fsavail)\n'
  query+='Used Space:   \(.fsused) [\(."fsuse%")]\n'

  local part_path=''
  while read -r part_path; do
    find_device "${part_path}" | jq -cer "\"${query}\"" || return 1
  done <<< "${part_paths}"

  swapon --noheadings --show | awk -F' ' '{
    printf "%-13s %s\n", "Swap:", $1
    printf "%-13s %s\n", "Type:", $2
    printf "%-13s %s\n", "Used:", $4"/"$3
  }' || return 1

  cat /proc/meminfo | grep -E "Swap.*" | awk -F':' '{
    gsub(/^[ \t]+/,"",$1)
    gsub(/[ \t]+$/,"",$1)
    gsub(/^[ \t]+/,"",$2)
    gsub(/[ \t]+$/,"",$2)
    printf "%-13s %s\n", $1":", $2
  }' || return 1
}

# Shows the data of the block device with the given path.
# Globals:
#  REPLY
# Arguments:
#  path: the path of a block device
# Outputs:
#  A long text of device data.
show_device () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_device "all" || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]]; then
    echo "Invalid block device path"
    return 2
  fi

  local parts=''
  parts+='\(.path) \(if .mountpoints != [null] then "\(.mountpoints) " else "" end)'
  parts+='\(.fstype|ascii_upcase) '
  parts+='\(if .label then .label else "" end)'
  parts="Parts:         \([.children[]|\"${parts}\"]|join(\"\n              \"))"

  local query=''
  query+='Name:          \(.name)\n'
  query+='Path:          \(.path)\n'
  query+='Type:          \(.type)\n'
  query+='\(if .fstype then "File System:   \(.fstype|ascii_upcase)\n" else "" end)'
  query+='\(if .fsver then "File Version:  \(.fsver)\n" else "" end)'
  query+='Removable:     \(.rm)\n'
  query+='ReadOnly:      \(.ro)\n'
  query+='\(if .tran then "Transfer:      \(.tran)\n" else "" end)'
  query+='HotPlug:       \(.hotplug)\n'
  query+='Size:          \(.size)'
  query+='\(if .fsavail then "\nFree Space:    \(.fsavail)" else "" end)'
  query+='\(if .fsused then "\nUsed Space:    \(.fsused) [\(."fsuse%")]" else "" end)'
  query+='\(if .label then "\nLabel:         \(.label)" else "" end)'
  query+='\(if .uuid then "\nUUID:          \(.uuid)" else "" end)'
  query+='\(if .vendor then "\nVendor:        \(.vendor)" else "" end)'
  query+='\(if .model then "\nModel:         \(.model)" else "" end)'
  query+='\(if .rev then "\nRevision:      \(.rev)" else "" end)'
  query+='\(if .serial then "\nSerial:        \(.serial)" else "" end)'
  query+='\(if .state then "\nState:         \(.state)" else "" end)'
  query+='\(if .mountpoint then "\nMount:         \(.mountpoint)" else "" end)'
  query+='\(if .mountpoints != [null] then "\nMounts:        \(.mountpoints)" else "" end)'
  query+="\(if .children then \"\n${parts}\" else \"\" end)"

  find_device "${path}" | jq -cer "\"${query}\""

  if [[ $? -ne 0 ]]; then
    echo "Failed to read device data"
    return 2
  fi
}

# Scans the device with the given path for
# possible SMART data.
# Arguments:
#  path: the path of a block device
# Outputs:
#  A long list of health and status data.
scan_device () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_device "all" || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]]; then
    echo "Invalid block device path"
    return 2
  elif ! sudo smartctl -i "${path}" &> /dev/null; then
    echo "Unable to retrieve SMART data"
    return 2
  fi

  local model=''
  model+='if .model_name'
  model+=' then "\nModel:     \(.model_name) FW.\(.firmware_version)"'
  model+=' else ""'
  model+='end'

  local physicals=''
  physicals+='if .physical_block_size'
  physicals+=' then " P:\(.physical_block_size)"'
  physicals+=' else ""'
  physicals+='end'

  local factor=''
  factor+='if .form_factor.name'
  factor+=' then "\nFactor:    \(.form_factor.name) \(.rotation_rate) rpm"'
  factor+=' else ""'
  factor+='end'

  local sata=''
  sata+='if .sata_version.string'
  sata+=' then "\nSATA:      \(.sata_version.string) at \(.interface_speed.max.string)"'
  sata+=' else ""'
  sata+='end'

  local trim=''
  trim+='if .trim.supported'
  trim+=' then "\nTrim:      \(.trim.supported)"'
  trim+=' else ""'
  trim+='end'

  local passed=''
  passed+='if .smart_status.passed then "passed" else "failed" end'

  local temp=''
  temp+='if .temperature.current'
  temp+=' then "\nTemp:      \(.temperature.current)C"'
  temp+=' else ""'
  temp+='end'

  local attr=''
  attr+='Attr:      \(.id)\n'
  attr+='Name:      \(.name)\n'
  attr+='Raw:       \(.raw.value)\n'
  attr+='Values:    [V\(.value), W\(.worst), T\(.thresh)]\n'
  attr+='Failing:   \(.when_failed)'

  local attrs=''
  attrs+='.ata_smart_attributes.table as $a |'
  attrs+="if \$a then \"\n\n\([\$a[]|\"${attr}\"]|join(\"\n\n\"))\" else \"\" end"

  local query=''
  query+='Device:    \(.device.name)'
  query+="\(${model})"
  query+='\nProtocol:  \(.device.type|ascii_upcase) \(.device.protocol)'
  query+='\nCapacity:  \(.user_capacity.bytes) bytes'
  query+="\nBlocks:    L:\(.logical_block_size)\(${physicals})"
  query+="\(${factor})"
  query+="\(${trim})"
  query+="\(${sata})"
  query+='\nSMART:     \(.smart_support.enabled)'
  query+="\(${temp})"
  query+="\nHealth:    \(${passed})"
  query+="\(${attrs})"

  sudo smartctl -iHj "${path}" | jq -cer "\"${query}\""

  local code="$?"

  if [[ ${code} -ne 0 ]] && [[ ${code} -ne 24 ]]; then
    echo "Failed to read SMART data"
    return 2
  fi
}

# Shows the list of devices of the given type.
# Arguments:
#  type: disk, part, rom or all
# Outputs:
#  A list of devices.
list_devices () {
  local type="${1}"

  if [[ -n "${type}" ]] && [[ ! "${type}" =~ ^(disk|part|rom)$ ]]; then
    echo "Invalid device type value"
    return 2
  fi

  local devices=''
  devices="$(find_devices "${type}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read ${type:-\b} devices"
    return 2
  fi

  local len=0
  len="$(count "${devices}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No ${type:-\b} devices have found"
    return 0
  fi

  local query=''
  query+='Path:    \(.path)\n'
  query+='Type:    \(.type)\n'
  query+='Size:    \(.size)'
  query+='\(if .vendor then "\nVendor:  \(.vendor)" else "" end)'
  query+='\(if .model then "\nModel:   \(.model)" else "" end)'
  query+='\(if .label then "\nLabel:   \(.label)" else "" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${devices}" | jq -cer "${query}" || return 1
}

# Shows the list of shared folders of the given host.
# Globals:
#  REPLY
# Arguments:
#  host: the name or ip of a host.
# Outputs:
#  A list of shared folders.
list_shares () {
  local host="${1}"

  if [[ -z "${host}" ]]; then
    pick_host || return $?
    [[ -n "${REPLY}" ]] && host="${REPLY}" || return 0
  fi

  ask "Enter the username:" || return $?
  local username="${REPLY}"

  ask "Enter the workgroup [WORKGROUP]:" || return $?
  local workgroup="${REPLY:-"WORKGROUP"}"

  ask_password "Enter the password:"
  local password="${REPLY}"

  local folders=''
  folders="$(find_shared_folders "${host}" "${username}" "${workgroup}" "${password}" &>/dev/null)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to retrieve shared folders"
    return 2
  fi

  local len=0
  len="$(count "${folders}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No shared folders have found"
    return 0
  fi

  local query=''
  query+='Name:  \(.name)\n'
  query+='Type:  \(.type)'

  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${folders}" | jq -cer "${query}" || return 1
}

# Shows the list of mounted devices and shared folders.
# Globals:
#  UID
# Arguments:
#  None
# Outputs:
#  A list of mounted devices and shared folders.
list_mounts () {
  local devices=''
  devices="$(find_devices "part,rom" "mounted")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read mounted devices"
    return 2
  fi

  local folders=''
  folders="$(ls "/run/user/${UID}/gvfs" | awk -v id="${UID}" '{
    match($0, /server=(.*),share=(.*),/, a);
    print "\nDevice:  "a[1]"/"a[2]"\nPoints:  [/run/user/"id"/gvfs/"$0"]"
  }')"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read mounted folders"
    return 2
  fi

  local len=0
  len="$(count "${devices}")" || return 1

  if [[ ${len} -eq 0 ]] && [[ -z "${folders}" ]]; then
    echo "No mounts have found"
    return 0
  fi

  if [[ ${len} -gt 0 ]]; then
    local query=''
    query+='Device:  \(.path)\n'
    query+='\(if .label then "Label:   \(.label)\n" else "" end)'
    query+='Points:  \(.mountpoints)'
    query="[.[]|\"${query}\"]|join(\"\n\n\")"

    echo "${devices}" | jq -cer "${query}" || return 1
  fi

  if [[ -n "${folders}" ]]; then
    echo "${folders}"
  fi
}

# Mounts the device with the given path.
# Globals:
#  REPLY, HOME, USER
# Arguments:
#  path: the path of a block device
mount_device () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_device 'part,rom' "unmounted" || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]]; then
    echo "Invalid block device"
    return 2
  elif grep -qs "${path} " /proc/mounts; then
    echo "Device ${path} is already mounted"
    return 2
  fi
  
  udisksctl mount -b "${path}" &>/dev/null

  if [[ $? -ne 0 ]]; then
    echo "Failed to mount device"
    return 2
  fi

  echo "Device ${path} has been mounted"

  local local_home="${HOME}/mount/local"

  if [[ -d "/run/media/${USER}" ]] && [[ ! -L "${local_home}" ]]; then
    mkdir -p "${local_home}"
    ln -s "/run/media/${USER}" "${local_home}"
  fi
}

# Unmounts the device with the given path.
# Globals:
#  REPLY, HOME, USER
# Arguments:
#  path: the path of a block device
unmount_device () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_device 'part,rom' "mounted" || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]]; then
    echo "Invalid block device"
    return 2
  elif ! grep -qs "${path} " /proc/mounts; then
    echo "Device ${path} is not mounted"
    return 2
  fi

  local mountpoint=''
  mountpoint="$(find_device "${path}" | jq -cer '.mountpoint')" || return 1

  if [[ "${mountpoint}" == "/" ]]; then
    echo "Cannot unmount root partition"
    return 2
  elif [[ "${mountpoint}" == "/home" ]]; then
    echo "Cannot unmount home partition"
    return 2
  elif [[ "${mountpoint}" =~ ^/(var|log)$ ]]; then
    echo "Cannot unmount ${mountpoint} partition"
    return 2
  fi

  sync && udisksctl unmount -b "${path}" &>/dev/null

  if [[ $? -ne 0 ]]; then
    echo "Failed to unmount device"
    return 2
  fi

  udisksctl power-off -b "${path}" &>/dev/null &&
    echo "Device power set to off" ||
    echo "Unable to power off the device"

  echo "Device ${path} has been unmounted"
}

# Mounts a shared folder of the given host.
# Globals:
#  REPLY, HOME, UID
# Arguments:
#  host: the name or ip of a host
mount_shared_folder () {
  local host="${1}"

  if [[ -z "${host}" ]]; then
    pick_host || return $?
    [[ -n "${REPLY}" ]] && host="${REPLY}" || return 0
  fi

  ask "Enter a shared folder:" || return $?
  local folder="${REPLY}"

  ask "Enter the username:" || return $?
  local username="${REPLY}"

  ask "Enter the workgroup [WORKGROUP]:" || return $?
  local workgroup="${REPLY:-"WORKGROUP"}"

  local uri="smb://${workgroup};${username}@${host}/${folder,,}"

  if gio mount -l | grep -q "${uri}"; then
    echo "Shared folder is already mounted"
    return 2
  fi

  gio mount "${uri}" 2>/dev/null
  
  if [[ $? -ne 0 ]]; then
    echo "Failed to mount shared folder"
    return 2
  fi

  echo "Shared folder ${folder} mounted"

  local remote_home="${HOME}/mount/remote"

  if [[ -d "/run/user/${UID}/gvfs" ]] && [[ ! -L "${remote_home}/gvfs" ]]; then
    mkdir -p "${remote_home}"
    ln -s "/run/user/${UID}/gvfs" "${remote_home}"
  fi
}

# Unmounts the shared folder with the given uri.
# Globals:
#  REPLY, UID
# Arguments:
#  uri: the uri of the shared folder
unmount_shared_folder () {
  local uri="${1}"

  if [[ -z "${uri}" ]]; then
    local uris=''
    uris="$(ls /run/user/${UID}/gvfs | awk '{
      match($0, /domain=(.*),server=(.*),share=(.*),user=(.*)/, a);
      key="smb://"a[1]";"a[4]"@"a[2]"/"a[3]
      print "{\"key\": \""key"\", \"value\":\""key"\"},"
    }')" || return 1

    # Remove the extra comma after the last element
    if [[ -n "${uris}" ]]; then
      uris="${uris::-1}"
    fi

    uris="[${uris}]"

    local len=0
    len="$(count "${uris}")" || return 1

    if [[ ${len} -eq 0 ]]; then
      echo "No mounted shared folders have been found"
      return 0
    fi

    pick_one "Select a shared folder:" "${uris}" "vertical" || return $?
    [[ -n "${REPLY}" ]] && uri="${REPLY}" || return 0
  fi

  if ! gio mount -l | grep -q "${uri}"; then
    echo "Shared folder is not mounted"
    return 2
  fi

  sync && gio mount -u "${uri}" 2>/dev/null
  
  if [[ $? -ne 0 ]]; then
    echo "Failed to umount shared folder"
    return 2
  fi

  echo "Shared folder ${uri} has been unmounted"
}

# Shows the help message.
# Arguments:
#  None
# Outputs:
#  A long help message.
show_help () {
  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf " %-35s %s\n" \
    "help" "Show this help message." \
    "" "" \
    "show status" "Show a report of disks and the file system." \
    "" "" \
    "show device [<path>]" "Show the data of a block device." \
    "scan device [<path>]" "Scan a block device for SMART data." \
    "" "" \
    "list devices [<type>]" "List all the block devices or by type," \
    "" "where type could be disk, part or rom." \
    "list shares [<host>]" "Fetch the shared folders of a host." \
    "list mounts" "List all mounted block devices and shared folders." \
    "" "" \
    "mount device [<path>]" "Mount a block device." \
    "unmount device [<path>]" "Unmount a block device." \
    "" "" \
    "mount share [<host>]" "Mount a shared folder." \
    "unmount share [<uri>]" "Unmount a shared folder."
}

loop () {
  clear

  while true; do
    prompt && history -s "${REPLY}"

    set -f
    set_separator "line"
    local cmd=($(xargs -n1 <<< "${REPLY}"))
    restore_separator && set +f

    if [[ "${cmd[0]}" == "help" ]]; then
      show_help
      continue
    elif [[ "${cmd[0]}" == "clear" ]]; then
      clear
      continue
    elif [[ "${cmd[0]}" == "quit" ]]; then
      break
    elif [[ -z "${cmd[0]}" ]]; then
      continue
    fi

    case "${cmd[0]}" in
      "list")
        case "${cmd[1]}" in
          "devices") list_devices "${cmd[2]}";;
          "shares") list_shares "${cmd[2]}";;
          "mounts") list_mounts;;
          *) echo "Invalid or unknown command";;
        esac;;
      "show")
        case "${cmd[1]}" in
          "status") show_status;;
          "device") show_device "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "scan")
        case "${cmd[1]}" in
          "device") scan_device "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "mount")
        case "${cmd[1]}" in
          "device") mount_device "${cmd[2]}";;
          "share") mount_shared_folder "${cmd[2]}" "${cmd[3]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "unmount")
        case "${cmd[1]}" in
          "device") unmount_device "${cmd[2]}";;
          "share") unmount_shared_folder "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      *) echo "Invalid or unknown command";; 
    esac

    if [[ $? -eq 1 ]]; then
      echo "An unknown error has occurred"
    fi
  done

  clear
}

loop