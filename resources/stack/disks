#!/bin/bash

set -o pipefail
source /opt/stack/utils

# Returns the list of disk block devices.
# Arguments:
#  None
# Outputs:
#  A json array of disk block device objects.
find_disks () {
  local fields='name,path,type,size,rm,ro,tran,hotplug,state,'
  fields+='vendor,model,rev,serial,mountpoint,mountpoints,'
  fields+='label,uuid,fstype,fsver,fsavail,fsused,fsuse%'

  local query='[.blockdevices[]|select(.type == "disk")]'

  lsblk -J -o "${fields}" | jq -cer "${query}" || return 1
}

# Returns the disk block device with the given path.
# Arguments:
#  path: the path of a disk block device
# Outputs:
#  A json object of a disk block device.
find_disk () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local query=".[]|select(.path == \"${path}\")"

  find_disks | jq -cer "${query}" || return 1
}

# Returns the list of partitions of the disk block
# device with the given path.
# Arguments:
#  path:   the path of a disk block device
#  status: mounted or unmounted
# Outputs:
#  A json array of partition block device objects.
find_partitions () {
  local path="${1}"
  local status="${2}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  # Collect any disk partitions reported by lsblk
  local query=''
  query+='.children|if . then .[]|select(.type == "part") else empty end'
  query="[${query}]"

  local parts=''
  parts="$(find_disk "${path}" | jq -cer "${query}")" || return 1

  # Collect any disk encrypted volumes reported by veracrypt
  local volumes=''
  volumes="$(veracrypt -t --list 2>&1)"

  if [[ $? -ne 0 ]] && [[ ! "${volumes}" =~ "No volumes mounted" ]]; then
    return 1
  fi

  local query=''
  query+=".[]|select(.path|test(\"^${path}\"))"
  query+=' |{path: .path, veracrypt: .}'
  query="[${query}]"

  volumes="$(echo "${volumes}" | jc --veracrypt | jq -cer "${query}")" || return 1

  # Merge partitions and volumes data by path into an array
  local query='$p + $v | group_by(.path) | map(add)'

  if [[ "${status}" == "mounted" ]]; then
    query+='|.[]|select(.mountpoint != null or .veracrypt.mountpoint != null)'
  elif [[ "${status}" == "unmounted" ]]; then
    query+='|.[]|select(.mountpoint == null and .veracrypt.mountpoint == null)'
  fi

  query="[${query}]|flatten"

  jq -ncer --argjson p "${parts}" --argjson v "${volumes}" "${query}" || return 1
}

# Returns the partition block device with the given path.
# Arguments:
#  path: the path of a partition block device
# Outputs:
#  A json object of a partition block device.
find_partition () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  # Collect the partition data reported by lsblk
  local fields='name,path,type,size,rm,ro,tran,hotplug,state,'
  fields+='vendor,model,rev,serial,mountpoint,mountpoints,'
  fields+='label,uuid,fstype,fsver,fsavail,fsused,fsuse%'

  local query='.blockdevices[0]|select(.type == "part")'

  local part=''
  part="$(lsblk -J -o "${fields}" "${path}" | jq -cer "${query}")" || return 1

  # Colect the encrypted volume data reported by veracrypt, if any
  local volume=''
  volume="$(veracrypt -t --volume-properties "${path}" 2>&1)"

  if [[ $? -ne 0 ]] && [[ ! "${volume}" =~ "No such volume is mounted" ]]; then
    return 1
  fi

  local query='if .|length>0 then .[0]|{path: .path, veracrypt: .} else {} end'

  volume="$(echo "${volume}" | jc --veracrypt | jq -cer "${query}")" || return 1

  # Merge partition and volume data into an object
  jq -ncer --argjson p "${part}" --argjson v "${volume}" "\$p + \$v" || return 1
}

# Returns the list of rom block devices.
# Arguments:
#  status: mounted or unmounted
# Outputs:
#  A json array of rom block device objects.
find_roms () {
  local status="${1}"

  local fields='name,path,type,size,rm,ro,tran,hotplug,state,'
  fields+='vendor,model,rev,serial,mountpoint,mountpoints,'
  fields+='label,uuid,fstype,fsver,fsavail,fsused,fsuse%'

  local query='.blockdevices[]|select(.type == "rom")'

  if [[ "${status}" == "mounted" ]]; then
    query+='|select(.mountpoint != null)'
  elif [[ "${status}" == "unmounted" ]]; then
    query+='|select(.mountpoint == null)'
  fi

  query="[${query}]"

  lsblk -J -o "${fields}" | jq -cer "${query}" || return 1
}

# Returns the rom block device with the given path.
# Arguments:
#  path: the path of a rom block device
# Outputs:
#  A json object of a rom block device.
find_rom () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local query=".[]|select(.path == \"${path}\")"

  find_roms | jq -cer "${query}" || return 1
}

# Checks if the block device with the given path
# is a disk device.
# Arguments:
#  path: the path of a block device
# Returns:
#  0 if it is disk otherwise 1.
is_disk () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local type=''
  type="$(find_disk "${path}" | jq -cer '.type')" || return 1

  if [[ "${type}" == "disk" ]]; then
    return 0
  else
    return 1
  fi
}

# Checks if the block device with the given path
# is a disk with system partitions on it.
# Arguments:
#  path: the path of a disk block device
# Returns:
#  0 if it is a system disk otherwise 1.
is_system_disk () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local disk=''
  disk="$(find_disk "${path}")" || return 1

  local system_paths='/|/home|/boot|/var|/log|/swap'

  # Check if any partition's mountpoint is a system path
  local is_system_path="if . then .|test(\"^(${system_paths})$\") else false end"

  local query=''
  query+=".children|if . then [.[]|.mountpoint|${is_system_path}]|any else false end"

  local result=''
  result="$(echo "${disk}" | jq -cr "${query}")" || return 1

  if [[ "${result}" == "true" ]]; then
    return 0
  fi

  # Check also deep into the partitions children, if any
  local query=''
  query+=".children|if . then [.[]|.mountpoint|${is_system_path}]|any else false end"
  query=".children|if . then ([.[]|${query}]|any) else false end"

  result="$(echo "${disk}" | jq -cr "${query}")" || return 1

  if [[ "${result}" == "true" ]]; then
    return 0
  else
    return 1
  fi
}

# Checks if the block device with the given path
# is a partition device.
# Arguments:
#  path: the path of a block device
# Returns:
#  0 if it is partition otherwise 1.
is_partition () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local type=''
  type="$(find_partition "${path}" | jq -cer '.type')" || return 1

  if [[ "${type}" == "part" ]]; then
    return 0
  else
    return 1
  fi
}

# Checks if the block device with the given path
# is a partition pointing to a system path.
# Arguments:
#  path: the path of a partition block device
# Returns:
#  0 if it is a system partition otherwise 1.
is_system_partition () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local system_paths='/|/home|/boot|/var|/log|/swap'

  # Check if partition mountpoint is a system path
  local is_system_path="if . then .|test(\"^(${system_paths})$\") else false end"

  local query=''
  query+="if (.mountpoint|${is_system_path}) or (.veracrypt.mountpoint|${is_system_path})"
  query+=' then true else false '
  query+='end'

  local result=''
  result="$(find_partition "${path}" | jq -cer "${query}")" || return 1

  if [[ "${result}" == "true" ]]; then
    return 0
  else
    return 1
  fi
}

# Checks if the block device with the given path
# is a rom device.
# Arguments:
#  path: the path of a block device
# Returns:
#  0 if it is rom otherwise 1.
is_rom () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local type=''
  type="$(find_rom "${path}" | jq -cer '.type')" || return 1

  if [[ "${type}" == "rom" ]]; then
    return 0
  else
    return 1
  fi
}

# Checks if the block device with the given path
# is mounted or not.
# Arguments:
#  path: the path of a mountable block device
# Returns:
#  0 if it is mounted otherwise 1.
is_mounted () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  if grep -qsE "^${path} " /proc/mounts; then
    return 0
  fi

  if veracrypt -t --list 2>&1 | grep -qsE "^[0-9]+: ${path} "; then
    return 0
  fi

  return 1
}

# Mounts the block device with the given path.
# Arguments:
#  path: the path of a mountable block device
mount_device () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  udisksctl mount -b "${path}" &> /dev/null || return 1

  # Create symlink to the local mount folder
  local local_home="${HOME}/mounts/local"

  if [[ -d "/run/media/${USER}" ]] && [[ ! -L "${local_home}" ]]; then
    mkdir -p "${local_home}"
    ln -s "/run/media/${USER}" "${local_home}"
  fi
}

# Mounts the encrypted block device with the given path.
# Arguments:
#  path:     the path of an encrypted block device
#  password: the encryption key pass
mount_encrypted () {
  local path="${1}"
  local password="${2}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local folder_name="$(echo "${path:1}" | tr '/' '_')"
  local mount_point="${HOME}/mounts/encrypted/${folder_name}"

  mkdir -p "${mount_point}" &&
  sudo veracrypt -t --mount "${path}" "${mount_point}" --password "${password}" \
    --pim 0 --keyfiles "" --protect-hidden no --non-interactive &> /dev/null

  if [[ $? -ne 0 ]]; then
    rm -rf "${mount_point}"
    return 1
  fi
}

# Unmounts the block device with the given path.
# Arguments:
#  path: the path of a mountable block device
unmount_device () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  sync &&
  udisksctl unmount -b "${path}" &> /dev/null || return 1
}

# Unmounts the encrypted block device with the given path.
# Arguments:
#  path: the path of an encrypted block device
unmount_encrypted () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  sync &&
  sudo veracrypt -t --dismount "${path}" &> /dev/null || return 1

  local folder_name="$(echo "${path:1}" | tr '/' '_')"
  rm -rf "${HOME}/mounts/encrypted/${folder_name}"
}

# Unmounts the mounted partitions of a disk block
# device with the given path.
# Arguments:
#  path: the path of a disk block device
unmount_partitions () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  # Collect any disk's mounted partitions
  local parts=''
  parts="$(grep -sE "^${path}p?[0-9]+ " /proc/mounts | awk '{print $1}')"

  # Collect any disk's mounted encrypted volumes, if any
  local volumes=''
  volumes="$(veracrypt -t --list 2>&1)"
  
  if [[ $? -ne 0 ]] && [[ ! "${volumes}" =~ "No volumes mounted" ]]; then
    return 1
  fi
  
  volumes="$(echo "${volumes}" | jc --veracrypt | jq -cr '.[]|.path')" || return 1
  
  if [[ -z "${parts}" ]] && [[ -z "${volumes}" ]]; then
    echo "No mounted partitions have found"
    return 0
  fi

  if [[ -n "${parts}" ]]; then
    local part=''
    while read -r part; do
      unmount_device "${part}"

      if [[ $? -eq 0 ]]; then
        echo "Partition ${part} has been unmounted"
      else
        echo "Failed to unmount partition ${part}"
        return 2
      fi
    done <<< "${parts}"
  fi

  if [[ -n "${volumes}" ]]; then
    local volume=''
    while read -r volume; do
      unmount_encrypted "${volume}"

      if [[ $? -eq 0 ]]; then
        echo "Partition ${volume} has been unmounted"
      else
        echo "Failed to unmount partition ${volume}"
        return 2
      fi
    done <<< "${volumes}"
  fi
}

# Re-creates the partition table and removes any
# existing partitions on the disk block device with
# the given path.
# Arguments:
#  path: the path of a disk block device
clean_partitions () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  sudo wipefs --all --force --quiet "${path}" &&
  sudo parted --script -a optimal -- "${path}" mklabel msdos || return 1
}

# Creates a primary partition to the disk block
# device with the given path.
# Arguments:
#  path:    the path of a block disk device
#  fs_type: the fs type of the partition
#  start:   the start of the partition
#  end:     the end of the partition
create_partition () {
  local path="${1}"
  local fs_type="${2}"
  local start="${3}"
  local end="${4}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  # Use ntfs as fs type for exfat file systems
  [[ "${fs_type}" == "exfat" ]] && fs_type="ntfs"
  
  sudo parted --script -a optimal -- "${path}" mkpart primary "${fs_type}" "${start}" "${end}" &&
  sudo parted --script -- "${path}" align-check optimal 1 || return 1
}

# Formats the i-th partition of the disk block
# device with the given path.
# Arguments:
#  path:    the path of a disk block device
#  index:   the index of the partition to format
#  fs_type: the fs type of the partition
#  label:   the label of the partition
format_partition () {
  local path="${1}"
  local index="${2}"
  local fs_type="${3}"
  local label="${4}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  # Add path postfix for nvme and mmcblk disks
  if [[ "${path}" =~ ^/dev/(nvme|mmcblk) ]]; then
    path="${path}p"
  fi

  case "${fs_type}" in
    "ext2") sudo mkfs.ext2 -L "${label}" "${path}${index}" | awk NF;;
    "ext3") sudo mkfs.ext3 -L "${label}" "${path}${index}" | awk NF;;
    "ext4") sudo mkfs.ext4 -L "${label}" "${path}${index}" | awk NF;;
    "ntfs") sudo mkfs.ntfs -f -L "${label}" "${path}${index}" | awk NF;;
    "exfat") sudo mkfs.exfat -L "${label}" "${path}${index}" | awk NF;;
    "fat32") sudo mkfs.fat -F 32 -n "${label}" "${path}${index}" | awk NF;;
    *) return 1;;
  esac

  if [[ $? -ne 0 ]]; then
    return 1
  fi
}

# Returns the list of shared folders of the given
# host available in the local network.
# Arguments:
#  host:      the name or ip of a host
#  username:  the name of the user
#  workgroup: the group of the user
#  password:  the password of the user
# Outputs:
#  A json array of shared folder objects.
find_shared_folders () {
  local host="${1}"
  local username="${2}"
  local workgroup="${3}"
  local password="${4}"

  local folders=''
  folders="$(smbclient -L "${host}" -U "${username}" -W "${workgroup}" --password="${password}" |
    awk '/Disk/{print "{\"name\":\""$1"\",\"type\":\""$2"\"},"}')" || return 1

  # Remove the extra comma after the last element
  if [[ -n "${folders}" ]]; then
    folders="${folders::-1}"
  fi

  echo "[${folders}]"
}

# Shows a menu asking the user to select one disk block device,
# where the answer is kept in the global var REPLY.
# Arguments:
#  None
# Outputs:
#  A menu of disk block devices.
pick_disk () {
  local disks=''
  disks="$(find_disks)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find disks"
    return 2
  fi

  local len=0
  len="$(count "${disks}")" || return 1
  
  if [[ ${len} -eq 0 ]]; then
    echo "No disks have found"
    return 2
  fi

  local trim='.|gsub("^\\s+|\\s+$";"")'
  local vendor="\(.vendor|if . then .|${trim} else empty end)"

  local value=''
  value+="[\"${vendor}\", .size]|join(\" \")"
  value="\(${value}|if . != \"\" then \" [\(.|${trim})]\" else empty end)"
  value="\(.path)${value}"

  local query=''
  query="[.[]|{key: .path, value: \"${value}\"}]"

  disks="$(echo "${disks}" | jq -cer "${query}")" || return 1

  pick_one "Select a disk:" "${disks}" "vertical" || return $?
}

# Shows a menu asking the user to select one partition
# of the disk with the given path, where the answer is
# kept in the global var REPLY.
# Arguments:
#  path:   the path of a disk block device
#  status: mounted, unmounted
# Outputs:
#  A menu of partition block devices.
pick_partition () {
  local path="${1}"
  local status="${2}"

  local parts=''
  parts="$(find_partitions "${path}" "${status}")"

  if [[ $? -ne 0 ]]; then
    echo -e "Unable to find ${status:-\b} partitions"
    return 2
  fi

  local len=0
  len="$(count "${parts}")" || return 1
  
  if [[ ${len} -eq 0 ]]; then
    echo -e "No ${status:-\b} partitions have found"
    return 2
  fi

  local trim='.|gsub("^\\s+|\\s+$";"")'
  local label="\(.label|if . then .|${trim} else empty end)"

  local value=''
  value+="[\"${label}\", .size]|join(\" \")"
  value="\(${value}|if . != \"\" then \" [\(.|${trim})]\" else empty end)"
  value="\(.path)${value}"

  local query="[.[]|{key: .path, value: \"${value}\"}]"

  parts="$(echo "${parts}" | jq -cer "${query}")" || return 1

  pick_one "Select a partition:" "${parts}" "vertical" || return $?
}

# Shows a menu asking the user to select one rom block
# device, where the answer is kept in the global var REPLY.
# Arguments:
#  status: mounted, unmounted
# Outputs:
#  A menu of rom block devices.
pick_rom () {
  local status="${1}"

  local roms=''
  roms="$(find_roms "${status}")"

  if [[ $? -ne 0 ]]; then
    echo -e "Unable to find ${status:-\b} roms"
    return 2
  fi

  local len=0
  len="$(count "${roms}")" || return 1
  
  if [[ ${len} -eq 0 ]]; then
    echo -e "No ${status:-\b} roms have found"
    return 2
  fi

  local trim='.|gsub("^\\s+|\\s+$";"")'
  local vendor="\(.vendor|if . then .|${trim} else empty end)"
  local label="\(.label|if . then .|${trim} else empty end)"

  local value=''
  value+="[\"${vendor}\", \"${label}\", .size]|join(\" \")"
  value="\(${value}|if . != \"\" then \" [\(.|${trim})]\" else empty end)"
  value="\(.path)${value}"

  local query=''
  query="[.[]|{key: .path, value: \"${value}\"}]"

  roms="$(echo "${roms}" | jq -cer "${query}")" || return 1

  pick_one "Select a rom:" "${roms}" "vertical" || return $?
}

# Shows a menu asking the user to select one host, where the
# answer is kept in the global var REPLY.
# Arguments:
#  None
# Outputs:
#  A menu of host names.
pick_host () {
  echo "Searching hosts in local network..."

  local hosts=''
  hosts="$(find_hosts)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find hosts"
    return 2
  fi

  local len=0
  len="$(count "${hosts}")" || return 1
  
  if [[ ${len} -eq 0 ]]; then
    echo "No hosts have found"
    return 2
  fi

  local query=''
  query+='key: .ip,'
  query+='value: "\(.ip)\(.name|if . and . != "" then " [\(.)]" else "" end)"'
  query="[.[]|{${query}}]"

  hosts="$(echo "${hosts}" | jq -cer "${query}")" || return 1

  pick_one "Select a host:" "${hosts}" "vertical" || return $?
}

# Shows a menu asking the user to select one file system type,
# where the answer is kept in the global var REPLY.
# Arguments:
#  None
# Outputs:
#  A menu of file system types.
pick_fs_type () {
  local values=''
  values+='{"key": "ext4", "value": "EXT4"},'
  values+='{"key": "ext3", "value": "EXT3"},'
  values+='{"key": "ext2", "value": "EXT2"},'
  values+='{"key": "ntfs", "value": "NTFS"},'
  values+='{"key": "exfat", "value": "exFAT"},'
  values+='{"key": "fat32", "value": "FAT32"}'
  values="[${values}]"

  pick_one "Select a file system type:" "${values}" "vertical" || return $?
}

# Shows a prompt status and asks user to enter the
# next command, which is kept in the global var REPLY.
# Arguments:
#  None
# Outputs:
#  A minimal prompt status line.
prompt () {
  local query='.[]|.children|'
  query+='if . then .[]|select(.mountpoint == "/")|.name else empty end'

  local status=''
  status="$(find_disks | jq -cer "${query}")"

  if [[ $? -ne 0 ]]; then
    status='none'
  fi

  read -rep "[disks:${status}] " REPLY
}

# Shows a short status of the disks and filesystem.
# Arguments:
#  None
# Outputs:
#  A list of disks and filesystem data.
show_status () {
  local alt_fstype='.children|'
  alt_fstype+='if . and length>0'
  alt_fstype+=' then (.[0]|.fstype|if . then  " \(.|ascii_upcase)" else "" end)'
  alt_fstype+=' else "" end'

  local alt_fsuse='.children|'
  alt_fsuse+='if . and length>0'
  alt_fsuse+=' then (.[0]|."fsuse%"|if . then  " \(.)" else "" end)'
  alt_fsuse+=' else "" end'

  local parts=''
  parts+='\(.path)'
  parts+="\(if .fstype then \" \(.fstype|ascii_upcase)\" else ${alt_fstype} end)"
  parts+="\(if .\"fsuse%\" then \" \(.\"fsuse%\")\" else ${alt_fsuse} end)"
  parts=".children|if . and length>0 then .[]|\"${parts}\" else \"\" end"
  parts="[${parts}]|join(\"\n         \")"

  local query=''
  query+='Disk:    \(.path)\n'
  query+='Model:   \(.vendor|gsub("^\\s+|\\s+$";"")) \(.model)\n'
  query+='Size:    \(.size)\n'
  query+="Parts:   \(if .children then ${parts} else \"none\" end)"

  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  find_disks | jq -cer "${query}" || return 1

  echo

  swapon --noheadings --show | awk -F' ' '{
    printf "%-8s %s\n", "Swap:", $1
    printf "%-8s %s\n", "Type:", $2
    printf "%-8s %s\n", "Used:", $4"/"$3
  }' || return 1

  cat /proc/meminfo | grep -E "Swap.*" | awk -F':' '{
    gsub(/^[ \t]+/,"",$1)
    gsub(/[ \t]+$/,"",$1)
    gsub(/^[ \t]+/,"",$2)
    gsub(/[ \t]+$/,"",$2)

    if ($1 == "SwapCached") $1="Cached"
    if ($1 == "SwapTotal") $1="Total"
    if ($1 == "SwapFree") $1="Free"
    printf "%-8s %s\n", $1":", $2
  }' || return 1
}

# Shows the data of the disk block device with
# the given path.
# Arguments:
#  path: the path of a disk block device
# Outputs:
#  A long text of disk block device data.
show_disk () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_disk || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]]; then
    echo "Unable to find disk ${path}"
    return 2
  fi

  local disk=''
  disk="$(find_disk "${path}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find disk ${path}"
    return 2
  fi

  local alt_fstype='.children|'
  alt_fstype+='if . and length>0'
  alt_fstype+=' then (.[0]|.fstype|if . then  " \(.|ascii_upcase)" else "" end)'
  alt_fstype+=' else "" end'

  local alt_fsuse='.children|'
  alt_fsuse+='if . and length>0'
  alt_fsuse+=' then (.[0]|."fsuse%"|if . then  " \(.)" else "" end)'
  alt_fsuse+=' else "" end'

  local alt_label='.children|'
  alt_label+='if . and length>0'
  alt_label+=' then (.[0]|.label|if . then  " [\(.)]" else "" end)'
  alt_label+=' else "" end'

  local parts=''
  parts+='\(.path)'
  parts+="\(if .fstype then \" \(.fstype|ascii_upcase)\" else ${alt_fstype} end)"
  parts+="\(if .\"fsuse%\" then \" \(.\"fsuse%\")\" else ${alt_fsuse} end)"
  parts+="\(if .label then \" [\(.label)]\" else ${alt_label} end)"
  parts=".children|if . and length>0 then .[]|\"${parts}\" else \"\" end"
  parts="[${parts}]|join(\"\n            \")"

  local query=''
  query+='Name:       \(.name)\n'
  query+='Path:       \(.path)\n'
  query+='Removable:  \(.rm)\n'
  query+='ReadOnly:   \(.ro)\n'
  query+='Transfer:   \(.tran)\n'
  query+='HotPlug:    \(.hotplug)\n'
  query+='Size:       \(.size)\n'
  query+='Vendor:     \(.vendor)\n'
  query+='Model:      \(.model)\n'
  query+='Revision:   \(.rev)\n'
  query+='Serial:     \(.serial)\n'
  query+='State:      \(.state)\n'
  query+="Parts:      \(if .children then ${parts} else \"none\" end)"

  echo "${disk}" | jq -cer "\"${query}\""

  if [[ $? -ne 0 ]]; then
    echo "Failed to parse disk data"
    return 2
  fi
}

# Shows the data of the partition block device.
# Arguments:
#  path: the path of a partition block device
# Outputs:
#  A long text of partition block device data.
show_partition () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_disk || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0

    pick_partition "${path}" || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi
  
  if [[ ! -b "${path}" ]]; then
    echo "Unable to find partition ${path}"
    return 2
  fi

  local part=''
  part="$(find_partition "${path}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find partition ${path}"
    return 2
  fi

  local alt_fstype='.children|'
  alt_fstype+='if . and length>0'
  alt_fstype+=' then (.[0]|.fstype|if . then  "File System:  \(.|ascii_upcase)\n" else "" end)'
  alt_fstype+=' else "" end'

  local alt_fsavail='.children|'
  alt_fsavail+='if . and length>0'
  alt_fsavail+=' then (.[0]|.fsavail|if . then  "\nFree Space:   \(.)" else "" end)'
  alt_fsavail+=' else "" end'

  local alt_fsused='.children|'
  alt_fsused+='if . and length>0'
  alt_fsused+=' then (.[0]|if .fsused then  "\nUsed Space:   \(.fsused) [\(."fsuse%")]" else "" end)'
  alt_fsused+=' else "" end'

  local alt_label='.children|'
  alt_label+='if . and length>0'
  alt_label+=' then (.[0]|.label|if . then  "\nLabel:        \(.)" else "" end)'
  alt_label+=' else "" end'

  local alt_uuid='.children|'
  alt_uuid+='if . and length>0'
  alt_uuid+=' then (.[0]|.uuid|if . then  "\nUUID:         \(.)" else "" end)'
  alt_uuid+=' else "" end'

  local alt_mountpoint=''
  alt_mountpoint+='.veracrypt|if . then "\nMount:        \(.mountpoint)" else "" end'

  local query=''
  query+='Name:         \(.name) \(if .veracrypt then "[encrypted]" else "" end)\n'
  query+='Path:         \(.path)\n'
  query+="\(if .fstype then \"File System:  \(.fstype|ascii_upcase)\n\" else ${alt_fstype} end)"
  query+='Removable:    \(.rm)\n'
  query+='ReadOnly:     \(.ro)\n'
  query+='HotPlug:      \(.hotplug)\n'
  query+='Size:         \(.size)'
  query+="\(if .fsavail then \"\nFree Space:   \(.fsavail)\" else ${alt_fsavail} end)"
  query+="\(if .fsused then \"\nUsed Space:   \(.fsused) [\(.\"fsuse%\")]\" else ${alt_fsused} end)"
  query+="\(if .label then \"\nLabel:        \(.label)\" else ${alt_label} end)"
  query+="\(if .uuid then \"\nUUID:         \(.uuid)\" else ${alt_uuid} end)"
  query+='\(.veracrypt|if . then "\nSlot:         \(.slot)" else "" end)'
  query+='\(.veracrypt|if . then "\nHidden:       \(.hidden_protected)" else "" end)'
  query+='\(.veracrypt|if . then "\nEncryption:   \(.encryption_algo):\(.prf) [\(.mode)]" else "" end)'
  query+='\(.veracrypt|if . then "\nBlock:        \(.block_size)" else "" end)'
  query+='\(.veracrypt|if . then "\nMapped:       \(.device)" else "" end)'
  query+="\(if .mountpoint then \"\nMount:        \(.mountpoint)\" else ${alt_mountpoint} end)"

  echo "${part}" | jq -cer "\"${query}\""

  if [[ $? -ne 0 ]]; then
    echo "Failed to parse partition data"
    return 2
  fi
}

# Shows the data of the rom block device with
# the given path.
# Arguments:
#  path: the path of a rom block device
# Outputs:
#  A long text of rom block device data.
show_rom () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_rom || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]]; then
    echo "Unable to find rom ${path}"
    return 2
  fi

  local rom=''
  rom="$(find_rom "${path}")"
  
  if [[ $? -ne 0 ]]; then
    echo "Unable to find rom ${path}"
    return 2
  fi

  local query=''
  query+='Name:          \(.name)\n'
  query+='Path:          \(.path)\n'
  query+='\(if .fstype then "File System:   \(.fstype|ascii_upcase)\n" else "" end)'
  query+='Removable:     \(.rm)\n'
  query+='ReadOnly:      \(.ro)\n'
  query+='Transfer:      \(.tran)\n'
  query+='HotPlug:       \(.hotplug)\n'
  query+='Size:          \(.size)\n'
  query+='\(if .fsavail then "Free Space:    \(.fsavail)\n" else "" end)'
  query+='\(if .fsused then "Used Space:    \(.fsused) [\(."fsuse%")]\n" else "" end)'
  query+='\(if .label then "Label:         \(.label)\n" else "" end)'
  query+='\(if .uuid then "UUID:          \(.uuid)\n" else "" end)'
  query+='Vendor:        \(.vendor)\n'
  query+='Model:         \(.model)\n'
  query+='Revision:      \(.rev)\n'
  query+='Serial:        \(.serial)\n'
  query+='State:         \(.state)'
  query+='\(if .mountpoint then "\nMount:         \(.mountpoint)" else "" end)'

  echo "${rom}" | jq -cer "\"${query}\""

  if [[ $? -ne 0 ]]; then
    echo "Failed to parse rom data"
    return 2
  fi
}

# Shows the list of disk block devices.
# Arguments:
#  None
# Outputs:
#  A list of disk block devices.
list_disks () {
  local disks=''
  disks="$(find_disks)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find disks"
    return 2
  fi

  local len=0
  len="$(count "${disks}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No disks have found"
    return 0
  fi

  local query=''
  query+='Name:    \(.name)\n'
  query+='Path:    \(.path)\n'
  query+='Size:    \(.size)'
  query+='\(if .vendor then "\nVendor:  \(.vendor)" else "" end)'
  query+='\(if .model then "\nModel:   \(.model)" else "" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${disks}" | jq -cer "${query}" || return 1
}

# Shows the list of partitions of the disk block device
# with the given path.
# Arguments:
#  path: the path of a disk block device
# Outputs:
#  A list of parition block devices.
list_partitions () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_disk || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]] || ! is_disk "${path}"; then
    echo "Unable to find disk ${path}"
    return 2
  fi

  local parts=''
  parts="$(find_partitions "${path}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find partitions"
    return 2
  fi

  local len=0
  len="$(count "${parts}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No partitions have found"
    return 0
  fi

  local query=''
  query+='Name:   \(.name)\(if .veracrypt then " [encrypted]" else "" end)\n'
  query+='Path:   \(.path)\n'
  query+='Size:   \(.size)'
  query+='\(if .label then "\nLabel:  \(.label)" else "" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${parts}" | jq -cer "${query}" || return 1
}

# Shows the list of rom block devices.
# Arguments:
#  None
# Outputs:
#  A list of rom block devices.
list_roms () {
  local roms=''
  roms="$(find_roms)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find roms"
    return 2
  fi

  local len=0
  len="$(count "${roms}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No roms have found"
    return 0
  fi

  local query=''
  query+='Name:    \(.name)\n'
  query+='Path:    \(.path)\n'
  query+='Size:    \(.size)'
  query+='\(if .vendor then "\nVendor:  \(.vendor)" else "" end)'
  query+='\(if .model then "\nModel:   \(.model)" else "" end)'
  query+='\(if .label then "\nLabel:   \(.label)" else "" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${roms}" | jq -cer "${query}" || return 1
}

# Shows the list of shared folders of the given host.
# Arguments:
#  host: the name or ip of a host.
# Outputs:
#  A list of shared folders.
list_shared_folders () {
  local host="${1}"

  if [[ -z "${host}" ]]; then
    pick_host || return $?
    [[ -n "${REPLY}" ]] && host="${REPLY}" || return 0
  fi

  ask "Enter the username:" || return $?
  local username="${REPLY}"

  ask "Enter the workgroup [WORKGROUP]:" || return $?
  local workgroup="${REPLY:-"WORKGROUP"}"

  ask_secret "Enter the password:" || return $?
  local password="${REPLY}"

  local folders=''
  folders="$(find_shared_folders "${host}" "${username}" "${workgroup}" "${password}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find shared folders"
    return 2
  fi

  local len=0
  len="$(count "${folders}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No shared folders have found"
    return 0
  fi

  local query=''
  query+='Name:  \(.name)\n'
  query+='Type:  \(.type)'

  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${folders}" | jq -cer "${query}" || return 1
}

# Shows the list of any mounted devices, images and/or
# shared folders.
# Arguments:
#  None
# Outputs:
#  A list of mounting points.
list_mounts () {
  local mounts='[]'

  local disks=''
  disks="$(find_disks | jq -cer '.[]|.path')" || return 1

  local disk=''
  while read -r disk; do
    local parts=''
    parts="$(find_partitions "${disk}" "mounted" |
      jq -cer '[.[]|{name: .path, point: (if .mountpoint then .mountpoint else .veracrypt.mountpoint end)}]')" || return 1

    # Merge disk partitions to mounts array
    mounts="$(jq -n --argjson m "${mounts}" --argjson p "${parts}" '$m + $p')" || return 1
  done <<< "${disks}"

  local roms=''
  roms="$(find_roms "mounted" | 
    jq -cer '[.[]|{name: .path, point: .mountpoint}]')" || return 1
  
  # Merge roms to mounts array
  mounts="$(jq -n --argjson m "${mounts}" --argjson r "${roms}" '$m + $r')" || return 1

  local folders=''
  folders="$(ls "/run/user/${UID}/gvfs" | awk -v id="${UID}" '{
    match($0, /server=(.*),share=(.*),/, a);

    schema="\"name\": \"%s\","
    schema=schema"\"point\": \"%s\""
    schema="{"schema"},"

    printf schema, a[1]"/"a[2], "/run/user/"id"/gvfs/"$0
  }')" || return 1

  # Remove the extra comma after the last element
  if [[ -n "${folders}" ]]; then
    folders="${folders::-1}"
  fi

  folders="[${folders}]"

  # Merge shared folders to mounts array
  mounts="$(jq -n --argjson m "${mounts}" --argjson f "${folders}" '$m + $f')" || return 1

  local images=''
  images="$(cat /proc/mounts | awk '/^fuseiso/{
    n=split($2, a, "/")

    schema="\"name\": \"%s\","
    schema=schema"\"point\": \"%s\""
    schema="{"schema"},"

    printf schema, a[n], $2
  }')" || return 1

  # Remove the extra comma after the last element
  if [[ -n "${images}" ]]; then
    images="${images::-1}"
  fi

  images="[${images}]"

  # Merge images to mounts array
  mounts="$(jq -n --argjson m "${mounts}" --argjson i "${images}" '$m + $i')" || return 1

  local len=0
  len="$(count "${mounts}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No mounts have found"
    return 0
  fi

  local query=''
  query+='Name:   \(.name)\n'
  query+='Point:  \(.point)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${mounts}" | jq -cer "${query}" || return 1
}

# Mounts the partition block device with the given path.
# Arguments:
#  path: the path of a partition block device
mount_partition () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_disk || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0

    pick_partition "${path}" "unmounted" || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]] || ! is_partition "${path}"; then
    echo "Unable to find partition ${path}"
    return 2
  elif is_mounted "${path}"; then
    echo "Partition ${path} is already mounted"
    return 2
  fi

  # Try to mount it as normal partition
  mount_device "${path}"

  if [[ $? -eq 0 ]]; then
    echo "Partition ${path} has been mounted"
    return 0
  fi

  # Otherwise try to mount it as encrypted partition
  ask_secret "Enter the encryption password:" || return $?
  local password="${REPLY}"

  mount_encrypted "${path}" "${password}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to mount partition"
    return 2
  fi

  echo "Partition ${path} has been mounted"
}

# Unmounts the partition block device with the
# given path.
# Arguments:
#  path: the path of a partition block device
unmount_partition () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_disk || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0

    pick_partition "${path}" "mounted" || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]] || ! is_partition "${path}"; then
    echo "Unable to find partition ${path}"
    return 2
  elif ! is_mounted "${path}"; then
    echo "Partition ${path} is already unmounted"
    return 2
  elif is_system_partition "${path}"; then
    echo "Cannot unmount system partition"
    return 2
  fi

  unmount_device "${path}"

  if [[ $? -eq 0 ]]; then
    echo "Partition ${path} has been unmounted"
    return 0
  fi

  unmount_encrypted "${path}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to unmount partition"
    return 2
  fi

  echo "Partition ${path} has been unmounted"
}

# Mounts the rom block device with the given path.
# Arguments:
#  path: the path of a rom block device
mount_rom () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_rom "unmounted" || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]] || ! is_rom "${path}"; then
    echo "Unable to find rom ${path}"
    return 2
  elif is_mounted "${path}"; then
    echo "Rom ${path} is already mounted"
    return 2
  fi

  mount_device "${path}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to mount rom"
    return 2
  fi

  echo "Rom ${path} has been mounted"
}

# Unmounts the rom block device with the given path.
# Arguments:
#  path: the path of a rom block device
unmount_rom () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_rom "mounted" || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]] || ! is_rom "${path}"; then
    echo "Unable to find rom ${path}"
    return 2
  elif ! is_mounted "${path}"; then
    echo "Rom ${path} is not mounted"
    return 2
  fi

  unmount_device "${path}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to unmount rom"
    return 2
  fi

  echo "Rom ${path} has been unmounted"
}

# Mounts the image file system contained with in
# the file with the given file path.
# Arguments:
#  path: the path to an image file
mount_image () {
  local path="${1}"

  if [[ ! -f "${path}" ]]; then
    echo "Not valid image file"
    return 2
  fi

  local folder_name="$(basename "${path}")"
  local mount_point="${HOME}/mounts/virtual/${folder_name}"

  if [[ -d "${mount_point}" ]]; then
    echo "Image ${path} is already mounted"
    return 2
  fi

  mkdir -p "${mount_point}" &&
  fuseiso -p "${path}" "${mount_point}" &> /dev/null

  if [[ $? -ne 0 ]]; then
    echo "Failed to mount image file"

    rm -rf "${mount_point}"
    return 2
  fi

  echo "Image file ${path} mounted"
}

# Unmounts the image file system mounted to the given
# path.
# Arguments:
#  path: the path an image is mounted to
unmount_image () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    local mounts=''
    mounts="$(cat /proc/mounts | awk '/^fuseiso/{
      print "{\"key\":\"" $2 "\",\"value\":\"" $2 "\"},"
    }')" || return 1

    # Remove the extra comma after the last element
    if [[ -n "${mounts}" ]]; then
      mounts="${mounts::-1}"
    fi

    mounts="[${mounts}]"

    local len=0
    len="$(count "${mounts}")" || return 1

    if [[ ${len} -eq 0 ]]; then
      echo "No image mounts have found"
      return 0
    fi

    pick_one "Select an image mount:" "${mounts}" "vertical" || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -d "${path}" ]]; then
    echo "No valid image mount path"
    return 2
  fi

  fusermount -u "${path}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to unmount image file system"
    return 2
  fi

  rm -rf "${path}"

  echo "Image file system ${path} unmounted"
}

# Mounts a shared folder of the given host.
# Arguments:
#  host: the name or ip of a host
mount_shared_folder () {
  local host="${1}"

  if [[ -z "${host}" ]]; then
    pick_host || return $?
    [[ -n "${REPLY}" ]] && host="${REPLY}" || return 0
  fi

  ask "Enter a shared folder:" || return $?
  local folder="${REPLY}"

  ask "Enter the username:" || return $?
  local username="${REPLY}"

  ask "Enter the workgroup [WORKGROUP]:" || return $?
  local workgroup="${REPLY:-"WORKGROUP"}"

  local uri="smb://${workgroup};${username}@${host}/${folder,,}"

  if gio mount -l | grep -q "${uri}"; then
    echo "Shared folder is already mounted"
    return 2
  fi

  gio mount "${uri}" 2> /dev/null
  
  if [[ $? -ne 0 ]]; then
    echo "Failed to mount shared folder"
    return 2
  fi

  echo "Shared folder ${folder} mounted"

  local remote_home="${HOME}/mounts/remote"

  if [[ -d "/run/user/${UID}/gvfs" ]] && [[ ! -L "${remote_home}/gvfs" ]]; then
    mkdir -p "${remote_home}"
    ln -s "/run/user/${UID}/gvfs" "${remote_home}"
  fi
}

# Unmounts the shared folder with the given uri.
# Arguments:
#  uri: the uri of the shared folder
unmount_shared_folder () {
  local uri="${1}"

  if [[ -z "${uri}" ]]; then
    local uris=''
    uris="$(ls /run/user/${UID}/gvfs | awk '{
      match($0, /domain=(.*),server=(.*),share=(.*),user=(.*)/, a);
      key="smb://"a[1]";"a[4]"@"a[2]"/"a[3]
      print "{\"key\": \""key"\", \"value\":\""key"\"},"
    }')" || return 1

    # Remove the extra comma after the last element
    if [[ -n "${uris}" ]]; then
      uris="${uris::-1}"
    fi

    uris="[${uris}]"

    local len=0
    len="$(count "${uris}")" || return 1

    if [[ ${len} -eq 0 ]]; then
      echo "No mounted shared folders have found"
      return 0
    fi

    pick_one "Select a shared folder:" "${uris}" "vertical" || return $?
    [[ -n "${REPLY}" ]] && uri="${REPLY}" || return 0
  fi

  if ! gio mount -l | grep -q "${uri}"; then
    echo "Shared folder is not mounted"
    return 2
  fi

  sync && gio mount -u "${uri}" 2> /dev/null
  
  if [[ $? -ne 0 ]]; then
    echo "Failed to umount shared folder"
    return 2
  fi

  echo "Shared folder ${uri} has been unmounted"
}

# Formats the disk block device with the given path,
# creating a new partition table of a single primary
# partition.
# Arguments:
#  path: the path of a disk block device
format_disk () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_disk || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]] || ! is_disk "${path}"; then
    echo "Unable to find disk ${path}"
    return 2
  elif is_system_disk "${path}"; then
    echo "Cannot format the system disk"
    return 2
  fi

  ask "Enter the disk label:" ".+" || return $?
  local label="${REPLY}"

  local fs_type=''
  pick_fs_type || return $?
  [[ -n "${REPLY}" ]] && fs_type="${REPLY}" || return 0

  local model=''
  model="$(find_disk "${path}" |
    jq -cr '"\(.vendor|gsub("^\\s+|\\s+$";"")) \(.model) \(.size)"')" || return 1

  echo "ALL DATA in ${model} [${path}],"
  echo "will be irreversibly gone forever!"
  confirm "Do you really want to proceed?" || return $?
  [[ "${REPLY}" != "yes" ]] && return 0

  echo "Unmounting disk partitions..."
  unmount_partitions "${path}" || return 1

  echo "Cleaning disk partitions..."
  clean_partitions "${path}" &&
  echo "Partition table is ready" || return 1

  echo "Creating disk partition..."
  create_partition "${path}" "${fs_type}" "1Mib" "100%" &&
  echo "Primary partition created" || return 1

  echo "Formatting disk partition..."
  format_partition "${path}" "1" "${fs_type}" "${label}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to format disk ${path}"
    return 2
  fi

  echo "Disk ${path} has been formated"
}

# Ejects the disk block device with the given path.
# Arguments:
#  path: the path of a disk block device
eject_disk () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_disk || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]] || ! is_disk "${path}"; then
    echo "Unable to find disk ${path}"
    return 2
  elif is_system_disk "${path}"; then
    echo "Cannot eject the system disk"
    return 2
  fi

  echo "Unmounting disk partitions..."

  unmount_partitions "${path}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to unmount disk partitions"
    return 2
  fi

  udisksctl power-off -b "${path}" &> /dev/null

  if [[ $? -eq 0 ]]; then
    echo "Disk power set to off"
    echo "Unplug safely the disk device"
  else
    echo "Unable to power disk off"
    echo "Unplug the disk device at your own risk"
  fi
}

# Scans the disk block device with the given path
# for possible SMART data.
# Arguments:
#  path: the path of a disk block device
# Outputs:
#  A long list of health and status data.
scan_disk () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_disk || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]] || ! is_disk "${path}"; then
    echo "Unable to find disk ${path}"
    return 2
  fi
  
  if ! sudo smartctl -i "${path}" &> /dev/null; then
    echo "Unable to retrieve SMART data"
    return 2
  fi

  local model=''
  model+='if .model_name'
  model+=' then "\nModel:     \(.model_name) FW.\(.firmware_version)"'
  model+=' else ""'
  model+='end'

  local physicals=''
  physicals+='if .physical_block_size'
  physicals+=' then " P:\(.physical_block_size)"'
  physicals+=' else ""'
  physicals+='end'

  local factor=''
  factor+='if .form_factor.name'
  factor+=' then "\nFactor:    \(.form_factor.name) \(.rotation_rate) rpm"'
  factor+=' else ""'
  factor+='end'

  local sata=''
  sata+='if .sata_version.string'
  sata+=' then "\nSATA:      \(.sata_version.string) at \(.interface_speed.max.string)"'
  sata+=' else ""'
  sata+='end'

  local trim=''
  trim+='if .trim.supported'
  trim+=' then "\nTrim:      \(.trim.supported)"'
  trim+=' else ""'
  trim+='end'

  local passed=''
  passed+='if .smart_status.passed then "passed" else "failed" end'

  local temp=''
  temp+='if .temperature.current'
  temp+=' then "\nTemp:      \(.temperature.current)C"'
  temp+=' else ""'
  temp+='end'

  local attr=''
  attr+='Attr:      \(.id)\n'
  attr+='Name:      \(.name)\n'
  attr+='Raw:       \(.raw.value)\n'
  attr+='Values:    [V\(.value), W\(.worst), T\(.thresh)]\n'
  attr+='Failing:   \(.when_failed)'

  local attrs=''
  attrs+='.ata_smart_attributes.table as $a |'
  attrs+="if \$a then \"\n\n\([\$a[]|\"${attr}\"]|join(\"\n\n\"))\" else \"\" end"

  local query=''
  query+='Name:      \(.device.name)'
  query+="\(${model})"
  query+='\nProtocol:  \(.device.type|ascii_upcase) \(.device.protocol)'
  query+='\nCapacity:  \(.user_capacity.bytes) bytes'
  query+="\nBlocks:    L:\(.logical_block_size)\(${physicals})"
  query+="\(${factor})"
  query+="\(${trim})"
  query+="\(${sata})"
  query+='\nSMART:     \(.smart_support.enabled)'
  query+="\(${temp})"
  query+="\nHealth:    \(${passed})"
  query+="\(${attrs})"

  sudo smartctl -iHj "${path}" | jq -cer "\"${query}\""

  local code="$?"

  if [[ ${code} -ne 0 ]] && [[ ${code} -ne 24 ]]; then
    echo "Failed to parse SMART data"
    return 2
  fi
}

# Creates an encrypted disk block device with the
# given path.
# Arguments:
#  path: the path of a disk block device
create_encrypted () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_disk || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]] || ! is_disk "${path}"; then
    echo "Unable to find disk ${path}"
    return 2
  elif is_system_disk "${path}"; then
    echo "Cannot encrypt the system disk"
    return 2
  fi

  local fs_type=''
  pick_fs_type || return $?
  [[ -n "${REPLY}" ]] && fs_type="${REPLY}" || return 0

  ask_secret "Enter the encryption password:" ".+" || return $?
  local password="${REPLY}"

  if ! confirm_secret "Retype the encryption password:" "${password}"; then
    echo 'Encryption password does not match'
    return 2
  fi

  local model=''
  model="$(find_disk "${path}" |
    jq -cr '"\(.vendor|gsub("^\\s+|\\s+$";"")) \(.model) \(.size)"')" || return 1

  echo "ALL DATA in ${model} [${path}],"
  echo "will be irreversibly gone forever!"
  confirm "Do you really want to proceed?" || return $?
  [[ "${REPLY}" != "yes" ]] && return 0

  echo "Unmounting disk partitions..."
  unmount_partitions "${path}" || return 1

  echo "Cleaning disk partitions..."
  clean_partitions "${path}" &&
  echo "Partition table is ready" || return 1

  echo "Creating disk partition..."
  create_partition "${path}" "${fs_type}" "1Mib" "100%" &&
  echo "Primary partition created" || return 1

  echo "Formatting disk partition..."
  format_partition "${path}" "1" "${fs_type}" &&
  echo "Partition ${path}1 has been formated" || return 1

  # Create a seed file with 350 random characters
  local rand_text_file="/tmp/.rand_text_$(date +%s)"

  tr -dc 'A-Za-z0-9!"#$%&'\''()*+,-./:;<=>?@[\]^_`{|}~' < /dev/urandom |
    head -c 350 > "${rand_text_file}"

  sudo veracrypt -t --create "${path}1" --password "${password}" \
    --volume-type normal --encryption AES --hash sha-512 --filesystem "${fs_type}" \
    --pim 0 --keyfiles "" --random-source "${rand_text_file}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to encrypt disk ${path}"
    return 2
  fi

  echo "Disk ${path} has been encrypted"
}

# Creates a bootable archlinux installation drive.
# Arguments:
#  path: the path of a disk block device
create_bootable () {
  local path="${1}"

  if [[ -z "${path}" ]]; then
    pick_disk || return $?
    [[ -n "${REPLY}" ]] && path="${REPLY}" || return 0
  fi

  if [[ ! -b "${path}" ]] || ! is_disk "${path}"; then
    echo "Unable to find disk ${path}"
    return 2
  elif is_system_disk "${path}"; then
    echo "Cannot create bootable on the system disk"
    return 2
  fi

  confirm "Do you want to download the latest iso?" || return $?
  [[ -z "${REPLY}" ]] && return 0

  local iso_file_path=''

  if [[ "${REPLY}" == "yes" ]]; then
    local hosts=''
    hosts+='{"key": "http://arch.phinau.de/iso/latest", "value": "Germany [phinau.de]"},'
    hosts+='{"key": "http://mirrors.acm.wpi.edu/archlinux/iso/latest", "value": "USA [acm.wpi.edu]"},'
    hosts+='{"key": "https://mirror.kamtv.ru/archlinux/iso/latest", "value": "Russia [kamtv.ru]"},'
    hosts+='{"key": "https://mirrors.bfsu.edu.cn/archlinux/iso/latest", "value": "China [bfsu.edu.cn]"},'
    hosts+='{"key": "https://mirror.vishmak.in/archlinux/iso/latest", "value": "India [vishmak.in]"},'
    hosts+='{"key": "http://archlinux.c3sl.ufpr.br/iso/latest", "value": "Brazil [c3sl.ufpr.br]"},'
    hosts+='{"key": "https://mirror.aarnet.edu.au/pub/archlinux/iso/latest", "value": "Australia [aarnet.edu.au]"}'
    hosts="[${hosts}]"

    local host=''
    pick_one "Select a mirror host:" "${hosts}" "vertical" || return $?
    [[ -n "${REPLY}" ]] && host="${REPLY}" || return 0

    local file='archlinux-x86_64.iso'
    local output="${HOME}/downloads"

    local files=(
      "${host}/b2sums.txt"
      "${host}/${file}.sig"
    )

    if [[ -f "${output}/${file}" ]]; then
      echo "An existing iso file is found"
    else
      files+=("${host}/${file}")
    fi

    # Clean up signature and checksum files
    rm -f "${output}/b2sums.txt"
    rm -f "${output}/${file}.sig"

    download "${output}" "${files[@]}"

    if [[ $? -ne 0 ]]; then
      echo "Unable to download archlinux files"
      return 2
    fi

    sq --force wkd get pierre@archlinux.org -o "${output}/release-key.pgp"

    if [[ $? -ne 0 ]]; then
      echo "Unable to fetch the release key"
      return 2
    fi

    echo "Verifying the integrity of files..."

    cd ${output} &&
    b2sum --ignore-missing -c b2sums.txt &&
    sq verify --signer-file release-key.pgp --detached "${file}.sig" "${file}" 2>&1 | awk NF

    if [[ $? -ne 0 ]]; then
      echo "Failed to verify archlinux files"
      return 2
    fi

    echo "Files have been verified successfully"

    iso_file_path="${output}/${file}"
  else
    ask "Enter the path to the iso file:" "^/.+" || return $?
    iso_file_path="${REPLY}"
  fi

  if [[ ! -f "${iso_file_path}" ]]; then
    echo "Invalid or unknown archlinux iso file"
    return 2
  fi

  local model=''
  model="$(find_disk "${path}" | jq -cr '"\(.vendor) \(.model) \(.size)"')" || return 1

  echo ""
  echo "ALL DATA in ${model} [${path}],"
  echo "will be irreversibly gone forever!"
  confirm "Do you really want to proceed?" || return $?
  [[ "${REPLY}" != "yes" ]] && return 0

  echo "Unmounting disk partitions..."
  unmount_partitions "${path}" || return 1

  echo "Cleaning disk partitions..."
  clean_partitions "${path}" &&
  echo "Partition table is ready" || return 1

  echo "Creating disk partition..."
  create_partition "${path}" "fat32" "1Mib" "100%" &&
  echo "Primary partition created" || return 1

  echo "Formatting the bootable disk..."
  format_partition "${path}" "1" "fat32" || return 1

  echo "Flashing installation files..."

  sudo dd "if=${iso_file_path}" "of=${path}" bs=4M conv=fsync oflag=direct status=progress

  if [[ $? -ne 0 ]]; then
    echo "Failed to flash installation files"
  fi

  echo "Bootable disk ${path} is ready"
}

# Shows the help message.
# Arguments:
#  None
# Outputs:
#  A long help message.
show_help () {
  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf " %-32s %s\n" \
    "help" "Show this help message." \
    "" "" \
    "show status" "Show a report of the file system." \
    "" "" \
    "show disk [<path>]" "Show a disk block device." \
    "show partition [<path>]" "Show a partition block device." \
    "show rom [<path>]" "Show an optical drive block device." \
    "" "" \
    "list disks" "List all disk block devices." \
    "list partitions [<path>]" "List the partitions of a disk block device." \
    "list roms" "List all optical block devices." \
    "list folders [<host>]" "List the shared folders of a host." \
    "list mounts" "List all mounting points." \
    "" "" \
    "mount partition [<path>]" "Mount a partition block device." \
    "unmount partition [<path>]" "Unmount a partition block device." \
    "mount rom [<path>]" "Mount an optical block device." \
    "unmount rom [<path>]" "Unmount an optical block device." \
    "mount image <path>" "Mount an iso, img image file system." \
    "unmount image [<path>]" "Unmount an image file system." \
    "mount folder [<host>]" "Mount a shared storage folder." \
    "unmount folder [<uri>]" "Unmount a shared storage folder." \
    "" "" \
    "format disk [<path>]" "Format a disk block device." \
    "eject disk [<path>]" "Eject a disk block device." \
    "scan disk [<path>]" "Scan a disk block device for SMART data." \
    "" "" \
    "create encrypted [<path>]" "Create an encrypted drive." \
    "create bootable [<path>]" "Create a bootable installation drive."
}

loop () {
  clear

  while true; do
    prompt && history -s "${REPLY}"

    set -f
    set_separator "line"
    local cmd=($(xargs -n1 <<< "${REPLY}"))
    restore_separator && set +f

    if [[ "${cmd[0]}" == "help" ]]; then
      show_help
      continue
    elif [[ "${cmd[0]}" == "clear" ]]; then
      clear
      continue
    elif [[ "${cmd[0]}" == "quit" ]]; then
      break
    elif [[ -z "${cmd[0]}" ]]; then
      continue
    fi

    case "${cmd[0]}" in
      "list")
        case "${cmd[1]}" in
          "disks") list_disks;;
          "partitions") list_partitions "${cmd[2]}";;
          "roms") list_roms;;
          "folders") list_shared_folders "${cmd[2]}";;
          "mounts") list_mounts;;
          *) echo "Invalid or unknown command";;
        esac;;
      "show")
        case "${cmd[1]}" in
          "status") show_status;;
          "disk") show_disk "${cmd[2]}";;
          "partition") show_partition "${cmd[2]}";;
          "rom") show_rom "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "mount")
        case "${cmd[1]}" in
          "partition") mount_partition "${cmd[2]}";;
          "rom") mount_rom "${cmd[2]}";;
          "image") mount_image "${cmd[2]}";;
          "folder") mount_shared_folder "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "unmount")
        case "${cmd[1]}" in
          "partition") unmount_partition "${cmd[2]}";;
          "rom") unmount_rom "${cmd[2]}";;
          "image") unmount_image "${cmd[2]}";;
          "folder") unmount_shared_folder "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "format")
        case "${cmd[1]}" in
          "disk") format_disk "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "eject")
        case "${cmd[1]}" in
          "disk") eject_disk "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "scan")
        case "${cmd[1]}" in
          "disk") scan_disk "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "create")
        case "${cmd[1]}" in
          "encrypted") create_encrypted "${cmd[2]}";;
          "bootable") create_bootable "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      *) echo "Invalid or unknown command";; 
    esac

    if [[ $? -eq 1 ]]; then
      echo "An unknown error has occurred"
    fi
  done

  clear
}

loop