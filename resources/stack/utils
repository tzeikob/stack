#!/usr/bin/env bash

WHITE=$'\e[0;37m'
RED=$'\e[0;31m'
GREEN=$'\e[0;32m'
BLUE=$'\e[0;34m'
YELLOW=$'\e[0;33m'

YE=$'\e[0;33m'
RE=$'\e[0;31m'
GR=$'\e[0;32m'
MA=$'\e[0;35m'
RS=$'\e[m'

abort () {
  local MESSAGE=${1:-"Something went wrong"}
  local CODE=${2:-1}

  echo "$MESSAGE"
  notify-send -u critical -t 5000 "We have problem!" "$MESSAGE"

  exit $CODE
}

require () {
  local DEPS=("${@}")
  local LEN=${#DEPS[@]}

  local INDEX=0
  while [ $INDEX -lt $LEN ]; do
    local DEP=${DEPS[$INDEX]}

    pacman -Qi "$DEP" &>/dev/null ||
    [ -f "/usr/bin/$DEP" ] ||
    [ -f "/usr/local/bin/$DEP" ] ||
      abort "Missing $DEP dependency"
    
    INDEX=$((INDEX + 1))
  done
}

contains () {
  local ITEM=$1 && shift
  local ARR=("${@}")
  local LEN=${#ARR[@]}

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    if [ "$ITEM" = "${ARR[$INDEX]}" ]; then
      return 0
    fi
  done

  return 1
}

uniques () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | awk -vRS='[ \n]' -vORS=' ' '!x[$0]++' | clean_spaces
}

clean_spaces () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | sed 's/ \{1,\}/ /g' | trim
}

askme () {
  local ARGS_LEN=$#
  local PROMPT=$1 && shift

  if [ $ARGS_LEN -gt 2 ]; then
    local OPTIONS=("${@}")

    read -rep "$PROMPT [${OPTIONS[*]}] " REPLY

    while ! contains "$REPLY" "${OPTIONS[@]}"; do
      read -rep " Please enter a valid value: " REPLY
    done
  elif [ $ARGS_LEN -eq 2 ]; then
    local RE=$1 && shift

    read -rep "$PROMPT " REPLY

    while [[ ! "$REPLY" =~ $RE ]]; do
      read -rep " Please enter a valid value: " REPLY
    done
  else
    read -rep "$PROMPT " REPLY
  fi
}

pick () {
  local PROMPT=$1 && shift
  local OPTIONS=("${@}")
  local LEN=${#OPTIONS[@]}

  local FRM='%01d %s\n'
  if [ $LEN -gt 10 ]; then
    FRM='%02d %s\n'
  fi

  print 1 30 "${OPTIONS[@]}" | sed -r 's/_+/ /g' | awk -v f="$FRM" -F'|' '{printf f,$1,$3}'
  read -rep "$PROMPT " REPLY

  while [[ ! $REPLY =~ ^[0-9]+$ ]] || (( $REPLY < 0 || $REPLY >= $LEN )); do
    read -rep " Please enter a valid value: " REPLY
  done
}

set_in_order () {
  local PROMPT=$1 && shift
  local OPTIONS=("${@}")
  local LEN=${#OPTIONS[@]}

  local FRM='%01d %s\n'
  if [ $LEN -gt 10 ]; then
    FRM='%02d %s\n'
  fi

  print 1 30 "${OPTIONS[@]}" | sed -r 's/_+/ /g' |
    awk -v f="$FRM" -F'|' '{if ($2) {printf f,NR-1,$2} else {printf f,NR-1,$0}}'
  
  read -rep "$PROMPT " REPLY
  REPLY=$(clean_spaces "$REPLY")

  while true; do
    if [[ $REPLY =~ ^(0|[1-9][0-9]*)( +(0|[1-9][0-9]*)){$((LEN-1))}$ ]]; then
      if echo "$REPLY" | uniques | awk -v l="$LEN" '{ \
        if (l != NF) exit 1; \
        for(i=1; i<=NF; i++) \
          if ($i < 0 || $i >= l) exit 1}'; then
        break
      fi
    fi
  
    read -rep " Please enter a valid input: " REPLY
    REPLY=$(clean_spaces "$REPLY")
  done
}

prompt () {
  local TEXT=$1
  local COLOR=${2:-$WHITE}
  local RESET=$'\e[m'

  read -rep "[${COLOR}$TEXT${RESET}] " REPLY
}

trim () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

no_breaks () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | tr -d '\n'
}

print () {
  local COLS=$1 && shift
  local PADDING=$1 && shift

  local ARR=("${@}")
  local LEN=${#ARR[@]}

  # Calculate total rows for the given length and columns
  local ROWS=$(((LEN + COLS - 1) / COLS))

  for ((i = 0; i < $ROWS; i++)); do
    for ((j = 0; j < $COLS; j++)); do
      # Map the index of the item to print vertically
      local INDX=$((i + (j * ROWS)))

      if [ ! -z "${ARR[$INDX]}" ]; then
        local TEXT="$(no_breaks "${ARR[$INDX]}")"

        printf "%-${PADDING}s\t" "$TEXT"
      fi
    done

    printf "\n"
  done
}
