#!/usr/bin/env bash

ES=$';'
ES_LN=$';\n'
LS=$'~'

WHITE=$'\e[0;37m'
RED=$'\e[0;31m'
GREEN=$'\e[0;32m'
BLUE=$'\e[0;34m'
YELLOW=$'\e[0;33m'

YE=$'\e[0;33m'
RE=$'\e[0;31m'
GR=$'\e[0;32m'
MA=$'\e[0;35m'
RS=$'\e[m'

abort () {
  local MESSAGE=${1:-"Something went wrong"}
  local CODE=${2:-1}

  echo "$MESSAGE"
  notify-send -u critical -t 5000 "We have problem!" "$MESSAGE"

  exit $CODE
}

require () {
  local DEPS=("${@}")
  local LEN=${#DEPS[@]}

  local INDEX=0
  while [ $INDEX -lt $LEN ]; do
    local DEP=${DEPS[$INDEX]}

    pacman -Qi "$DEP" &>/dev/null ||
    [ -f "/usr/bin/$DEP" ] ||
    [ -f "/usr/local/bin/$DEP" ] ||
      abort "Missing $DEP dependency"
    
    INDEX=$((INDEX + 1))
  done
}

contains () {
  local ITEM=$1 && shift
  local ARR=("${@}")
  local LEN=${#ARR[@]}

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    if [ "$ITEM" = "${ARR[$INDEX]}" ]; then
      return 0
    fi
  done

  return 1
}

uniques () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | awk -vRS='[ \n]' -vORS=' ' '!x[$0]++' | clean_spaces
}

clean_spaces () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | sed 's/ \{1,\}/ /g' | trim
}

askme () {
  local ARGS_LEN=$#
  local PROMPT=$1 && shift

  if [ $ARGS_LEN -gt 2 ]; then
    local OPTIONS=("${@}")

    read -rep "$PROMPT [${OPTIONS[*]}] " REPLY

    while ! contains "$REPLY" "${OPTIONS[@]}"; do
      read -rep " Please enter a valid value: " REPLY
    done
  elif [ $ARGS_LEN -eq 2 ]; then
    local RE=$1 && shift

    read -rep "$PROMPT " REPLY

    while [[ ! "$REPLY" =~ $RE ]]; do
      read -rep " Please enter a valid value: " REPLY
    done
  else
    read -rep "$PROMPT " REPLY
  fi
}

pick () {
  local PROMPT=$1 && shift
  local OPTIONS=("${@}")
  local LEN=${#OPTIONS[@]}

  local FRM='%01d %s\n'
  if [ $LEN -gt 10 ]; then
    FRM='%02d %s\n'
  fi

  print 1 30 "${OPTIONS[@]}" | sed -r 's/_+/ /g' | awk -v f="$FRM" -F'|' '{printf f,$1,$3}'
  read -rep "$PROMPT " REPLY

  while [[ ! $REPLY =~ ^[0-9]+$ ]] || (( $REPLY < 0 || $REPLY >= $LEN )); do
    read -rep " Please enter a valid value: " REPLY
  done
}

prompt () {
  local TEXT=$1
  local COLOR=${2:-$WHITE}
  local RESET=$'\e[m'

  read -rep "[${COLOR}$TEXT${RESET}] " REPLY
}

trim () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

no_breaks () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | tr -d '\n'
}

print () {
  local COLS=$1 && shift
  local PADDING=$1 && shift

  local ARR=("${@}")
  local LEN=${#ARR[@]}

  # Calculate total rows for the given length and columns
  local ROWS=$(((LEN + COLS - 1) / COLS))

  for ((i = 0; i < $ROWS; i++)); do
    for ((j = 0; j < $COLS; j++)); do
      # Map the index of the item to print vertically
      local INDX=$((i + (j * ROWS)))

      if [ ! -z "${ARR[$INDX]}" ]; then
        local TEXT="$(no_breaks "${ARR[$INDX]}")"

        printf "%-${PADDING}s\t" "$TEXT"
      fi
    done

    printf "\n"
  done
}

pick_one () {
  local PROMPT=$1
  local OPTIONS=$2
  local MODE=$3

  if [ ! $(count "$OPTIONS") -gt 0 ]; then
    return 1
  fi

  echo "$PROMPT"

  if [[ "$MODE" =~ ^vertical-[1-9][0-9]*$ ]]; then
    local LINES=$(echo "$MODE" | cut -d '-' -f 2)
    REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$ES_LN" -l -L "$ES" -n "$LINES" -S /\($LS.*\)//v)
    return
  fi
  
  if [[ "$MODE" =~ ^tabular-[1-9][0-9]*$ ]]; then
    local TABS=$(echo "$MODE" | cut -d '-' -f 2)
    REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$ES_LN" -t "$TABS" -S /\($LS.*\)//v)
    return
  fi
  
  REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$ES_LN" -S /\($LS.*\)//v)
  echo "R: <$REPLY>"
}

pick_by_order () {
  local PROMPT=$1
  local OPTIONS=$2
  local COUNT=$3
  local MODE=$4

  if [ ! $(count "$OPTIONS") -gt 0 ]; then
    return 1
  fi

  echo "$PROMPT"

  if [[ "$MODE" =~ ^vertical-[1-9][0-9]*$ ]]; then
    local LINES=$(echo "$MODE" | cut -d '-' -f 2)
    REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$ES_LN" -l -L "$ES" -n "$LINES" -S /\($LS.*\)//v -P "$ES")

    while [ -n "$REPLY" ] && [ ! $(count "$REPLY") == $COUNT ]; do
      echo "Please select exactly $COUNT items:"
      REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$ES_LN" -l -L "$ES" -n "$LINES" -S /\($LS.*\)//v -P "$ES")
    done

    return
  fi
  
  if [[ "$MODE" =~ ^tabular-[1-9][0-9]*$ ]]; then
    local TABS=$(echo "$MODE" | cut -d '-' -f 2)
    REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$ES_LN" -t "$TABS" -S /\($LS.*\)//v -P "$ES")

    while [ -n "$REPLY" ] && [ ! $(count "$REPLY") == $COUNT ]; do
      echo "Please select exactly $COUNT items:"
      REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$ES_LN" -t "$TABS" -S /\($LS.*\)//v -P "$ES")
    done

    return
  fi
  
  REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$ES_LN" -S /\($LS.*\)//v -P "$ES")

  while [ -n "$REPLY" ] && [ ! $(count "$REPLY") == $COUNT ]; do
    echo "Please select exactly $COUNT items:"
    REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$ES_LN" -S /\($LS.*\)//v -P "$ES")
  done
}

set_separator () {
  DEFAULT_IFS=$IFS

  case "$1" in
    "space") IFS=$' ';;
    "line") IFS=$'\n';;
    "tab") IFS=$'\t';;
    *) IFS="$1"
  esac
}

restore_separator () {
  if [ -n "$DEFAULT_IFS" ]; then
    IFS=$DEFAULT_IFS
  else
    IFS=$' \n\t'
  fi
}

count () {
  local ELEMENTS="$1"

  if [ -z "$ELEMENTS" ] || [[ "$ELEMENTS" =~ ^${ES}+$ ]]; then
    echo 0
  else
    set_separator "$ES"
    local ARRAY=($ELEMENTS)
    restore_separator

    echo "${#ARRAY[@]}"
  fi
}

element () {
  local INDEX=$1
  local ELEMENTS=$2
  local EXTRACT=$3

  if [ -z "$ELEMENTS" ] || [[ "$ELEMENTS" =~ ^${ES}+$ ]]; then
    echo ""
  else
    INDEX=$((INDEX + 1))
    local ELEMENT=$(echo "$ELEMENTS" | cut -d "$ES" -f "$INDEX")

    if [ "$EXTRACT" = "value" ];then
      value "$ELEMENT"
    elif [ "$EXTRACT" = "label" ];then
      label "$ELEMENT"
    else
      echo "$ELEMENT"
    fi
  fi
}

label () {
  local ELEMENT="$1"

  echo "$ELEMENT" | cut -d "$LS" -f 1
}

value () {
  local ELEMENT="$1"

  echo "$ELEMENT" | cut -d "$LS" -f 2
}
