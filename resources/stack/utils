#!/bin/bash

CONFIG_HOME="${HOME}/.config/stack"

RESOURCES_HOME="${HOME}/.local/share"
COLORS_HOME="${RESOURCES_HOME}/colors"
WALLPAPERS_HOME="${RESOURCES_HOME}/wallpapers"

AES=$'╬'
AES_LN=$'╬\n'
KVS=$'▒'

# Sets the IFS to the given value.
# Globals:
#  IFS
# Arguments:
#  value: space, line, tab or any character
set_separator () {
  local value="${1}"

  case "${value}" in
    "space") IFS=$' ';;
    "line") IFS=$'\n';;
    "tab") IFS=$'\t';;
    *) IFS="${value}";;
  esac
}

# Restores the IFS to the default value.
# Globals:
#  IFS
# Arguments:
#  None
restore_separator () {
  IFS=$' \n\t'
}

# Exits the process printing the given message
# to stderr.
# Arguments:
#  message: an optional error message
# Outputs:
#  An optional error message.
abort () {
  local message="${1}"

  if [[ -n "${message}" ]]; then
    echo "${message}" >&2
  fi

  exit 1
}

# Removes leading and trailing white spaces
# from the given string or input.
# Arguments:
#  input: a string or input of a pipeline
trim () {
  local input=''
  [[ -p /dev/stdin ]] && input="$(cat -)" || input="${@}"

  echo "${input}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

# Asks the user to enter a value, which is validated
# by the optional regular expression. The answer is
# kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  prompt: a text line
#  re:     an optional regular expression
# Outputs:
#  A prompt text line.
ask () {
  local prompt="${1}"
  local re="${2}"

  if [[ -n "${re}" ]]; then
    read -rep "${prompt} " REPLY

    while [[ ! "${REPLY}" =~ ${re} ]]; do
      read -rep "Please enter a valid value: " REPLY
    done
  else
    read -rep "${prompt} " REPLY
  fi
}

# Asks the user to enter a password, the answer is
# kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  prompt: a text line
# Outputs:
#  A prompt text line.
ask_password () {
  local prompt="${1}"

  read -srep "${prompt} " REPLY
}

# Shows a Yes/No menu and asks user to select an option,
# where the selection is kept in the global var REPLY
# either as a yes or no value.
# Globals:
#  REPLY, AES, AES_LN, KVS
# Arguments:
#  prompt: a text line
# Outputs:
#  A menu of yes or no options.
confirm () {
  local prompt="${1}"
  
  local options="yes${KVS}Yes${AES}no${KVS}No"

  echo "${prompt}"
  REPLY="$(echo "${options}" |
    smenu -nm -/ prefix -W "${AES_LN}" -S /\(.*"${KVS}"\)//v)" || return 1

  if [[ -n "${REPLY}" ]]; then
    # Remove the value part from the selected option
    REPLY="$(echo "${REPLY}" | sed -r "s/(.*)${KVS}.*/\1/")"
  fi
}

# Shows a menu and asks user to pick one option, where
# the selection is kept in the global var REPLY as a
# value equal to the key property of the selected option.
# Globals:
#  REPLY, AES, AES_LN, KVS
# Arguments:
#  prompt:  a text line
#  options: a JSON array of {key, value} pairs
#  mode:    horizontal, vertical, tabular
#  slots:   number of vertical or tabular slots
# Outputs:
#  A menu of the given options.
pick_one () {
  local prompt="${1}"
  local options="${2}"
  local mode="${3}"
  local slots="${4:-6}"

  local len=0
  len="$(count "${options}")" || return 1
  [[ ${len} -eq 0 ]] && return 1

  local args=()
  if [[ "${mode}" == "vertical" ]]; then
    args+=(-l -L "${AES}" -n "${slots}")
  elif [[ "${mode}" == "tabular" ]]; then
    args+=(-t "${slots}")
  fi

  # Convert options to a line of key${KVS}value${AES} pairs
  options="$(echo "${options}" |
    jq -cer '[.[]|("\(.key)'"${KVS}"'\(.value)")]|join("'"${AES}"'")')" || return 1

  echo "${prompt}"
  REPLY="$(echo "${options}" |
    smenu -nm -/ prefix -W "${AES_LN}" "${args[@]}" -S /\(.*"${KVS}"\)//v)" || return 1

  if [[ -n "${REPLY}" ]]; then
    # Remove the value part from the selected option
    REPLY="$(echo "${REPLY}" | sed -r "s/(.*)${KVS}.*/\1/")"
  fi
}

# Shows a menu and asks user to pick many options in order,
# where the selection is kept in the global var REPLY as a
# JSON array with elements equal to the key property of every
# selected option.
# Globals:
#  REPLY, AES, AES_LN, KVS
# Arguments:
#  prompt:  a text line
#  options: a JSON array of {key, value} pairs
#  size:    how many options must be selected
#           all all must be selected
#           a,b at least a and up to b
#           a,  at least a
#           ,b  up to b
#  mode:    horizontal, vertical, tabular
#  slots:   number of vertical or tabular slots
# Outputs:
#  A menu of the given options.
pick_many () {
  local prompt="${1}"
  local options="${2}"
  local size="${3}"
  local mode="${4}"
  local slots="${5:-6}"

  local len=0
  len="$(count "${options}")" || return 1
  [[ ${len} -eq 0 ]] && return 1

  local min=0
  local max=0
  if [[ "${size}" =~ ^all$ ]]; then
    min="${len}"
    max="${len}"
  elif [[ "${size}" =~ ^[1-9][0-9]*,$ ]]; then
    min="$(echo "${size}" | cut -d ',' -f 1)"
    max="${len}"
  elif [[ "${size}" =~ ^,[1-9][0-9]*$ ]]; then
    min=1
    max="$(echo "${size}" | cut -d ',' -f 2)"
  elif [[ "${size}" =~ ^[1-9][0-9]*,[1-9][0-9]*$ ]]; then
    min="$(echo "${size}" | cut -d ',' -f 1)"
    max="$(echo "${size}" | cut -d ',' -f 2)"
  else
    return 1
  fi

  local args=()
  if [[ "${mode}" == "vertical" ]]; then
    args+=(-l -L "${AES}" -n "${slots}")
  elif [[ "${mode}" == "tabular" ]]; then
    args+=(-t "${slots}")
  fi

  # Convert options to a line of key${KVS}value${AES} pairs
  options="$(echo "${options}" |
    jq -cer '[.[]|("\(.key)'"${KVS}"'\(.value)")]|join("'"${AES}"'")')" || return 1

  while true; do
    echo "${prompt}"
    REPLY="$(echo "${options}" |
      smenu -nm -/ prefix -W "${AES_LN}" "${args[@]}" -S /\(.*"${KVS}"\)//v -P "${AES}")" || return 1

    [[ -z "${REPLY}" ]] && return 0

    # Validate the selection size matching the min/max limits
    local selected="$(echo "${REPLY}" | awk -F"${AES}" '{print NF}')"

    if [[ ${selected} -ge ${min} ]] && [[ ${selected} -le ${max} ]]; then
      # Convert selected options to a JSON array of their keys
      REPLY="$(echo "${REPLY}" | awk -F"${AES}" '{
        out=""
        for (i=1;i<=NF;i++) {
          gsub(/('"${KVS}"'.*$)/, "", $i);
          out=out "\""$i"\","
        }
        print out
      }')"

      # Remove last post fixed comma
      [[ "${REPLY}" =~ ,$ ]] && REPLY="[${REPLY::-1}]"

      return 0
    fi

    [[ ${min} -eq ${max} ]] &&
      prompt="Please select exactly ${max} items:" ||
      prompt="Please select at least ${min} or up to ${max} items:"
  done
}

# Gets a JSON object's property its key matching the
# given query, where query could be any valid jq query.
# Arguments:
#  object: a JSON object
#  query:  a jq query
# Outputs:
#  The value of the given key.
get () {
  local object="${1}"
  local query="${2:-"."}|if . then . else \"\" end"

  local result=''
  result="$(echo "${object}" | jq -cr "${query}")" || return 1

  echo "${result}"
}

# Counts the number of elements in the given JSON array.
# Arguments:
#  array: a JSON array object
# Outputs:
#  The number of array elements.
count () {
  local array="${1}"

  local result=0
  result="$(echo "${array}" | jq -cer 'length')" || return 1

  echo "${result}"
}

# Returns the md5 hash of the given string value
# truncated to the first given number of characters.
# Arguments:
#  value:  a string value
#  length: the number of character to keep
# Outputs:
#  A truncated md5 hash value.
get_hash () {
  local value="${1}"
  local length="${2:-32}"

  echo "${value}" | md5sum | cut "-c1-${length}"
}