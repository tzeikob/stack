#!/bin/bash

CONFIG_HOME="${HOME}/.config/stack"

RESOURCES_HOME="${HOME}/.local/share"
COLORS_HOME="${RESOURCES_HOME}/colors"
WALLPAPERS_HOME="${RESOURCES_HOME}/wallpapers"

AES=$'╬'
AES_LN=$'╬\n'
KVS=$'▒'

# Sets the IFS to the given value.
# Globals:
#  IFS
# Arguments:
#  value: space, line, tab or any character
set_separator () {
  local value="$1"

  case "${value}" in
    "space") IFS=$' ';;
    "line") IFS=$'\n';;
    "tab") IFS=$'\t';;
    *) IFS="${value}";;
  esac
}

# Restores the IFS to the default value.
# Globals:
#  IFS
# Arguments:
#  None
restore_separator () {
  IFS=$' \n\t'
}

# Exits the process printing the given message
# to stderr.
# Arguments:
#  message: an optional error message
# Outputs:
#  An optional error message.
abort () {
  local message="$1"

  if [[ -n "${message}" ]]; then
    echo "${message}" >&2
  fi

  exit 1
}

require () {
  local DEPS=("${@}")
  local LEN=${#DEPS[@]}

  local INDEX=0
  while [ $INDEX -lt $LEN ]; do
    local DEP=${DEPS[$INDEX]}

    pacman -Qi "$DEP" &>/dev/null ||
    [ -f "/usr/bin/$DEP" ] ||
    [ -f "/usr/local/bin/$DEP" ] ||
      abort "Missing $DEP dependency"
    
    INDEX=$((INDEX + 1))
  done
}

contains () {
  local ITEM=$1 && shift
  local ARR=("${@}")
  local LEN=${#ARR[@]}

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    if [ "$ITEM" = "${ARR[$INDEX]}" ]; then
      return 0
    fi
  done

  return 1
}

uniques () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | awk -vRS='[ \n]' -vORS=' ' '!x[$0]++' | clean_spaces
}

clean_spaces () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | sed 's/ \{1,\}/ /g' | trim
}

askme () {
  local ARGS_LEN=$#
  local PROMPT=$1 && shift

  if [ $ARGS_LEN -gt 2 ]; then
    local OPTIONS=("${@}")

    read -rep "$PROMPT [${OPTIONS[*]}] " REPLY

    while ! contains "$REPLY" "${OPTIONS[@]}"; do
      read -rep " Please enter a valid value: " REPLY
    done
  elif [ $ARGS_LEN -eq 2 ]; then
    local RE=$1 && shift

    read -rep "$PROMPT " REPLY

    while [[ ! "$REPLY" =~ $RE ]]; do
      read -rep " Please enter a valid value: " REPLY
    done
  else
    read -rep "$PROMPT " REPLY
  fi
}

pick () {
  local PROMPT=$1 && shift
  local OPTIONS=("${@}")
  local LEN=${#OPTIONS[@]}

  local FRM='%01d %s\n'
  if [ $LEN -gt 10 ]; then
    FRM='%02d %s\n'
  fi

  print 1 30 "${OPTIONS[@]}" | sed -r 's/_+/ /g' | awk -v f="$FRM" -F'|' '{printf f,$1,$3}'
  read -rep "$PROMPT " REPLY

  while [[ ! $REPLY =~ ^[0-9]+$ ]] || (( $REPLY < 0 || $REPLY >= $LEN )); do
    read -rep " Please enter a valid value: " REPLY
  done
}

prompt () {
  local TEXT=$1
  local COLOR=${2:-$WHITE}
  local RESET=$'\e[m'

  read -rep "[${COLOR}$TEXT${RESET}] " REPLY
}

trim () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

no_breaks () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | tr -d '\n'
}

print () {
  local COLS=$1 && shift
  local PADDING=$1 && shift

  local ARR=("${@}")
  local LEN=${#ARR[@]}

  # Calculate total rows for the given length and columns
  local ROWS=$(((LEN + COLS - 1) / COLS))

  for ((i = 0; i < $ROWS; i++)); do
    for ((j = 0; j < $COLS; j++)); do
      # Map the index of the item to print vertically
      local INDX=$((i + (j * ROWS)))

      if [ ! -z "${ARR[$INDX]}" ]; then
        local TEXT="$(no_breaks "${ARR[$INDX]}")"

        printf "%-${PADDING}s\t" "$TEXT"
      fi
    done

    printf "\n"
  done
}

# Asks the user to enter a value, which is validated
# by the optional regular expression. The answer is
# kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  prompt: a text line
#  re:     an optional regular expression
# Outputs:
#  A prompt text line.
ask () {
  local prompt="$1"
  local re="$2"

  if [[ -n "${re}" ]]; then
    read -rep "${prompt} " REPLY

    while [[ ! "${REPLY}" =~ ${re} ]]; do
      read -rep "Please enter a valid value: " REPLY
    done
  else
    read -rep "${prompt} " REPLY
  fi
}

# Asks the user to enter a password, the answer is
# kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  prompt: a text line
# Outputs:
#  A prompt text line.
ask_password () {
  local prompt="$1"

  read -srep "${prompt} " REPLY
}

# Shows a Yes/No menu and asks user to select an option,
# where the selection is kept in the global var REPLY
# either as a yes or no value.
# Globals:
#  REPLY, AES, AES_LN, KVS
# Arguments:
#  prompt: a text line
# Outputs:
#  A menu of yes or no options.
confirm () {
  local prompt="$1"
  
  local options="yes${KVS}Yes${AES}no${KVS}No"

  echo "${prompt}"
  REPLY="$(echo "${options}" |
    smenu -nm -/ prefix -W "${AES_LN}" -S /\(.*"${KVS}"\)//v)" || return 1

  if [[ -n "${REPLY}" ]]; then
    # Remove the value part from the selected option
    REPLY="$(echo "${REPLY}" | sed -r "s/(.*)${KVS}.*/\1/")"
  fi
}

# Shows a menu and asks user to pick one option, where
# the selection is kept in the global var REPLY as a
# value equal to the key property of the selected option.
# Globals:
#  REPLY, AES, AES_LN, KVS
# Arguments:
#  prompt:  a text line
#  options: a JSON array of {key, value} pairs
#  mode:    horizontal, vertical, tabular
#  slots:   number of vertical or tabular slots
# Outputs:
#  A menu of the given options.
pick_one () {
  local prompt="$1"
  local options="$2"
  local mode="$3"
  local slots="${4:-6}"

  local len=0
  len="$(count "${options}")" || return 1
  [[ ${len} -eq 0 ]] && return 1

  local args=()
  if [[ "${mode}" == "vertical" ]]; then
    args+=(-l -L "${AES}" -n "${slots}")
  elif [[ "${mode}" == "tabular" ]]; then
    args+=(-t "${slots}")
  fi

  # Convert options to a line of key${KVS}value${AES} pairs
  options="$(echo "${options}" |
    jq -cer '[.[]|("\(.key)'"${KVS}"'\(.value)")]|join("'"${AES}"'")')" || return 1

  echo "${prompt}"
  REPLY="$(echo "${options}" |
    smenu -nm -/ prefix -W "${AES_LN}" "${args[@]}" -S /\(.*"${KVS}"\)//v)" || return 1

  if [[ -n "${REPLY}" ]]; then
    # Remove the value part from the selected option
    REPLY="$(echo "${REPLY}" | sed -r "s/(.*)${KVS}.*/\1/")"
  fi
}

# Shows a menu and asks user to pick many options in order,
# where the selection is kept in the global var REPLY as a
# JSON array with elements equal to the key property of every
# selected option.
# Globals:
#  REPLY, AES, AES_LN, KVS
# Arguments:
#  prompt:  a text line
#  options: a JSON array of {key, value} pairs
#  size:    how many options must be selected
#           all all must be selected
#           a,b at least a and up to b
#           a,  at least a
#           ,b  up to b
#  mode:    horizontal, vertical, tabular
#  slots:   number of vertical or tabular slots
# Outputs:
#  A menu of the given options.
pick_many () {
  local prompt="$1"
  local options="$2"
  local size="$3"
  local mode="$4"
  local slots="${5:-6}"

  local len=0
  len="$(count "${options}")" || return 1
  [[ ${len} -eq 0 ]] && return 1

  local min=0
  local max=0
  if [[ "${size}" =~ ^all$ ]]; then
    min="${len}"
    max="${len}"
  elif [[ "${size}" =~ ^[1-9][0-9]*,$ ]]; then
    min="$(echo "${size}" | cut -d ',' -f 1)"
    max="${len}"
  elif [[ "${size}" =~ ^,[1-9][0-9]*$ ]]; then
    min=1
    max="$(echo "${size}" | cut -d ',' -f 2)"
  elif [[ "${size}" =~ ^[1-9][0-9]*,[1-9][0-9]*$ ]]; then
    min="$(echo "${size}" | cut -d ',' -f 1)"
    max="$(echo "${size}" | cut -d ',' -f 2)"
  else
    return 1
  fi

  local args=()
  if [[ "${mode}" == "vertical" ]]; then
    args+=(-l -L "${AES}" -n "${slots}")
  elif [[ "${mode}" == "tabular" ]]; then
    args+=(-t "${slots}")
  fi

  # Convert options to a line of key${KVS}value${AES} pairs
  options="$(echo "${options}" |
    jq -cer '[.[]|("\(.key)'"${KVS}"'\(.value)")]|join("'"${AES}"'")')" || return 1

  while true; do
    echo "${prompt}"
    REPLY="$(echo "${options}" |
      smenu -nm -/ prefix -W "${AES_LN}" "${args[@]}" -S /\(.*"${KVS}"\)//v -P "${AES}")" || return 1

    [[ -z "${REPLY}" ]] && return

    # Validate the selection size matching the min/max limits
    local selected="$(echo "${REPLY}" | awk -F"${AES}" '{print NF}')"

    if [[ ${selected} -ge ${min} ]] && [[ ${selected} -le ${max} ]]; then
      # Convert selected options to a JSON array of their keys
      REPLY="$(echo "${REPLY}" | awk -F"${AES}" '{
        out=""
        for (i=1;i<=NF;i++) {
          gsub(/('"${KVS}"'.*$)/, "", $i);
          out=out "\""$i"\","
        }
        print out
      }')"

      # Remove last post fixed comma
      [[ "${REPLY}" =~ ,$ ]] && REPLY="[${REPLY::-1}]"

      return
    fi

    [[ ${min} -eq ${max} ]] &&
      prompt="Please select exactly ${max} items:" ||
      prompt="Please select at least ${min} or up to ${max} items:"
  done
}

# Gets a JSON object's property its key matching the
# given query, where query could be any valid jq query.
# Arguments:
#  object: a JSON object
#  query:  a jq query
# Outputs:
#  The value of the given key.
get () {
  local object="$1"
  local query="$2"

  local result=''
  result="$(echo "${object}" | jq -cer "${query}")" || return 1

  echo "${result}"
}

# Asserts if the given JSON object has a property with
# a key matching the given query, where query could be
# any valid jq query.
# Arguments:
#  object: a JSON object
#  query:    a jq query
#  value:  a string value
# Returns:
#  0 if succeeds otherwise 1.
assert () {
  local object="$1"
  local query="$2"
  local value="$3"

  local result
  result="$(echo "${object}" | jq -cer "${query}")" || return 1

  [[ "${result}" == "${value}" ]] && return 0 || return 1
}

# Counts the number of elements in the given JSON array.
# Arguments:
#  array: a JSON array object
# Outputs:
#  The number of array elements.
count () {
  local array="$1"

  local result=0
  result="$(echo "${array}" | jq -cer '.|length')" || return 1

  echo "${result}"
}

# Returns the i-th element of the given JSON array.
# Arguments:
#  array: a JSON array object
#  index: a zero-based integer
# Outputs:
#  The i-th element of the array.
element () {
  local array="$1"
  local index="$2"

  local result
  result="$(echo "${array}" | jq -cer ".[${index}]")" || return 1

  [[ "${result}" != "null" ]] && echo "${result}" || echo ""
}

set_prop () {
  local KEY=$1
  local VALUE=$2
  local FILE=$3

  if [ -z "$KEY" ]; then
    return 1
  fi

  if [ ! -f "$FILE" ]; then
    return 1
  fi

  echo "$(jq "$KEY = \"$VALUE\"" "$FILE")" > "$FILE"
}

get_prop () {
  local KEY=$1
  local FILE=$2

  if [ -z "$KEY" ]; then
    return 1
  fi

  if [ ! -f "$FILE" ]; then
    return 1
  fi

  jq -r "$KEY" "$FILE"
}

# Returns the md5 hash of the given string value
# truncated to the first given number of characters.
# Arguments:
#  value:  a string value
#  length: the number of character to keep
# Outputs:
#  A truncated md5 hash value.
get_hash () {
  local value="$1"
  local length="${2:-32}"

  echo "${value}" | md5sum | cut "-c1-${length}"
}