#!/usr/bin/env bash

AES=$',,'
AES_LN=$',,\n'
KVS=$'::'

CONFIG_HOME=~/.config/stack

WHITE=$'\e[0;37m'
RED=$'\e[0;31m'
GREEN=$'\e[0;32m'
BLUE=$'\e[0;34m'
YELLOW=$'\e[0;33m'

YE=$'\e[0;33m'
RE=$'\e[0;31m'
GR=$'\e[0;32m'
MA=$'\e[0;35m'
RS=$'\e[m'

abort () {
  local MESSAGE=$1

  if [ -n "$MESSAGE" ]; then
    echo "$MESSAGE"
  fi

  exit 1
}

require () {
  local DEPS=("${@}")
  local LEN=${#DEPS[@]}

  local INDEX=0
  while [ $INDEX -lt $LEN ]; do
    local DEP=${DEPS[$INDEX]}

    pacman -Qi "$DEP" &>/dev/null ||
    [ -f "/usr/bin/$DEP" ] ||
    [ -f "/usr/local/bin/$DEP" ] ||
      abort "Missing $DEP dependency"
    
    INDEX=$((INDEX + 1))
  done
}

contains () {
  local ITEM=$1 && shift
  local ARR=("${@}")
  local LEN=${#ARR[@]}

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    if [ "$ITEM" = "${ARR[$INDEX]}" ]; then
      return 0
    fi
  done

  return 1
}

uniques () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | awk -vRS='[ \n]' -vORS=' ' '!x[$0]++' | clean_spaces
}

clean_spaces () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | sed 's/ \{1,\}/ /g' | trim
}

askme () {
  local ARGS_LEN=$#
  local PROMPT=$1 && shift

  if [ $ARGS_LEN -gt 2 ]; then
    local OPTIONS=("${@}")

    read -rep "$PROMPT [${OPTIONS[*]}] " REPLY

    while ! contains "$REPLY" "${OPTIONS[@]}"; do
      read -rep " Please enter a valid value: " REPLY
    done
  elif [ $ARGS_LEN -eq 2 ]; then
    local RE=$1 && shift

    read -rep "$PROMPT " REPLY

    while [[ ! "$REPLY" =~ $RE ]]; do
      read -rep " Please enter a valid value: " REPLY
    done
  else
    read -rep "$PROMPT " REPLY
  fi
}

pick () {
  local PROMPT=$1 && shift
  local OPTIONS=("${@}")
  local LEN=${#OPTIONS[@]}

  local FRM='%01d %s\n'
  if [ $LEN -gt 10 ]; then
    FRM='%02d %s\n'
  fi

  print 1 30 "${OPTIONS[@]}" | sed -r 's/_+/ /g' | awk -v f="$FRM" -F'|' '{printf f,$1,$3}'
  read -rep "$PROMPT " REPLY

  while [[ ! $REPLY =~ ^[0-9]+$ ]] || (( $REPLY < 0 || $REPLY >= $LEN )); do
    read -rep " Please enter a valid value: " REPLY
  done
}

prompt () {
  local TEXT=$1
  local COLOR=${2:-$WHITE}
  local RESET=$'\e[m'

  read -rep "[${COLOR}$TEXT${RESET}] " REPLY
}

trim () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

no_breaks () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | tr -d '\n'
}

print () {
  local COLS=$1 && shift
  local PADDING=$1 && shift

  local ARR=("${@}")
  local LEN=${#ARR[@]}

  # Calculate total rows for the given length and columns
  local ROWS=$(((LEN + COLS - 1) / COLS))

  for ((i = 0; i < $ROWS; i++)); do
    for ((j = 0; j < $COLS; j++)); do
      # Map the index of the item to print vertically
      local INDX=$((i + (j * ROWS)))

      if [ ! -z "${ARR[$INDX]}" ]; then
        local TEXT="$(no_breaks "${ARR[$INDX]}")"

        printf "%-${PADDING}s\t" "$TEXT"
      fi
    done

    printf "\n"
  done
}

confirm () {
  local PROMPT=$1

  echo "$PROMPT"
  
  local OPTIONS="Yes${KVS}yes${AES}No${KVS}no"
  REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$AES_LN" -S /\($KVS.*\)//v)
}

pick_one () {
  local PROMPT=$1
  local OPTIONS=$2
  local MODE=$3

  if [[ "$OPTIONS" =~ .*${AES}$ ]]; then
    OPTIONS="${OPTIONS::-${#AES}}"
  fi

  if [[ "$OPTIONS" =~ ^($AES)*$ ]]; then
    return 1
  elif [ ! $(count "$OPTIONS") -gt 0 ]; then
    return 1
  fi

  echo "$PROMPT"

  if [[ "$MODE" =~ ^vertical-[1-9][0-9]*$ ]]; then
    local LINES=$(echo "$MODE" | cut -d '-' -f 2)
    REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$AES_LN" -l -L "$AES" -n "$LINES" -S /\($KVS.*\)//v)
    return
  fi
  
  if [[ "$MODE" =~ ^tabular-[1-9][0-9]*$ ]]; then
    local TABS=$(echo "$MODE" | cut -d '-' -f 2)
    REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$AES_LN" -t "$TABS" -S /\($KVS.*\)//v)
    return
  fi
  
  REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$AES_LN" -S /\($KVS.*\)//v)
}

pick_many () {
  local PROMPT=$1
  local OPTIONS=$2
  local MIN=$3
  local MAX=$4
  local MODE=$5

  if [[ "$OPTIONS" =~ .*${AES}$ ]]; then
    OPTIONS="${OPTIONS::-${#AES}}"
  fi

  if [[ "$OPTIONS" =~ ^($AES)*$ ]]; then
    return 1
  elif [ ! $(count "$OPTIONS") -gt 0 ]; then
    return 1
  fi

  echo "$PROMPT"

  if [[ "$MODE" =~ ^vertical-[1-9][0-9]*$ ]]; then
    local LINES=$(echo "$MODE" | cut -d '-' -f 2)
    REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$AES_LN" -l -L "$AES" -n "$LINES" -S /\($KVS.*\)//v -P "$AES")
    local COUNT=$(count "$REPLY")

    while [ -n "$REPLY" ] && (( $COUNT < $MIN )) || (( $COUNT > $MAX )); do
      [ $MIN = $MAX ] && echo "Please select exactly $MAX items:" ||
        echo "Please select at least $MIN or up to $MAX items:"

      REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$AES_LN" -l -L "$AES" -n "$LINES" -S /\($KVS.*\)//v -P "$AES")
      COUNT=$(count "$REPLY")
    done

    return
  fi
  
  if [[ "$MODE" =~ ^tabular-[1-9][0-9]*$ ]]; then
    local TABS=$(echo "$MODE" | cut -d '-' -f 2)
    REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$AES_LN" -t "$TABS" -S /\($KVS.*\)//v -P "$AES")
    local COUNT=$(count "$REPLY")

    while [ -n "$REPLY" ] && (( $COUNT < $MIN )) || (( $COUNT > $MAX )); do
      [ $MIN = $MAX ] && echo "Please select exactly $MAX items:" ||
        echo "Please select at least $MIN or up to $MAX items:"

      REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$AES_LN" -t "$TABS" -S /\($KVS.*\)//v -P "$AES")
      COUNT=$(count "$REPLY")
    done

    return
  fi
  
  REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$AES_LN" -S /\($KVS.*\)//v -P "$AES")
  local COUNT=$(count "$REPLY")

  while [ -n "$REPLY" ] && (( $COUNT < $MIN )) || (( $COUNT > $MAX )); do
    [ $MIN = $MAX ] && echo "Please select exactly $MAX items:" ||
      echo "Please select at least $MIN or up to $MAX items:"

    REPLY=$(echo "$OPTIONS" | smenu -nm -/ prefix -W "$AES_LN" -S /\($KVS.*\)//v -P "$AES")
    COUNT=$(count "$REPLY")
  done
}

set_separator () {
  DEFAULT_IFS=$IFS

  case "$1" in
    "space") IFS=$' ';;
    "line") IFS=$'\n';;
    "tab") IFS=$'\t';;
    *) IFS="$1"
  esac
}

restore_separator () {
  if [ -n "$DEFAULT_IFS" ]; then
    IFS=$DEFAULT_IFS
  else
    IFS=$' \n\t'
  fi
}

count () {
  local ELEMENTS="$1"

  if [[ "$ELEMENTS" =~ .*${AES}$ ]]; then
    ELEMENTS="${ELEMENTS::-${#AES}}"
  fi

  echo "$ELEMENTS" | awk -F "$AES" '{print NF}'
}

element () {
  local ELEMENTS=$1
  local INDEX=$2

  if [[ "$ELEMENTS" =~ .*${AES}$ ]]; then
    ELEMENTS="${ELEMENTS::-${#AES}}"
  fi

  INDEX=$((INDEX + 1))
  echo "$ELEMENTS" | awk -F "$AES" '{print $'$INDEX'}'
}

key () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | awk -F "$KVS" '{if ($1) {print $1} else {print $0}}'
}

value () {
  local INPUT=""
  [[ -p /dev/stdin ]] && INPUT="$(cat -)" || INPUT="${@}"

  echo "$INPUT" | awk -F "$KVS" '{if ($2) {print $2} else {print $0}}'
}
