#!/bin/bash

set -o pipefail
source /opt/stack/utils

# Shows a prompt status and asks user to enter the
# next command, which is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A minimal prompt status line.
prompt () {
  local status=''
  status="$(timedatectl | jc --timedatectl | jq -cer '.time_zone' | cut -d ' ' -f 1)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to resolve status"
    status='none'
  fi

  read -rep "[clock:${status}] " REPLY
}

# Shows the current status of system clock.
# Arguments:
#  None
# Outputs:
#  A verbose list of text data.
show_status () {
  local query=''
  query+='Local Time:      \(.local_time)\n'
  query+='Universal Time:  \(.universal_time)\n'
  query+='RTC Time:        \(.rtc_time)\n'
  query+='Time Zone:       \(.time_zone)\n'
  query+='Synced:          \(.system_clock_synchronized)\n'
  query+='NTP Service:     \(.ntp_service)\n'
  query+='RTC Local TZ:    \(.rtc_in_local_tz)\n'
  query+='Epoch UTC:       \(.epoch_utc)'

  timedatectl | jc --timedatectl | jq -cer "\"${query}\""

  if [[ $? -ne 0 ]]; then
    echo "Unable to resolve date time status"
    return 2
  fi

  local ntp_status=''
  ntp_status="$(timedatectl timesync-status 2> /dev/null)"

  if [[ $? -eq 0 ]]; then
    local query=''
    query+='Server:          \(.server)\n'
    query+='Poll Interval:   \(.poll_interval)\n'
    query+='Leap:            \(.leap)'
    
    echo "${ntp_status}" | jc --timedatectl | jq -cer "\"${query}\""
  fi
}

# Activates or deactivates the NTP service.
# Arguments:
#  status: on or off
set_ntp () {
  local status="${1}"

  if [[ ! "${status}" =~ ^(on|off)$ ]]; then
    echo "Invalid status value"
    return 2
  fi

  local status_name='enabled'
  [[ "${status}" == "off" ]] && status_name='disabled'

  timedatectl set-ntp "${status}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to ${status_name} the NTP service"
    return 2
  fi

  echo "NTP service has been ${status_name}"
}

# Sets the timezone to the given region.
# Arguments:
#  timezone: a timezone in region/city form
set_timezone () {
  local timezone="${1}"

  local timezones=''
  timezones="$(timedatectl list-timezones | awk '{print "{\"key\":\""$0"\",\"value\":\""$0"\"},"}')"
  timezones="[${timezones::-1}]"

  if [[ -z "${timezone}" ]]; then
    pick_one "Select a timezone:" "${timezones}" "vertical" || return $?
    [[ -n "${REPLY}" ]] && timezone="${REPLY}" || return 0
  fi

  local exists=''
  exists="$(echo "${timezones}" | jq -cer ".[]|select(.key == \"${timezone}\")")"

  if [[ -z "${exists}" ]]; then
    echo "Invalid timezone value"
    return 2
  fi

  timedatectl set-timezone "${timezone}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to set the timezone"
    return 2
  fi
  
  echo "Timezone set to ${timezone}"
}

# Sets the system time to the given hours and minutes.
# Arguments:
#  time: the time in HH:mm form
set_time () {
  local time="${1}"

  if [[ ! "${time}" =~ ^[0-9][0-9]:[0-9][0-9]$ ]]; then
    echo "Invalid time value"
    return 2
  fi

  local hour=$(echo "${time}" | cut -d ':' -f 1)
  local min=$(echo "${time}" | cut -d ':' -f 2)

  if ((${hour} > 23)); then
    echo "Hour value is out of range"
    return 2
  fi

  if ((${min} > 59)); then
    echo "Minute value is out of range"
    return 2
  fi

  timedatectl set-time "${time}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to set the time"
    return 2
  fi

  echo "Time set to ${time}"
}

# Sets the system date to the given hours and minutes.
# Arguments:
#  time: the time in hh:mm form
set_date () {
  local date="${1}"

  if [[ ! "${date}" =~ ^[0-9][0-9]([0-9][0-9])?-[0-9][0-9]-[0-9][0-9]$ ]]; then
    echo "Invalid date value"
    return 2
  fi

  local year=$(echo "${date}" | cut -d '-' -f 1)
  local month=$(echo "${date}" | cut -d '-' -f 2)
  local day=$(echo "${date}" | cut -d '-' -f 3)

  if ((${month} == 0 || ${month} > 12)) ; then
    echo "Month value is out of range"
    return 2
  fi

  if ((${day} == 0 || ${day} > 31)); then
    echo "Day value is out of range"
    return 2
  fi

  local time=$(date +"%H:%M:%S")

  timedatectl set-time "${date} ${time}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to set the date"
    return 2
  fi

  echo "Date set to ${date}"
}

# Sets the hardware clock to local or UTC time.
# Arguments:
#  mode: local or utc
set_rtc () {
  local mode="${1}"

  if [[ ! "${mode}" =~ ^(local|utc)$ ]]; then
    echo "Invalid rtc mode value"
    return 2
  fi

  if [[ "${mode}" == "local" ]]; then
    timedatectl --adjust-system-clock set-local-rtc on
  else
    timedatectl --adjust-system-clock set-local-rtc off
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to set RTC"
    return 2
  fi

  echo "RTC set to ${mode} time"
}

# Synchronizes the hardware clock from the system clock.
# Arguments:
#  None
sync_rtc () {
  sudo hwclock --systohc --utc

  if [[ $? -ne 0 ]]; then
    echo "Failed to sync the hardware clock"
    return 2
  fi

  echo "Hardware clock synced from the system clock"
}

# Shows the help message.
# Arguments:
#  None
# Outputs:
#  A long help message.
show_help () {
  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf " %-30s %s\n" \
    "help" "Show this help message." \
    "" "" \
    "show status" "Show the system date time status." \
    "" "" \
    "set timezone [<Region/City>]" "Set the system timezone." \
    "set time <HH:MM:SS>" "Set the system local time." \
    "set date <YYYY-mm-dd>" "Set the system date." \
    "" "" \
    "set ntp on|off" "Enable or disable the NTP service." \
    "set rtc local|utc" "Set the hardware clock to local or UTC time." \
    "" "" \
    "sync rtc" "Sync the hardware clock from the system clock."
}

loop () {
  clear

  while true; do
    prompt && history -s "${REPLY}"

    set -f
    set_separator "line"
    local cmd=($(xargs -n1 <<< "${REPLY}"))
    restore_separator && set +f

    if [[ "${cmd[0]}" == "help" ]]; then
      show_help
      continue
    elif [[ "${cmd[0]}" == "clear" ]]; then
      clear
      continue
    elif [[ "${cmd[0]}" == "quit" ]]; then
      break
    elif [[ -z "${cmd[0]}" ]]; then
      continue
    fi

    case "${cmd[0]}" in
      "show")
        case "${cmd[1]}" in
          "status") show_status;;
          *) echo "Invalid or unknown command";;
        esac;;
      "set")
        case "${cmd[1]}" in
          "ntp") set_ntp "${cmd[2]}";;
          "timezone") set_timezone "${cmd[2]}";;
          "time") set_time "${cmd[2]}";;
          "date") set_date "${cmd[2]}";;
          "rtc") set_rtc "${cmd[2]}";;
          *) echo "Invalid or unknown command";; 
        esac;;
      "sync")
        case "${cmd[1]}" in
          "rtc") sync_rtc;;
          *) echo "Invalid or unknown command";; 
        esac;;
      *) echo "Invalid or unknown command";; 
    esac

    if [[ $? -eq 1 ]]; then
      echo "An unknown error has occurred"
    fi
  done

  clear
}

loop