#!/bin/bash

set -o pipefail
source /opt/stack/utils

# The settings file should has the following schema:
# {
#   "layout": {
#    "DP-1": "--mode <mode>...",
#    "DP-2": "--mode <mode>...",
#    "DP-3": "--off"
#   },
#   "colors": {
#     "DP-1": {
#       "index": "0",
#       "profile": "*.icc"
#     },
#     "DP-2": {
#       "index": "1",
#       "profile": "*.icc"
#     }
#   }
# }

SETTINGS_FILE="${CONFIG_HOME}/displays.json"

require "xorg-xrandr"
require "xcalib"

# Returns a list of outputs having the given status.
# Arguments:
#  status: all, connected, disconnected,
#          active, inactive, primary
# Outputs:
#  A JSON array of outputs.
find_outputs () {
  local status="${1:-"all"}"

  local states='all|connected|disconnected|active|inactive|primary'
  if [[ ! "${status}" =~ ^(${states})$ ]]; then
    return 1
  fi

  local criteria='true'
  if [[ "${status}" == "connected" ]]; then
    criteria='.is_connected == true'
  elif [[ "${status}" == "disconnected" ]]; then
    criteria='.is_connected == false'
  elif [[ "${status}" == "active" ]]; then
    criteria='.is_connected == true and .resolution_width != null'
  elif [[ "${status}" == "inactive" ]]; then
    criteria='.is_connected == true and .resolution_width == null'
  elif [[ "${status}" == "primary" ]]; then
    criteria='.is_primary == true'
  fi

  local a=''
  a+='.screens[]|select(.screen_number==0)'
  a+=" |.associated_device|select(${criteria})"
  a="[${a}]"

  local b=''
  b+=".unassociated_devices[]|select(${criteria})"
  b="[${b}]"

  local query="${a}+${b}"

  xrandr | jc --xrandr | jq -cer "${query}" || return 1
}

# Returns the output with the given name.
# Arguments:
#  name: any string
# Outputs:
#  A JSON object of output.
find_output () {
  local name="$1"

  local query=".[]|select(.device_name == \"${name}\")"

  find_outputs "all" | jq -cer "${query}" || return 1
}

# Finds the index of the output with the given name.
# Arguments:
#  name: any string
# Outputs:
#  The index number of the output.
find_index () {
  local name="$1"

  local query=".value.device_name == \"${name}\""
  query="to_entries[]|select(${query})|.key"

  find_outputs "all" | jq -cer "${query}" || return 1
}

# Asserts if the given output is connected.
# Arguments:
#  output: a JSON object output
# Returns:
#  0 if is connected otherwise 1.
is_connected () {
  local output="${1}"

  local query='select(.is_connected)'

  echo "${output}" | jq -cer "${query}" &>/dev/null || return 1
}

# Asserts if the given output is active.
# Arguments:
#  output: a JSON object output
# Returns:
#  0 if is active otherwise 1.
is_active () {
  local output="${1}"

  local query='select(.is_connected and .resolution_width != null)'

  echo "${output}" | jq -cer "${query}" &>/dev/null || return 1
}

# Asserts if the given output is primary.
# Arguments:
#  output: a JSON object output
# Returns:
#  0 if is primary otherwise 1.
is_primary () {
  local output="${1}"

  local query='select(.is_primary)'

  echo "${output}" | jq -cer "${query}" &>/dev/null || return 1
}

# Shows a menu asking the user to select one output, where the
# answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  prompt:  a prompt text line
#  status: all, connected, disconnected,
#          active, inactive, primary
# Outputs:
#  A menu of output names.
pick_output () {
  local prompt="$1"
  local status="$2"

  # Convert outputs list into an array of {key, value} options
  local query=''
  query+='[.[]|{key: "\(.device_name)", value: "\(.device_name)"}]'

  local options=''
  options="$(find_outputs "${status}" | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${options}")" || return 1
  [[ ${len} -eq 0 ]] &&
    echo "No ${status:-\b} outputs have found" && return 1

  pick_one "${prompt}" "${options}" "horizontal" || return 1
}

# Shows a menu asking the user to select many outputs,
# where the answer is kept in the global var REPLY as
# a JSON array of output names.
# Globals:
#  REPLY
# Arguments:
#  prompt:  a prompt text line
#  status:  all, connected, disconnected,
#           active, inactive, primary
#  size:    the number of items must be selected
#  skip:    the output to except from selection
# Outputs:
#  A menu of output names.
pick_outputs () {
  local prompt="$1"
  local status="$2"
  local size="$3"
  local skip="$4"

  local except='select(true)'
  if [[ -n "${skip}" ]]; then
    except="select(.device_name != \"${skip}\")"
  fi

  # Convert outputs list into an array of {key, value} options
  local query='{key: "\(.device_name)", value: "\(.device_name)"}'
  query="[.[]|${except}|${query}]"

  local options=''
  options="$(find_outputs "${status}" | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${options}")" || return 1
  [[ ${len} -eq 0 ]] &&
    echo "No ${status:-\b} outputs have found" && return 1

  pick_many "${prompt}" "${options}" "${size}" "horizontal" || return 1
}

# Shows a menu of resolutions of the given output and waits
# the user to pick one option. The selected option is kept
# in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  output: a JSON object output
# Outputs:
#  A menu of resolutions.
pick_resolution () {
  local output="$1"

  # Convert resolutions list into an array of {key, value} options
  local query=''
  query+='.associated_modes[]'
  query+=' |"\(.resolution_width)x\(.resolution_height)" as $res'
  query+=' |{key: "\($res)", value: "\($res)"}'
  query="[${query}]"

  local options=''
  options="$(echo "${output}" | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${options}")" || return 1
  [[ ${len} -eq 0 ]] &&
    echo "No resolutions have found" && return 1

  pick_one "Select a resolution:" "${options}" "vertical" || return 1
}

# Shows a menu of resolution rates of the given output and
# waits the user to pick one option. The selected option is
# kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  output: a JSON object output
# Outputs:
#  A menu of resolution rates.
pick_rate () {
  local output="$1"
  local resolution="$2"

  # Convert rates list into an array of {key, value} options
  local query=''
  query+='.associated_modes[]'
  query+=' |"\(.resolution_width)x\(.resolution_height)" as $res'
  query+=" |select(\$res == \"${resolution}\")"
  query+=' |"\(.frequencies[].frequency)" as $freq'
  query+=' |{key: "\($freq)", value: "\($freq)"}'
  query="[${query}]"

  local options=''
  options="$(echo "${output}" | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${options}")" || return 1
  [[ ${len} -eq 0 ]] &&
    echo "No refresh rates have found" && return 1

  pick_one "Select a refresh rate:" "${options}" "horizontal" || return 1
}

# Shows a menu of layout modes and waits the user to pick
# one. The selected option is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of layout modes.
pick_layout () {
  local len=0
  len="$(count "$(find_outputs "active")")" || return 1

  if [[ ${len} -lt 2 ]] || [[ ${len} -gt 3 ]]; then
    echo "No layout options found for ${len} display setups"
    return 1
  fi

  local layouts=''

  if [[ ${len} == 2 ]]; then
    layouts+='{"key": "row-2", "value": "SideBySide"},'
    layouts+='{"key": "col-2", "value": "TopBottom"}'
    layouts="[${layouts}]"

    echo "SideBySide  TopBottom"
    echo "----------  ----------"
    echo "[A][B]      [A]"
    echo "            [B]"
    echo
  elif [[ ${len} == 3 ]]; then
    layouts+='{"key": "row-3", "value": "SideBySide"},'
    layouts+='{"key": "col-3", "value": "TopBottom"},'
    layouts+='{"key": "gamma-3", "value": "LeftGamma"},'
    layouts+='{"key": "gamma-rev-3", "value": "RightGamma"},'
    layouts+='{"key": "lambda-3", "value": "LeftLambda"},'
    layouts+='{"key": "lambda-rev-3", "value": "RightLambda"}'
    layouts="[${layouts}]"

    echo "SideBySide  TopBottom   LeftGamma"
    echo "----------  ----------  -----------"
    echo "[A][B][C]   [A]         [A][B]"
    echo "            [B]         [C]"
    echo "            [C]"
    echo
    echo "RightGamma  LeftLambda  RightLambda"
    echo "----------  ----------  -----------"
    echo "[A][B]      [A]            [A]"
    echo "   [C]      [B][C]      [B][C]"
    echo
  fi

  pick_one "Select a layout mode:" "${layouts}" "tabular" "${len}" || return 1
}

# Shows a prompt status and asks user to enter the
# next command, which is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A minimal prompt status line.
prompt () {
  local status=''

  status="$(find_outputs "primary" | jq -cer '.[0].device_name')"
  [[ $? -ne 0 ]] && status='failure'

  read -rep "[displays:${status}] " REPLY
}

# Shows the current status of Xorg and active displays.
# Globals:
#  DISPLAY, COLORS, SETTINGS_FILE
# Arguments:
#  None
# Outputs:
#  A verbose list of text data.
show_status () {
  local re='/^('
  re+='name\sof\sdisplay|'
  re+='version\snumber|'
  re+='vendor\sstring|'
  re+='vendor\srelease\snumber|'
  re+='X.Org\sversion|'
  re+='motion\sbuffer\ssize|'
  re+='image\sbyte\sorder|'
  re+='default\sscreen\snumber|'
  re+='number\sof\sscreens'
  re+=')/'

  xdpyinfo -display "${DISPLAY}" | awk -F': ' "${re}"'{
    gsub(/[ \t]+$/, "", $1);
    gsub(/^[ \t]+/, "", $2);
    printf "%-23s %s\n",$1":",$2
  }' | sed -r 's/\<./\U&/g' || echo "Unable to retrieve xdpy info"

  local colors='{}'
  if [[ -f "${SETTINGS_FILE}" ]]; then
    local settings="$(<"${SETTINGS_FILE}")"
    colors="$(echo "${settings}" |
      jq -cr 'if .colors != null then .colors else "{}" end')"
  fi

  local rate=''
  rate+='[.associated_modes[].frequencies]|flatten'
  rate+=' |[.[]|select(.is_current==true)]'
  rate+=' |.[0].frequency'

  local offset='[\(.offset_width),\(.offset_height)]'
  local trans='\(.rotation) \(.reflection|ascii_downcase)'

  local query=''
  query+='Output:   \(.device_name)\(if .is_primary then "*" else "" end)\n'
  query+="Mode:     \(.resolution_width)x\(.resolution_height)@\(${rate})Hz\n"
  query+="Pos:      ${offset} ${trans}\n"
  query+='Color:    \(.colors|.[$dn]|if . != null then .profile else "none" end)'

  # Merge colors setting to extract the color profile per output
  query=".[]|.+{colors:\$c}|.device_name as \$dn|(\"\n${query}\")"

  find_outputs "active" | jq -cer --argjson c "${colors}" "${query}"

  if [[ $? -ne 0 ]]; then
    echo "Unable to retrieve outputs"
    return 1
  fi
}

# Shows the Xorg displays log file.
# Globals:
#  HOME, DISPLAY
# Arguments:
#  None
# Outputs:
#  The log file of the xorg display.
show_logs () {
  local id="$(echo "${DISPLAY}" | cut -d ':' -f 2)"
  local log_file="${HOME}/.local/share/xorg/Xorg.${id}.log"

  if [[ ! -f "${log_file}" ]]; then
    echo "Unable to find the log file ${log_file}"
    return 1
  fi

  cat "${log_file}"
}

# Shows the data of the output with the given name.
# Globals:
#  REPLY, SETTINGS_FILE
# Arguments:
#  name: any string
# Outputs:
#  A verbose list of text data.
show_output () {
  local name="$1"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "all" || return 1
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return
  fi

  local color='Color:     none'
  if [[ -f "${SETTINGS_FILE}" ]]; then
    local settings="$(<"${SETTINGS_FILE}")"

    local query=''
    query=".colors.\"${name}\"|if . != null then .profile else \"none\" end"
    color="Color:     $(echo "${settings}" | jq -cr "${query}")"
  fi

  local base=''
  base+='Name:      \(.device_name)\n'
  base+='Connected: \(.is_connected)\n'
  base+='Primary:   \(.is_primary)'

  local rate=''
  rate+='[.associated_modes[].frequencies]|flatten'
  rate+=' |[.[]|select(.is_current==true)]'
  rate+=' |.[0].frequency'

  local extra=''
  extra+='Mode:      \(.resolution_width)x\(.resolution_height)\n'
  extra+="Rate:      \(${rate})Hz\n"
  extra+='Offset:    [\(.offset_width),\(.offset_height)]\n'
  extra+='Rotate:    \(.rotation)\n'
  extra+='Reflect:   \(.reflection|ascii_downcase)'

  local modes=''
  modes+='.associated_modes[]|'
  modes+='"\(.resolution_width)x\(.resolution_height)" as $mode|"'
  modes+='\($mode)'
  modes+='\($mode|if (9-length)>0 then (" "*(9-length)) else "" end)'
  modes+=' [\([.frequencies[]|.frequency]|join(", "))]"'

  modes="[${modes}]|join(\"\n           \")"

  local query=''
  query+="${base}"
  query+='\(if .is_connected and .resolution_width != null'
  query+=" then \"\n${extra}\""
  query+=' else "" end)'
  query+="\n${color}"
  query+='\(if .associated_modes|length != 0'
  query+=" then \"\nModes:     \(${modes})\""
  query+=' else "" end)'

  query=".[]|select(.device_name==\"${name}\")|(\"${query}\")"

  find_outputs "all" | jq -cer "${query}"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 1
  fi
}

# Shows the list of outputs matching the given status.
# Arguments:
#  status: all, connected, disconnected,
#          active, inactive, primary
# Outputs:
#  A list of outputs.
list_outputs () {
  local status="${1:-"all"}"

  local states='all|connected|disconnected|active|inactive|primary'
  if [[ ! "${status}" =~ ^(${states})$ ]]; then
    echo "Invalid status value"
    return 1
  fi

  local query=''
  query+='Name:      \(.device_name)\n'
  query+='Connected: \(.is_connected)\n'
  query+='Primary:   \(.is_primary)\n'

  query=".[]|(\"${query}\")"

  local outputs=''
  outputs="$(find_outputs "${status}" | jq -cr "${query}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to retrieve outputs"
    return 1
  fi

  if [[ -z "${outputs}" ]]; then
    echo "No ${status:-\b} outputs have found"
    return 1
  fi

  echo "${outputs}"
}

# Sets the resolution and rate of the output with the
# given name.
# Globals:
#  REPLY
# Arguments:
#  name:       any string
#  resolution: a resolution string, e.g. 600x800
#  rate:       a decimal number, e.g. 60.00
set_mode () {
  local name="${1}"
  local resolution="${2}"
  local rate="${3}"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return 1
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 1
  elif ! is_connected "${output}"; then
    echo "Cannot set mode of a disconnected output"
    return 1
  elif ! is_active "${output}"; then
    echo "Cannot set mode of an inactive output"
    return 1
  fi

  if [[ -z "$resolution" ]]; then
    pick_resolution "${output}" || return 1
    [[ -n "${REPLY}" ]] && resolution="${REPLY}" || return
  fi
  
  if [[ ! "${resolution}" =~ ^[0-9]+x[0-9]+$ ]]; then
    echo "Invalid resolution value"
    return 1
  fi

  if [[ -z "${rate}" ]]; then
    pick_rate "${output}" "${resolution}" || return 1
    [[ -n "${REPLY}" ]] && rate="${REPLY}" || return
  fi
  
  if [[ ! "${rate}" =~ ^[0-9][0-9]+(.[0-9][0-9])?$ ]]; then
    echo "Invalid refresh rate value"
    return 1
  fi

  xrandr --output "${name}" --mode "${resolution}" --rate "${rate}" &&
    echo "Output ${name} mode set to ${resolution}" ||
    echo "Failed to set mode of output ${name}"
}

# Sets the output with the given name as primary.
# Globals:
#  REPLY
# Arguments:
#  name: any string
set_primary () {
  local name="$1"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return 1
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 1
  elif ! is_connected "${output}"; then
    echo "Cannot set primary a disconnected output"
    return 1
  elif ! is_active "${output}"; then
    echo "Cannot set primary an inactive output"
    return 1
  elif is_primary "${output}"; then
    echo "Output ${name} is already the primary"
    return 1
  fi

  xrandr --output "${name}" --primary &&
    echo "Output ${name} has been set as primary" ||
    echo "Failed to set output ${name} as primary"
}

# Sets the output with the given name on.
# Globals:
#  REPLY
# Arguments:
#  name: any string
set_on () {
  local name="$1"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "inactive" || return 1
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 1
  elif ! is_connected "${output}"; then
    echo "Cannot activate a disconnected output"
    return 1
  elif is_active "${output}"; then
    echo "Output ${name} is already active"
    return 1
  fi

  xrandr --output "${name}" --auto &&
    echo "Output ${name} has been activated" ||
    echo "Failed to activate output ${name}"
}

# Sets the output with the given name off.
# Globals:
#  REPLY
# Arguments:
#  name: any string
set_off () {
  local name="$1"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return 1
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 1
  elif ! is_connected "${output}"; then
    echo "Cannot deactivate a disconnected output"
    return 1
  elif ! is_active "${output}"; then
    echo "Output ${output} is already inactive"
    return 1
  elif is_primary "${output}"; then
    echo "Cannot deactivate the primary output"
    return 1
  fi

  xrandr --output "${name}" --off &&
    echo "Output ${name} has been deactivated" ||
    echo "Failed to deactivate output ${name}"
}

# Sets the reflection of the output with the given name.
# Globals:
#  REPLY
# Arguments:
#  name: any string
#  mode: normal, x, y, xy
reflect () {
  local name="$1"
  local mode="$2"
  
  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return 1
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 1
  elif ! is_connected "${output}"; then
    echo "Cannot reflect a disconnected output"
    return 1
  elif ! is_active "${output}"; then
    echo "Cannot reflect an inactive output"
    return 1
  fi

  if [[ -z "${mode}" ]]; then
    local modes=''
    modes+='{"key": "normal", "value": "Normal"},'
    modes+='{"key": "x", "value": "X Axis"},'
    modes+='{"key": "y", "value": "Y Axis"},'
    modes+='{"key": "xy", "value": "XY Axis"}'
    modes="[${modes}]"

    pick_one "Select a reflection mode:" "${modes}" "horizontal" || return 1
    [[ -n "${REPLY}" ]] && mode="${REPLY}" || return
  fi
  
  if [[ ! "${mode}" =~ ^(normal|x|y|xy)$ ]]; then
    echo "Invalid reflection value"
    return 1
  fi

  xrandr --output "${name}" --reflect "${mode}" &&
    echo "Output ${name} reflected to ${mode} mode" ||
    echo "Failed to reflect output ${name}"
}

# Sets the rotation of the output with the given name.
# Globals:
#  REPLY
# Arguments:
#  name: any string
#  mode: normal, right, left, inverted
rotate () {
  local name="$1"
  local mode="$2"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return 1
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 1
  elif ! is_connected "${output}"; then
    echo "Cannot rotate a disconnected output"
    return 1
  elif ! is_active "${output}"; then
    echo "Cannot rotate an inactive output"
    return 1
  fi

  if [[ -z "${mode}" ]]; then
    local modes=''
    modes+='{"key": "normal", "value": "Normal"},'
    modes+='{"key": "right", "value": "Right"},'
    modes+='{"key": "left", "value": "Left"},'
    modes+='{"key": "inverted", "value": "Inverted"}'
    modes="[${modes}]"

    pick_one "Select a rotation mode:" "${modes}" "horizontal" || return 1
    [[ -n "${REPLY}" ]] && mode="${REPLY}" || return
  fi
  
  if [[ ! "${mode}" =~ ^(normal|right|left|inverted)$ ]]; then
    echo "Invalid rotation value"
    return 1
  fi

  xrandr --output "${name}" --rotate "${mode}" &&
    echo "Output ${name} rotated to ${mode} mode" ||
    echo "Failed to rotate output ${name}"
}

# Mirrors the output with the given name to other outputs,
# having all mirrors run at a common resolution shared among
# the source output and the mirrors. All outputs will move to
# position equal to the position of the source output and
# inherit the rotation and reflection modes.
# Globals:
#  REPLY
# Arguments:
#  name: any string
mirror () {
  local name="$1"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return 1
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 1
  elif ! is_connected "${output}"; then
    echo "Cannot mirror a disconnected output"
    return 1
  elif ! is_active "${output}"; then
    echo "Cannot mirror an inactive output"
    return 1
  fi

  local outputs=''
  outputs="$(find_outputs "active")" || return 1

  local len=0
  len="$(count "${outputs}")" || return 1
  [[ ${len} -lt 2 ]] &&
    echo "No other outputs have found to mirror" &&
    return 1

  local mirrors=''
  pick_outputs "Select on which outputs to mirror:" "active" "1," "${name}" || return 1
  [[ -n "${REPLY}" ]] && mirrors="${REPLY}" || return

  # Find the common resolution modes among output and mirrors
  local names=''
  names="$(echo "${mirrors}" | jq -cer '.|join("|")')" || return 1
  names+="|${name}"

  local query=''
  query+="select(.device_name | match(\"(${names})\"))"
  query+=' |.associated_modes[]'
  query+=' |"\(.resolution_width)x\(.resolution_height)"'

  query="[.[]|${query}]"
  query+=' |[group_by(.)|map(select(length>1))|.[]|.[0]'
  query+=' |{key: "\(.)", value: "\(.)"}]'

  local modes=''
  modes="$(echo "${outputs}" | jq -cer "${query}")" || return 1

  if [[ "$(count "${modes}")" -eq 0 ]]; then
    echo "No common resolutions found among mirrors"
    return 1
  fi

  local mode=''
  pick_one "Select the mirroring resolution:" "${modes}" "vertical" || return 1
  [[ -n "${REPLY}" ]] && mode="${REPLY}" || return

  # Have mirrors inherit the position and rotate/reflect of the source output
  local pos="$(echo "${output}" | jq -r '"\(.offset_width)x\(.offset_height)"')"
  local rot="$(echo "${output}" | jq -r '.rotation')"
  local ref="$(echo "${output}" | jq -r '.reflection|ascii_downcase' |
    awk '{gsub(/( |and|axis)/,"",$0); print}')"

  query="[\"--output \(.[]) --mode ${mode} --pos ${pos} --rotate ${rot} --reflect ${ref}\"]"
  query+='|join(" ")'

  local others="$(echo "${mirrors}" | jq -cr "${query}")"

  xrandr --output "${name}" --mode "${mode}" ${others} &&
    echo "Output ${name} mirrored successfully" ||
    echo "Failed to mirror output ${name}"
}

# Sets the layout of currently active outputs.
# Globals:
#  REPLY
# Arguments:
#  None
set_layout () {
  local layout=''
  pick_layout || return 1
  [[ -n "$REPLY" ]] && layout="${REPLY}" || return

  local outputs=''
  pick_outputs "Pick outputs by order:" "active" "all" || return 1
  [[ -n "$REPLY" ]] && outputs="${REPLY}" || return

  local a="$(echo "${outputs}" | jq -cr '.[0]')"
  local b="$(echo "${outputs}" | jq -cr '.[1]')"
  local c="$(echo "${outputs}" | jq -cr '.[2]')"

  local args=''
  case "${layout}" in
    "row-2")
      args="--output ${a} --left-of ${b}";;
    "col-2")
      args="--output ${a} --above ${b}";;
    "row-3")
      args="--output ${a} --left-of ${b} --output ${b} --left-of ${c}";;
    "col-3")
      args="--output ${a} --above ${b} --output ${b} --above ${c}";;
    "gamma-3")
      args="--output ${a} --left-of ${b} --output ${c} --below ${a}";;
    "gamma-rev-3")
      args="--output ${a} --left-of ${b} --output ${c} --below ${b}";;
    "lambda-3")
      args="--output ${a} --above ${b} --output ${b} --left-of ${c}";;
    "lambda-rev-3")
      args="--output ${a} --left-of ${c} --output ${a} --above ${c}";;
    *)
      echo "Invalid layout mode"
      return 1;;
  esac

  xrandr ${args}

  if [[ $? -ne 0 ]]; then
    echo "Failed to set layout mode"
    return 1
  fi

  echo "Layout has been set successfully"
}

# Saves the current state of each output to a line of
# xrandr compatible options ready to be used in xrandr
# calls. The state of an output is considered the mode,
# rate, offset (position), rotate, reflect and primary.
# Globals:
#  REPLY, CONFIG_HOME, SETTINGS_FILE
# Arguments:
#  None
save_layout () {
  local outputs=''
  outputs="$(find_outputs "all")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find outputs"
    return 1
  fi

  confirm "Should overwrite existing layout?"
  [[ -z "${REPLY}" ]] && return
  [[ "${REPLY}" == "no" ]] && return

  # Parse each output state to a line of xrandr options
  local mode=''
  mode+='.associated_modes[]'
  mode+=' |"\(.resolution_width)x\(.resolution_height)" as $res'
  mode+=' |.frequencies[]|select(.is_current)'
  mode+=' |"--mode \($res) --rate \(.frequency)"'

  local pos='--pos \(.offset_width)x\(.offset_height)'
  local rotate='--rotate \(.rotation)'
  local reflect='--reflect \(.reflection|ascii_downcase|gsub("( |and|axis)";""))'
  local primary='if .is_primary then " --primary" else "" end'

  local query=''
  query+='if .resolution_width'
  query+=" then \"\(${mode}) ${pos} ${rotate} ${reflect}\(${primary})\""
  query+=' else "--off"'
  query+='end'

  query="map({(.device_name|tostring): \"\(${query})\"})|add"

  local layout=''
  layout="$(echo "${outputs}" | jq -cer "${query}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to parse modes to layout"
    return 1
  fi

  local settings='{}'
  if [[ -f "${SETTINGS_FILE}" ]]; then
    settings="$(jq -e ".|.layout = ${layout}" "${SETTINGS_FILE}")"
  else
    settings="$(echo "{\"layout\": ${layout}}" | jq -e '.')"
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to parse the layout settings"
    return 1
  fi

  mkdir -p "${CONFIG_HOME}"
  echo "${settings}" > "${SETTINGS_FILE}" &&
    echo "Layout has been saved successfully" ||
    echo "Failed to save the layout settings"
}

# Restores the displays layout by calling xrandr on every
# output, where its mode, rate, pos, rotate, reflect and
# primary settings have been saved in the settings file.
# Globals:
#  SETTINGS_FILE
# Arguments:
#  None
restore_layout () {
  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No layout settings have found"
    return
  fi

  # Collect all output xrandr options in a single line
  local query='"--output \(.key) \(.value)"'
  query="[.layout|to_entries[]|${query}]|join(\" \")"

  local args=''
  args="$(jq -cer "${query}" "${SETTINGS_FILE}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read layout settings"
    return
  fi

  xrandr ${args} && echo "Layout has been restored"

  if [[ $? -ne 0 ]]; then
    echo "Failed to restore the layout"
    return 1
  fi
}

# Sets the color profile of the output with the given name
# where profile should be the filename of any .icc or .icm
# color calibration files saved in the $COLORS_HOME.
# Globals:
#  REPLY, COLORS_HOME, DISPLAY, CONFIG_HOME, SETTINGS_FILE
# Arguments:
#  name:    any string
#  profile: filename of a color profile
set_color () {
  local name="$1"
  local profile="$2"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return 1
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return
  fi
  
  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 1
  elif ! is_connected "${output}"; then
    echo "Cannot set color of a disconnected output"
    return 1
  elif ! is_active "${output}"; then
    echo "Cannot set color of an inactive output"
    return 1
  fi

  if [[ -z "${profile}" ]]; then
    local query='[.[]|select(.filename|test(".ic(c|m)$"))'
    query+='|{key: .filename, value: .filename}]'
  
    local profiles=''
    profiles"$(ls "${COLORS_HOME}" 2>/dev/null | jc --ls |
      jq -cer "${query}")" || return 1
    
    local len=0
    len="$(count "${profiles}")" || return 1

    if [[ ${len} -eq 0 ]]; then
      echo "No color profiles have found"
      return 1
    fi

    pick_one "Select a color profile:" "${profiles}" "vertical" || return 1
    [[ -n "${REPLY}" ]] && profile="${REPLY}" || return
  fi

  local index=''
  index="$(find_index "${name}")" || return 1

  local result=''
  result="$(xcalib -d "${DISPLAY}" -s 0 -o "${index}" "${COLORS_HOME}/${profile}" 2>&1)"

  if [[ $? -ne 0 ]] || [[ -n "${result}" ]]; then
    echo "Failed to set color profile"
    return 1
  fi

  local setting="{\"index\": \"${index}\", \"profile\": \"${profile}\"}"

  local settings='{}'
  if [[ -f "${SETTINGS_FILE}" ]]; then
    settings="$(jq -e ".colors.\"${name}\" = ${setting}" "${SETTINGS_FILE}")"
  else
    settings="$(echo "{\"colors\": {\"${name}\": ${setting}}}" | jq -e '.')"
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to parse the colors settings"
    return 1
  fi

  mkdir -p "${CONFIG_HOME}"
  echo "${settings}" > "${SETTINGS_FILE}" &&
    echo "Color of ${name} set to ${profile}" ||
    echo "Failed to persist color profile"
}

# Removes any color profile applied to the output with
# the given name.
# Globals:
#  REPLY, DISPLAY, SETTINGS_FILE
# Arguments:
#  name: any string
reset_color () {
  local name="$1"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return 1
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return
  fi
  
  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 1
  elif ! is_connected "${output}"; then
    echo "Cannot reset color profile of a disconnected output"
    return 1
  elif ! is_active "${output}"; then
    echo "Cannot reset color profile of an inactive output"
    return 1
  fi

  local index=''
  index="$(find_index "${name}")" || return 1

  local result=''
  result="$(xcalib -d "${DISPLAY}" -s 0 -o "${index}" -c 2>&1)"

  if [[ $? -ne 0 ]] || [[ -n "${result}" ]]; then
    echo "Failed to reset color profile"
    return 1
  fi

  echo "Color profile of ${name} reset to default"

  # Remove color setting if such setting has been set
  if [[ -f "${SETTINGS_FILE}" ]]; then
    local key=".colors.\"${name}\""
    local query="if ${key} != null then del(${key}) else . end"

    local settings=''
    settings="$(jq -e "${query}" "${SETTINGS_FILE}")"
    echo "${settings}" > "${SETTINGS_FILE}"
  fi
}

# Restores the displays color profiles by calling multiple
# xcalib commands on every output its name has been set in
# the colors settings.
# Globals:
#  COLORS_HOME, SETTINGS_FILE, DISPLAY
# Arguments:
#  None
restore_colors () {
  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No color settings have found"
    return
  fi

  # Collect all output colors in index,profile tuples
  local query="\(.value.index),${COLORS_HOME}/\(.value.profile)"
  query="[.colors|to_entries[]|\"${query}\"]|join(\"\n\")"

  local tuples=''
  tuples="$(jq -cer "${query}" "${SETTINGS_FILE}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read color settings"
    return
  elif [[ -z "${tuples}" ]]; then
    echo "No color settings have been found"
    return
  fi

  local failed='false'
  local tuple=''
  while read -r tuple; do  
    local index="$(echo "${tuple}" | cut -d ',' -f 1)"
    local profile="$(echo "${tuple}" | cut -d ',' -f 2)"

    local result="$(xcalib -d "${DISPLAY}" -s 0 -o "${index}" "${profile}" 2>&1)"

    if [[ $? -ne 0 ]] || [[ -n "${result}" ]]; then
      echo "Failed to restore profile ${profile} for output ${index}"
      failed='true'
    fi
  done <<< "${tuples}"

  if [[ "${failed}" == "true" ]]; then
    echo "Color profiles have been restored partially"
    return 1
  fi

  echo "Color profiles have been restored"
}

# Show the help message.
# Globals:
#  COLORS_HOME
# Arguments:
#  None
# Outputs:
#  A long help message.
help () {
  if [[ "$1" == "once" ]]; then
    echo "Usage: displays COMMAND [OBJECT] [ARGUMENTS]..."

    echo -e "\nCOMMANDS"
    printf " %-16s %s\n" \
      "help" "Show this help message." \
      "" "" \
      "restore layout" "Restore the layout." \
      "restore colors" "Restore color profiles."

    return
  fi

  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf " %-44s %s\n" \
    "help" "Show this help message." \
    "" "" \
    "show status" "Show a report of the Xorg server and active outputs." \
    "show logs" "Show the logs of the Xorg server." \
    "show output [<name>]" "Show the data of the given output." \
    "" "" \
    "list outputs [<status>]" "List all outputs or by the given status," \
    "" "all, connected, disconnected, active, inactive or primary." \
    "" "" \
    "set mode [<output> [<resolution> [<rate>]]]" "Set the mode of the given output." \
    "set primary [<output>]" "Set the given output as primary." \
    "set on|off [<output>]" "Set active or inactive the given output." \
    "" "" \
    "rotate [<output> [<mode>]]" "Set output rotation to normal, right, left or inverted." \
    "reflect [<output> [<mode>]]" "Set output reflection to normal, x, y or xy axes." \
    "mirror [<output>]" "Mirror the given active output to other outputs." \
    "" "" \
    "set color [<output> [<profile>]]" "Set the color profile of the given output, where profile" \
    "" "should be the filename of any .icc or .icm calibration" \
    "" "files stored under ${COLORS_HOME}." \
    "reset color [<output>]" "Reset the color profile of the given output." \
    "restore colors" "Restore the color profiles saved in settings." \
    "" "" \
    "set layout" "Set the layout of active outputs." \
    "save layout" "Persist the current layout." \
    "restore layout" "Restore the layout saved in settings."
}

loop () {
  clear

  while true; do
    prompt && history -s "${REPLY}"

    set -f
    set_separator "line"
    local cmd=($(xargs -n1 <<< "${REPLY}"))
    restore_separator && set +f

    if [[ "${cmd[0]}" == "help" ]]; then
      help
      continue
    elif [[ "${cmd[0]}" == "clear" ]]; then
      clear
      continue
    elif [[ "${cmd[0]}" == "quit" ]]; then
      break
    elif [[ -z "${cmd[0]}" ]]; then
      continue
    fi

    case "${cmd[0]}" in
      "show")
        case "${cmd[1]}" in
          "status") show_status;;
          "logs") show_logs;;
          "output") show_output "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "list")
        case "${cmd[1]}" in
          "outputs") list_outputs "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "set")
        case "${cmd[1]}" in
          "layout") set_layout;;
          "mode") set_mode "${cmd[2]}" "${cmd[3]}" "${cmd[4]}";;
          "primary") set_primary "${cmd[2]}";;
          "on") set_on "${cmd[2]}";;
          "off") set_off "${cmd[2]}";;
          "color") set_color "${cmd[2]}" "${cmd[3]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "reset")
        case "${cmd[1]}" in
          "color") reset_color "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "save")
        case "${cmd[1]}" in
          "layout") save_layout;;
          *) echo "Invalid or unknown command";;
        esac;;
      "restore")
        case "${cmd[1]}" in
          "layout") restore_layout;;
          "colors") restore_colors;;
          *) echo "Invalid or unknown command";;
        esac;;
      "rotate") rotate "${cmd[1]}" "${cmd[2]}";;
      "reflect") reflect "${cmd[1]}" "${cmd[2]}";;
      "mirror") mirror "${cmd[1]}";;
      *) echo "Invalid or unknown command";;
    esac
  done

  clear
}

once () {
  case "$1" in
    "help") help "once";;
    "restore")
      case "$2" in
        "layout") restore_layout || abort;;
        "colors") restore_colors || abort;;
        *) abort "Invalid or unknown command";;
      esac;;
    *) abort "Invalid or unknown command";;
  esac
}

if [[ $# -eq 0 ]]; then
  loop
else
  once "$@"
fi