#!/usr/bin/env bash

set -o pipefail
source /opt/stack/utils

LAYOUT_FILE=$CONFIG_HOME/displays.layout

require "xorg-xrandr"

screen () {
  xrandr --current | sed "/^Screen 0:/,/^Screen/!d;//d"
}

outputs () {
  local STATUS=$1

  local RE='^[A-Z]+-[0-9]+'
  if [[ "$STATUS" =~ ^(dis)?connected$ ]]; then
    RE+="\s$STATUS"
  elif [ "$STATUS" = "active" ]; then
    RE+='\sconnected.*\s([0-9]+x[0-9]+)\+.*'
  elif [ "$STATUS" = "inactive" ]; then
    RE+='\sconnected\s\(.*'
  elif [ "$STATUS" = "primary" ]; then
    RE+='\s.*\sprimary\s.*'
  fi

  local OUTPUTS=$(screen | awk '{ORS="'$AES'";} /'${RE}'/{print $1}')

  if [[ "$OUTPUTS" =~ .*${AES}$ ]]; then
    echo "${OUTPUTS::-${#AES}}"
  else
    echo "$OUTPUTS"
  fi
}

output () {
  local NAME=$1

  local CRITERION="^$NAME\s.*"

  if [ "$NAME" = "primary" ]; then
    CRITERION='.*\sprimary\s.*'
  fi

  local SCREEN="$(screen)"

  local HEAD=$(echo "$SCREEN" | awk '/'$CRITERION'/')
  
  if [ -z "$HEAD" ]; then
    return 1
  fi

  local RE='^(.*)\s(connected|disconnected)\s?(primary)?\s?'
  RE+='([0-9]+x[0-9]+)?(\+[0-9]+\+[0-9]+)?\s?'
  RE+='(normal|right|left|inverted)?\s?(X\saxis|Y\saxis|X\sand\sY\saxis)?\s.*'

  local STATE="$(echo "$HEAD" | awk 'match($0,/'$RE'/,a) {
    a[5]=gensub(/\+(.*)\+(.*)/,"\\1x\\2","g",a[5]);
    a[7]=tolower(a[7]); gsub(/( |and|axis)/,"",a[7]);
    print a[1]"'$AES'"a[2]"'$AES'"a[3]"'$AES'"a[4]"'$AES'"a[5]"'$AES'"a[6]"'$AES'"a[7]}')"

  RE='^\s+([0-9]+x[0-9]+)\s.*\s([0-9]{2}.[0-9]{2})\*.*'

  local MODE="$(echo "$SCREEN" | sed -n "/$CRITERION/{:a;N;/\*/!ba;/\*/p}" |
    awk 'match($0,/'$RE'/,a) {print a[1]"'$AES'"a[2]}')"

  [ -n "$MODE" ] && STATE+="$AES$MODE" || STATE+="$AES$AES"

  RE='^\s+([0-9]+x[0-9]+)\s.*\s([0-9]{2}.[0-9]{2})\*?\s?\+.*'

  local NATIVE="$(echo "$SCREEN" | sed -n "/$CRITERION/{:a;N;/\+/!ba;/\+/p}" |
    awk 'match($0,/'$RE'/,a) {print a[1]"@"a[2]"Hz"}')"
  
  [ -n "$NATIVE" ] && STATE+="$AES$NATIVE" || STATE+="$AES"

  local PROFILES="$(echo "$SCREEN" | awk '/'$CRITERION'/,!//' | tail -n +2 |
    sed -E 's/(\*|\+)//g' |
    awk -v AES="$AES" -v KVS="$KVS" '{
      if ($0 ~ /^\s+[0-9]+x[0-9]+/) {
        rates=""
        for (i=2; i<=NF; i++) {
          rates=rates $i
          if (i<NF) rates=rates AES
        }
        print $1 KVS rates
      } else exit
    }')"
  
  echo -e "$STATE\n$PROFILES"
}

is_connected () {
  local OUTPUT=$1

  echo "$OUTPUT" | head -n 1 |
    awk '/'$AES'connected'$AES'/ {c=0;next} {c=1} END {exit c}'
}

is_active () {
  local OUTPUT=$1

  echo "$OUTPUT" | head -n 1 |
    awk '/'$AES'connected'$AES'.*'$AES'[0-9]+x[0-9]+'$AES'/ {c=0;next} {c=1} END {exit c}'
}

is_primary () {
  local OUTPUT=$1

  echo "$OUTPUT" | head -n 1 |
    awk '/'$AES'primary'$AES'/ {c=0;next} {c=1} END {exit c}'
}

pick_output () {
  local STATUS=$1

  local OUTPUTS=$(outputs "$STATUS")
  local LEN=$(count "$OUTPUTS")

  if [ ! $LEN -gt 0 ]; then
    echo "No ${STATUS:-\b} outputs have been found"
    return 1
  fi

  local MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"
  
  pick_one "Select an output:" "$OUTPUTS" "$MODE"
}

pick_resolution () {
  local OUTPUT=$1

  local RESOLUTIONS="$(echo "$OUTPUT" |
    awk -F$KVS '{ORS="'$AES'";} {if ($0 ~ /^[0-9]+x[0-9]+/) {print $1}}')"

  if [[ "$RESOLUTIONS" =~ .*${AES}$ ]]; then
    RESOLUTIONS="${RESOLUTIONS::-${#AES}}"
  fi

  local LEN=$(count "$RESOLUTIONS")

  if [ ! $LEN -gt 0 ]; then
    echo "No available resolutions have been found"
    return 1
  fi

  local MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"
  
  pick_one "Select a resolution:" "$RESOLUTIONS" "$MODE"
}

pick_rate () {
  local OUTPUT=$1
  local RESOLUTION=$2

  local RATES="$(echo "$OUTPUT" |
    awk -F$KVS '{if ($0 ~ /^'$RESOLUTION'/) {print $2; exit}}')"

  local LEN=$(count "$RATES")

  if [ ! $LEN -gt 0 ]; then
    echo "No available rates have been found"
    return 1
  fi

  local MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"
  
  pick_one "Select a rate:" "$RATES" "$MODE"
}

prompt () {
  local OUTPUTS="$(outputs primary)"
  local STATUS="$(element "$OUTPUTS" 0)"

  read -rep "[displays:$YE${STATUS}$RS] " REPLY
}

show_status () {
  if [ -z "$DISPLAY" ]; then
    echo "Unable to resolve the display of xorg server"
    return 1
  fi

  local PATTERN='/^('
  PATTERN+='name\sof\sdisplay|'
  PATTERN+='version\snumber|'
  PATTERN+='vendor\sstring|'
  PATTERN+='vendor\srelease\snumber|'
  PATTERN+='X.Org\sversion|'
  PATTERN+='motion\sbuffer\ssize|'
  PATTERN+='image\sbyte\sorder|'
  PATTERN+='default\sscreen\snumber|'
  PATTERN+='number\sof\sscreens'
  PATTERN+=')/'

  xdpyinfo -display "$DISPLAY" |
    awk -F': ' $PATTERN'{ \
      gsub(/[ \t]+$/, "", $1); \
      gsub(/^[ \t]+/, "", $2); \
      printf "%-23s %s\n",$1":",$2 \
    }' | sed -r 's/\<./\U&/g'

  local OUTPUTS=$(outputs active)
  local LEN=$(count "$OUTPUTS")

  if [ $LEN = 0 ]; then
    echo "Connected Outputs:      none"
    return
  fi

  echo "$OUTPUTS" | awk -F$AES '{
    out=$1; for(i=2;i<=NF;i++) out=out ","$i;
    print "Connected Outputs:      "out
  }'

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    echo

    local NAME="$(element "$OUTPUTS" "$INDEX" | value)"
    local OUTPUT="$(output "$NAME")"

    local FRM=""
    FRM+="Output: %s\n"
    FRM+="Mode:   %s@%sHz\n"
    FRM+="Area:   %s\n"
    FRM+="Pos:    %s\n"
    FRM+="RoRe:   %s %s\n"

    echo "$OUTPUT" | head -n 1 | awk -F$AES -v FRM="$FRM" '{
      if ($3) {$1=$1"*"};
      if (!$6) $6="normal";
      if (!$7) $7="normal";
      printf FRM,$1,$8,$9,$4,$5,$6,$7
    }'
  done
}

show_output () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi

  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find the $NAME output"
    return 1
  fi

  if ! is_connected "$OUTPUT"; then
    local FRM=""
    FRM+="Name:       %s\n"
    FRM+="Status:     %s\n"

    echo "$OUTPUT" | head -n 1 | awk -F$AES -v FRM="$FRM" '{printf FRM,$1,$2}'
    return
  fi

  if ! is_active "$OUTPUT"; then
    local FRM=""
    FRM+="Name:       %s\n"
    FRM+="Status:     %s\n"
    FRM+="Native:     %s\n"

    echo "$OUTPUT" | head -n 1 | awk -F$AES -v FRM="$FRM" '{printf FRM,$1,$2,$10}'
  else
    local FRM=""
    FRM+="Name:       %s\n"
    FRM+="Status:     %s\n"
    FRM+="Primary:    %s\n"
    FRM+="Resolution: %s\n"
    FRM+="Rate:       %sHz\n"
    FRM+="Rotate:     %s\n"
    FRM+="Reflect:    %s\n"
    FRM+="Area:       %s\n"
    FRM+="Position:   %s\n"
    FRM+="Native:     %s\n"

    echo "$OUTPUT" | head -n 1 | awk -F$AES -v FRM="$FRM" '{
      if ($3) {$3="true"} else {$3="false"};
      if (!$6) $6="normal";
      if (!$7) $7="normal";
      printf FRM,$1,$2,$3,$8,$9,$6,$7,$4,$5,$10
    }'
  fi

  echo "$OUTPUT" | tail -n +2 | head -n 1 |
    awk -F$KVS '{gsub(/'$AES'/," ",$2); printf "Profiles:   %-9s %s\n",$1,$2}'
  echo "$OUTPUT" | tail -n +3 |
    awk -F$KVS '{gsub(/'$AES'/," ",$2); printf "            %-9s %s\n",$1,$2}'
}

list_outputs () {
  local STATUS=$1

  local OUTPUTS=$(outputs "$STATUS")
  local LEN=$(count "$OUTPUTS")

  if [ ! $LEN -gt 0 ]; then
    echo "No ${STATUS:-\b} outputs have been found"
    return
  fi

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    [ $INDEX -gt 0 ] && echo

    local NAME=$(element "$OUTPUTS" "$INDEX" | value)
    show_output "$NAME"
  done
}

set_mode () {
  local NAME=$1
  local RESOLUTION=$2
  local RATE=$3

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi

  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find the $NAME output"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot set mode of a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot set mode of an inactive"
    return 1
  fi

  if [ -z "$RESOLUTION" ]; then
    pick_resolution "$OUTPUT" || return 1
    [ -z "$REPLY" ] && return
    
    RESOLUTION=$(value "$REPLY")
  fi

  if [ -z "$RATE" ]; then
    pick_rate "$OUTPUT" "$RESOLUTION" || return 1
    [ -z "$REPLY" ] && return
    
    RATE=$(value "$REPLY")
  fi

  xrandr --output "$NAME" --mode "$RESOLUTION" --rate "$RATE" &&
    echo "Output $NAME mode set to $RESOLUTION@${RATE}Hz" ||
    echo "Unable to set mode of the $NAME output"
}

set_primary () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find the $NAME output"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot set primary a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot set primary an inactive output"
    return 1
  elif is_primary "$OUTPUT"; then
    echo "Output $NAME is already the primary"
    return 1
  fi

  xrandr --output "$NAME" --primary &&
    echo "Output $NAME has been set as primary" ||
    echo "Unable to set the $NAME output as primary"
}

set_on () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output inactive || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find the $NAME output"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot activate a disconnected output"
    return 1
  elif is_active "$OUTPUT"; then
    echo "Output $NAME is already active"
    return 1
  fi

  xrandr --output "$NAME" --auto &&
    echo "Output $NAME has been activated" ||
    echo "Unable to activate the $NAME output"
}

set_off () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find the $NAME output"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot deactivate a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Output $NAME is already inactive"
    return 1
  elif is_primary "$OUTPUT"; then
    echo "Cannot deactivate the primary output"
    return 1
  fi

  xrandr --output "$NAME" --off &&
    echo "Output $NAME has been deactivated" ||
    echo "Unable to deactivate the $NAME output"
}

reflect () {
  local NAME=$1
  local MODE=$2

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find the $NAME output"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot reflect a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot reflect an inactive output"
    return 1
  fi

  if [ -z "$MODE" ]; then
    local MODES=""
    MODES+="Normal${KVS}normal${AES}"
    MODES+="X Axis${KVS}x${AES}"
    MODES+="Y Axis${KVS}y${AES}"
    MODES+="XY Axes${KVS}xy"

    pick_one "Select a reflection mode:" "$MODES" "vertical-4"
    [ -z "$REPLY" ] && return
    
    MODE=$(value "$REPLY")
  fi
  
  if [[ ! "$MODE" =~ ^(normal|x|y|xy)$ ]]; then
    echo "Unable to reflect, invalid reflection mode"
    return 1
  fi

  xrandr --output "$NAME" --reflect "$MODE" &&
    echo "Output $NAME has been reflected to $MODE mode" ||
    echo "Unable to reflect the $NAME output"
}

rotate () {
  local NAME=$1
  local MODE=$2

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find the $NAME output"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot reflect a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot reflect an inactive output"
    return 1
  fi

  if [ -z "$MODE" ]; then
    local MODES=""
    MODES+="Normal${KVS}normal${AES}"
    MODES+="Right 90°${KVS}right${AES}"
    MODES+="Left 90°${KVS}left${AES}"
    MODES+="Inverted 180°${KVS}inverted"

    pick_one "Select a rotation mode:" "$MODES" "vertical-6"
    [ -z "$REPLY" ] && return
    
    MODE=$(value "$REPLY")
  fi
  
  if [[ ! "$MODE" =~ ^(normal|right|left|inverted)$ ]]; then
    echo "Unable to rotate, invalid rotation mode"
    return 1
  fi

  xrandr --output "$NAME" --rotate "$MODE" &&
    echo "Output $NAME has been rotated to $MODE mode" ||
    echo "Unable to rotate the $NAME output"
}

pick_layout () {
  local OUTPUTS=$1

  local LAYOUTS=""

  if [ $OUTPUTS = 2 ]; then
    LAYOUTS+="Side by Side${KVS}row-2${AES}"
    LAYOUTS+="Top Bottom${KVS}col-2"

    echo
    echo "Side by Side  Top Bottom"
    echo "------------  ----------"
    echo "[A][B]        [A]"
    echo "              [B]"
    echo
  elif [ $OUTPUTS = 3 ]; then
    LAYOUTS+="Side by Side${KVS}row-3${AES}"
    LAYOUTS+="Top Bottom${KVS}col-3${AES}"
    LAYOUTS+="Left Gamma${KVS}gamma-3${AES}"
    LAYOUTS+="Right Gamma${KVS}gamma-rev-3${AES}"
    LAYOUTS+="Left Lambda${KVS}lambda-3${AES}"
    LAYOUTS+="Right Lambda${KVS}lambda-rev-3"

    echo
    echo "Side by Side  Top Bottom   Left Gamma"
    echo "------------  ----------   ----------"
    echo "[A][B][C]     [A]          [A][B]"
    echo "              [B]          [C]"
    echo "              [C]"
    echo
    echo "Right Gamma   Left Lambda  Right Lambda"
    echo "------------  -----------  ------------"
    echo "[A][B]        [A]             [A]"
    echo "   [C]        [B][C]       [B][C]"
    echo
  else
    return 1
  fi

  local MODE="vertical-6"
  [ $(count "$LAYOUTS") -lt 3 ] && MODE="horizontal"

  pick_one "Select a layout mode:" "$LAYOUTS" "$MODE"
}

set_layout () {
  local OUTPUTS=$(outputs active)
  local LEN=$(count "$OUTPUTS")

  if [ $LEN = 0 ]; then
    echo "No active outputs have been found"
    return
  elif [ $LEN = 1 ]; then
    echo "No layout options found for setups with one active output"
    return
  elif [ $LEN -gt 3 ]; then
    echo "No layout options found for setups with more than 3 active outputs"
    return
  fi

  pick_layout "$LEN" || return 1
  [ -z "$REPLY" ] && return

  local LAYOUT=$(value "$REPLY")

  MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"

  local SPOTS=$(echo "$LEN" | awk '{for(i=65; i<65+$0; i++) printf "%c,",i}')

  pick_by_order "Pick outputs by order to match ${SPOTS::-1}:" "$OUTPUTS" "$LEN" "$MODE"
  [ -z "$REPLY" ] && return

  local A=$(element "$REPLY" 0 | value)
  local B=$(element "$REPLY" 1 | value)
  if [ $LEN = 3 ]; then
    local C=$(element "$REPLY" 2 | value)
  fi

  case "$LAYOUT" in
    "row-2")
      xrandr --output "$A" --left-of "$B";;
    "col-2")
      xrandr --output "$A" --above "$B";;
    "row-3")
      xrandr --output "$A" --left-of "$B" --output "$B" --left-of "$C";;
    "col-3")
      xrandr --output "$A" --above "$B" --output "$B" --above "$C";;
    "gamma-3")
      xrandr --output "$A" --left-of "$B" --output "$C" --below "$A";;
    "gamma-rev-3")
      xrandr --output "$A" --left-of "$B" --output "$C" --below "$B";;
    "lambda-3")
      xrandr --output "$A" --above "$B" --output "$B" --left-of "$C";;
    "lambda-rev-3")
      xrandr --output "$A" --left-of "$C" --output "$A" --above "$C";;
  esac

  if [ ! $? = 0 ]; then
    echo "Unable to set layout, unknown error occurred"
    return 1
  fi

  echo "Layout has been set successfully"
}

save_layout () {
  local OUTPUTS=$(outputs)
  local LEN=$(count "$OUTPUTS")
  
  if [ $LEN = 0 ]; then
    echo "Unable to save layout, no outputs have found"
    return 1
  fi

  echo "CAUTION, this operation will overwrite any"
  echo "existing layout configuration set before."
  confirm "Do you want to proceed?"
  
  if [ -z "$REPLY" ] || [ "$(value "$REPLY")" = "no" ]; then
    return
  fi

  mkdir -p $CONFIG_HOME
  rm -f "$LAYOUT_FILE"

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    local NAME=$(element "$OUTPUTS" "$INDEX" | value)
    local OUTPUT=$(output "$NAME")

    echo "$OUTPUT" | head -n 1 >> "$LAYOUT_FILE"
  done

  echo "Layout saved successfully"
}

load_layout () {
  if [ ! -f "$LAYOUT_FILE" ]; then
    echo "No layout file found, load is skipped"
    return
  fi

  local ARGS=$(awk -F$AES '{
    if ($8) {
      if (!$6) $6="normal";
      if (!$7) $7="normal";
      args="--output "$1" --mode "$8" --rate "$9" --pos "$5" --rotate "$6" --reflect "$7
      if ($3 == "primary") args=args" --primary"
      print args
    } else {
      print "--output "$1" --off"
    }
  }' "$LAYOUT_FILE" | tr $'\n' ' ')

  xrandr $ARGS && echo "Display layout loaded successfully"

  if [ ! $? = 0 ]; then
    echo "Unable to load the display layout"
    return 1
  fi
}

help () {
  if [ "$1" = "once" ]; then
    echo "Usage: displays COMMAND"

    echo -e "\nCOMMANDS"
    printf " %-12s\t%s\n" \
      "help" "Show this message" \
      "load layout" "Load display layout"

    return
  fi

  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf " %-32s\t%s\n" \
    "help" "Show this help message." \
    "show status" "Show a report of the xorg server and active outputs." \
    "show output [<name>]" "Show the data of the given output." \
    "" "" \
    "list outputs [<status>]" "List all outputs or by the given status," \
    "" "connected, disconnected, active, inactive or primary." \
    "" "" \
    "set mode [<name> [<res> [<rate>]]]" "Set the mode of the given output." \
    "set primary [<name>]" "Set the given output as primary." \
    "set on|off [<name>]" "Set active or inactive the given output." \
    "set layout" "Set the layout of active outputs." \
    "" "" \
    "rotate [<name> [<mode>]]" "Set output rotation to normal, right, left or inverted." \
    "reflect [<name> [<mode>]]" "Set output reflection to normal, x, y or xy axes." \
    "" "" \
    "save layout" "Persist the current display layout for next boots."
}

loop () {
  clear

  while true; do
    prompt && history -s "$REPLY"

    set -f
    set_separator "line"
    local CMD=($(xargs -n1 <<< "$REPLY"))
    restore_separator && set +f

    if [ "${CMD[0]}" = "help" ]; then
      help
      continue
    elif [ "${CMD[0]}" = "clear" ]; then
      clear
      continue
    elif [ "${CMD[0]}" = "quit" ]; then
      break
    elif [ -z "${CMD[0]}" ]; then
      continue
    fi

    case "${CMD[0]}" in
      "show")
        case "${CMD[1]}" in
          "status") show_status;;
          "output") show_output "${CMD[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "list")
        case "${CMD[1]}" in
          "outputs") list_outputs "${CMD[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "set")
        case "${CMD[1]}" in
          "layout") set_layout;;
          "mode") set_mode "${CMD[2]}" "${CMD[3]}" "${CMD[4]}";;
          "primary") set_primary "${CMD[2]}";;
          "on") set_on "${CMD[2]}";;
          "off") set_off "${CMD[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "save")
        case "${CMD[1]}" in
          "layout") save_layout;;
          *) echo "Invalid or unknown command";;
        esac;;
      "rotate") rotate "${CMD[1]}" "${CMD[2]}";;
      "reflect") reflect "${CMD[1]}" "${CMD[2]}";;
      *) echo "Invalid or unknown command";;
    esac
  done

  clear
}

once () {
  case "$1" in
    "help") help once;;
    "load")
      case "$2" in
        "layout") load_layout || abort;;
        *) abort "Invalid or unknown command";;
      esac;;
    *) abort "Invalid or unknown command";;
  esac
}

if [ $# = 0 ]; then
  loop
else
  once "$@"
fi
