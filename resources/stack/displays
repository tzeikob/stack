#!/bin/bash

set -o pipefail
source /opt/stack/utils

SETTINGS_FILE="${CONFIG_HOME}/displays.json"

# Returns a list of outputs having the given status.
# Arguments:
#  status: all, connected, disconnected, active,
#          inactive, primary
# Outputs:
#  A json array of outputs.
find_outputs () {
  local status="${1:-"all"}"

  local states='all|connected|disconnected|active|inactive|primary'
  if [[ ! "${status}" =~ ^(${states})$ ]]; then
    return 1
  fi

  local criteria='true'
  if [[ "${status}" == "connected" ]]; then
    criteria='.is_connected == true'
  elif [[ "${status}" == "disconnected" ]]; then
    criteria='.is_connected == false'
  elif [[ "${status}" == "active" ]]; then
    criteria='.is_connected == true and .resolution_width != null'
  elif [[ "${status}" == "inactive" ]]; then
    criteria='.is_connected == true and .resolution_width == null'
  elif [[ "${status}" == "primary" ]]; then
    criteria='.is_primary == true'
  fi

  local a=''
  a+='.screens[]|select(.screen_number==0)'
  a+=" |.associated_device|select(${criteria})"
  a="[${a}]"

  local b=''
  b+=".unassociated_devices[]|select(${criteria})"
  b="[${b}]"

  local query="[${a}+${b}|to_entries[]|{index: .key} + .value]"

  xrandr --props | jc --xrandr | jq -cer "${query}" || return 1
}

# Returns the output with the given name.
# Arguments:
#  name: any string
# Outputs:
#  A json object of output.
find_output () {
  local name="${1}"

  local query=".[]|select(.device_name == \"${name}\")"

  find_outputs "all" | jq -cer "${query}" || return 1
}

# Returns a unique hashed signature of the list of the given
# outputs along with their connected devices if any. The signature
# is expected to be consistent assuming that xrandr works
# deterministically returning the outputs always in the exact
# same order.
# Arguments:
#  outputs: a json array of outputs
# Outputs:
#  A hashed signature value.
get_sig () {
  local outputs="${1}"

  local model=''
  model+='if .model_name and .is_connected and .resolution_width'
  model+=' then "_\(.model_name)_\(.product_id)_\(.serial_number)"'
  model+=' else ""'
  model+='end'

  local query=''
  query+="\"\(.device_name)\(${model})\""
  query="[.[]|${query}]|join(\",\")"

  local sig=''
  sig="$(echo "${outputs}" | jq -cer "${query}")" || return 1

  get_hash "${sig}" "6" || return 1
}

# Asserts if the given output is connected.
# Arguments:
#  output: a json object output
# Returns:
#  0 if is connected otherwise 1.
is_connected () {
  local output="${1}"

  local query='select(.is_connected)'

  echo "${output}" | jq -cer "${query}" &> /dev/null || return 1
}

# Asserts if the given output is active.
# Arguments:
#  output: a json object output
# Returns:
#  0 if is active otherwise 1.
is_active () {
  local output="${1}"

  local query='select(.is_connected and .resolution_width)'

  echo "${output}" | jq -cer "${query}" &> /dev/null || return 1
}

# Asserts if the given output is primary.
# Arguments:
#  output: a json object output
# Returns:
#  0 if is primary otherwise 1.
is_primary () {
  local output="${1}"

  local query='select(.is_primary)'

  echo "${output}" | jq -cer "${query}" &> /dev/null || return 1
}

# Asserts if an output supports the given resolution.
# Arguments:
#  output:     a json object of output
#  resolution: an output resolution
# Returns:
#  0 if output supports the resolution otherwise 1.
has_resolution () {
  local output="${1}"
  local resolution="${2}"

  local query=''
  query+='.associated_modes[]'
  query+=' |"\(.resolution_width)x\(.resolution_height)\(if .is_high_resolution then "i" else "" end)" as $res'
  query+=" |select(\$res == \"${resolution}\")"

  echo "${output}" | jq -cer "${query}" &> /dev/null || return 1
}

# Asserts if an output at a resolution supports
# the given refresh rate.
# Arguments:
#  output:     a json object of output
#  resolution: an output resolution
#  rate:       a refresh rate
# Returns:
#  0 if output supports the refresh rate otherwise 1.
has_rate () {
  local output="${1}"
  local resolution="${2}"
  local rate="${3}"

  local query=''
  query+='.associated_modes[]'
  query+=' |"\(.resolution_width)x\(.resolution_height)\(if .is_high_resolution then "i" else "" end)" as $res'
  query+=" |select(\$res == \"${resolution}\")"
  query+=" |.frequencies[]|select(.frequency == ${rate})"

  echo "${output}" | jq -cer "${query}" &> /dev/null || return 1
}

# Shows a menu asking the user to select one output, where the
# answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  prompt: a prompt text line
#  status: all, connected, disconnected, active,
#          inactive, primary
# Outputs:
#  A menu of output names.
pick_output () {
  local prompt="${1}"
  local status="${2}"

  # Convert outputs list into an array of {key, value} options
  local key='\(.device_name)'
  local value='\(.device_name):[\(if .model_name then .model_name else "NA" end)]'

  local query="[.[]|{key: \"${key}\", value: \"${value}\"}]"

  local options=''
  options="$(find_outputs "${status}" | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${options}")" || return 1
  
  if [[ ${len} -eq 0 ]]; then
    echo "No ${status:-\b} outputs have found"
    return 2
  fi

  pick_one "${prompt}" "${options}" "vertical" || return $?
}

# Shows a menu asking the user to select many outputs,
# where the answer is kept in the global var REPLY as
# a JSON array of output names in selection order.
# Globals:
#  REPLY
# Arguments:
#  prompt:  a prompt text line
#  status:  all, connected, disconnected, active,
#           inactive, primary
#  size:    the number of items must be selected
#  skip:    the name of output to except from selection
# Outputs:
#  A menu of output names.
pick_outputs () {
  local prompt="${1}"
  local status="${2}"
  local size="${3}"
  local skip="${4}"

  local except='select(true)'
  [[ -n "${skip}" ]] && except="select(.device_name != \"${skip}\")"

  # Convert outputs list into an array of {key, value} options
  local key='\(.device_name)'
  local value='\(.device_name) [\(if .model_name then .model_name else "NA" end)]'

  local query="{key: \"${key}\", value: \"${value}\"}"
  query="[.[]|${except}|${query}]"

  local options=''
  options="$(find_outputs "${status}" | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${options}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No ${status:-\b} outputs have found"
    return 2
  fi

  pick_many "${prompt}" "${options}" "${size}" "vertical" || return $?
}

# Shows a menu of resolutions of the given output and waits
# the user to pick one option. The selected option is kept
# in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  output: a json object of output
# Outputs:
#  A menu of resolutions.
pick_resolution () {
  local output="${1}"

  # Convert resolutions list into an array of {key, value} options
  local query=''
  query+='.associated_modes[]'
  query+=' |"\(.resolution_width)x\(.resolution_height)\(if .is_high_resolution then "i" else "" end)" as $res'
  query+=' |(reduce .frequencies[] as $i (""; if $i.is_preferred then . + "*" else . end)) as $pref'
  query+=' |{key: "\($res)", value: "\($res)\($pref)"}'
  query="[${query}]"

  local options=''
  options="$(echo "${output}" | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${options}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No resolutions have found"
    return 2
  fi

  pick_one "Select a resolution:" "${options}" "vertical" || return $?
}

# Shows a menu of resolution rates of the given output and
# waits the user to pick one option. The selected option is
# kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  output: a json object of output
# Outputs:
#  A menu of resolution rates.
pick_rate () {
  local output="${1}"
  local resolution="${2}"

  # Convert rates list into an array of {key, value} options
  local query=''
  query+='.associated_modes[]'
  query+=' |"\(.resolution_width)x\(.resolution_height)\(if .is_high_resolution then "i" else "" end)" as $res'
  query+=" |select(\$res == \"${resolution}\")"
  query+=' |.frequencies[]'
  query+=' |"\(.frequency)" as $freq'
  query+=' |"\(if .is_preferred then "*" else "" end)" as $pref'
  query+=' |{key: "\($freq)", value: "\($freq)\($pref)"}'
  query="[${query}]"

  local options=''
  options="$(echo "${output}" | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${options}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No refresh rates have found"
    return 2
  fi

  pick_one "Select a refresh rate:" "${options}" "vertical" || return $?
}

# Shows a prompt status and asks user to enter the
# next command, which is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A minimal prompt status line.
prompt () {
  local status=''
  status="$(find_outputs "primary" | jq -cer '.[0].model_name' | tr ' ' '-')"
  
  if [[ $? -ne 0 ]]; then
    echo "Unable to resolve status"
    status='none'
  fi

  read -rep "[displays:${status}] " REPLY
}

# Shows the current status of Xorg and active displays.
# Globals:
#  DISPLAY, COLORS, SETTINGS_FILE
# Arguments:
#  None
# Outputs:
#  A verbose list of text data.
show_status () {
  xdpyinfo -display "${DISPLAY}" | awk -F': ' '{
    gsub(/[ \t]+$/, "", $1);
    gsub(/^[ \t]+/, "", $2);

    switch ($1) {
      case "name of display": $1 = "Display"; break
      case "version number": $1 = "Version"; break
      case "vendor string": $1 = "Vendor"; break
      case "vendor release number": $1 = "Release"; break
      case "X.Org version": $1 = "X.Org"; break
      case "motion buffer size": $1 = "Buffer"; break
      case "image byte order": $1 = "Order"; break
      case "default screen number": $1 = "Screen"; break
      case "number of screens": $1 = "Screens"; break
      default: $1 = ""; break
    }

    if ($1) printf "%-8s %s\n",$1":",$2
  }'

  if [[ $? -ne 0 ]]; then
    echo "Unable to read xdpy info"
    return 2
  fi

  local colors='[]'
  if [[ -f "${SETTINGS_FILE}" ]]; then
    colors="$(jq -cr "if .colors then .colors else [] end" "${SETTINGS_FILE}")"
  fi

  local rate=''
  rate+='[.associated_modes[].frequencies]|flatten'
  rate+=' |[.[]|select(.is_current==true)]'
  rate+=' |.[0].frequency'

  local offset='[\(.offset_width),\(.offset_height)]'
  local trans='\(.rotation) \(.reflection|ascii_downcase)'

  # Reduce over color settings to match any devices having a profile set
  local color=''
  color+='reduce $c[] as $i ({};'
  color+=' if $i.model_name == $m and $i.product_id == $p and $i.serial_number == $s'
  color+='  then . + {profile: $i.profile}'
  color+='  else .'
  color+=' end'
  color+=')|if .profile then .profile else "none" end'

  local query=''
  query+='Output:  \(.device_name)\(if .is_primary then "*" else "" end)\n'
  query+='Device:  \(.model_name)\n'
  query+="Mode:    \(.resolution_width)x\(.resolution_height)@\(${rate})Hz\n"
  query+="Pos:     ${offset} ${trans}\n"
  query+="Color:   \(if \$c|length > 0 then (${color}) else \"none\" end)"

  local alias='.model_name as $m|.product_id as $p|.serial_number as $s'

  query=".[]|${alias}|(\"\n${query}\")"

  find_outputs "active" | jq -cer --argjson c "${colors}" "${query}"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read active outputs"
    return 2
  fi
}

# Shows the Xorg displays log file.
# Globals:
#  HOME, DISPLAY
# Arguments:
#  lines: the number of last lines to show
# Outputs:
#  The log file of the xorg display.
show_logs () {
  local lines="${1}"

  if [[ -n "${lines}" ]] && [[ ! "${lines}" =~ ^[0-9][0-9]*$ ]]; then
    echo "Invalid lines value"
    return 2
  fi

  local id="$(echo "${DISPLAY}" | cut -d ':' -f 2)"
  local log_file="${HOME}/.local/share/xorg/Xorg.${id}.log"

  if [[ ! -f "${log_file}" ]]; then
    echo "Unable to locate xorg log file"
    return 2
  fi

  if [[ -z "${lines}" ]]; then
    cat "${log_file}"
  else
    cat "${log_file}" | tail -n "${lines}"
  fi
}

# Shows the data of the output with the given name.
# Globals:
#  REPLY, SETTINGS_FILE
# Arguments:
#  name: the name of an output
# Outputs:
#  A verbose list of text data.
show_output () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "all" || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local colors='[]'
  if [[ -f "${SETTINGS_FILE}" ]]; then
    colors="$(jq -cr "if .colors then .colors else [] end" "${SETTINGS_FILE}")"
  fi

  local base=''
  base+='Name:       \(.device_name)\n'
  base+='\(if .model_name then "Device:     \(.model_name)\n" else "" end)'
  base+='Connected:  \(.is_connected)\n'
  base+='Active:     \(.is_connected and .resolution_width)\n'
  base+='Primary:    \(.is_primary)'

  local rate=''
  rate+='[.associated_modes[].frequencies]|flatten'
  rate+=' |[.[]|select(.is_current==true)]'
  rate+=' |.[0].frequency'

  local extra=''
  extra+='Mode:       \(.resolution_width)x\(.resolution_height)\n'
  extra+="Rate:       \(${rate})Hz\n"
  extra+='Offset:     [\(.offset_width),\(.offset_height)]\n'
  extra+='Rotate:     \(.rotation)\n'
  extra+='Reflect:    \(.reflection|ascii_downcase)'

  # Reduce over color settings to match any devices have a profile set
  local color=''
  color+='reduce $c[] as $i ({};'
  color+='if $i.model_name == $m and $i.product_id == $p and $i.serial_number == $s'
  color+=' then . + {profile: $i.profile}'
  color+=' else . '
  color+='end)|if .profile then .profile else "none" end'

  local modes=''
  modes+='.associated_modes[]|'
  modes+='"\(.resolution_width)x\(.resolution_height)\(if .is_high_resolution then "i" else "" end)" as $mode|"'
  modes+='\($mode)'
  modes+='\($mode|if (10-length)>0 then (" "*(10-length)) else "" end)'
  modes+=' [\([.frequencies[]|.frequency]|join(", "))]"'

  modes="[${modes}]|join(\"\n            \")"

  local query=''
  query+="${base}"
  query+='\(if .is_connected and .resolution_width != null'
  query+=" then \"\n${extra}\""
  query+=' else "" end)'
  query+='\(if .is_connected'
  query+=" then \"\nColor:      \(if \$c|length > 0 then (${color}) else \"none\" end)\""
  query+=' else "" end)'
  query+='\(if .associated_modes|length != 0'
  query+=" then \"\nModes:      \(${modes})\""
  query+=' else "" end)'

  local alias='.model_name as $m|.product_id as $p|.serial_number as $s'

  query=".[]|${alias}|select(.device_name==\"${name}\")|(\"${query}\")"

  find_outputs "all" | jq -cer --argjson c "${colors}" "${query}"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 2
  fi
}

# Shows the list of outputs matching the given status.
# Arguments:
#  status: all, connected, disconnected, active,
#          inactive, primary
# Outputs:
#  A list of outputs.
list_outputs () {
  local status="${1:-"all"}"

  local states='all|connected|disconnected|active|inactive|primary'
  if [[ ! "${status}" =~ ^(${states})$ ]]; then
    echo "Invalid status value"
    return 2
  fi

  local query=''
  query+='Name:       \(.device_name)\n'
  query+='\(if .model_name then "Device:     \(.model_name)\n" else "" end)'
  query+='Connected:  \(.is_connected)\n'
  query+='Active:     \(.is_connected and .resolution_width)\n'
  query+='Primary:    \(.is_primary)\n'

  query=".[]|(\"${query}\")"

  local outputs=''
  outputs="$(find_outputs "${status}" | jq -cr "${query}")" || return 1

  if [[ -z "${outputs}" ]]; then
    echo "No ${status:-\b} outputs have found"
    return 2
  fi

  echo "${outputs}"
}

# Sets the resolution and rate of the output with the
# given name.
# Globals:
#  REPLY
# Arguments:
#  name:       the name of an output
#  resolution: a width x height resolution
#  rate:       a refresh rate number
set_mode () {
  local name="${1}"
  local resolution="${2}"
  local rate="${3}"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 2
  elif ! is_connected "${output}"; then
    echo "Output ${name} is disconnected"
    return 2
  elif ! is_active "${output}"; then
    echo "Output ${name} is inactive"
    return 2
  fi

  if [[ -z "$resolution" ]]; then
    pick_resolution "${output}" || return $?
    [[ -n "${REPLY}" ]] && resolution="${REPLY}" || return 0
  fi
  
  if [[ ! "${resolution}" =~ ^[0-9]+x[0-9]+i?$ ]]; then
    echo "Invalid resolution value"
    return 2
  elif ! has_resolution "${output}" "${resolution}"; then
    echo "Resolution ${resolution} is not supported"
    return 2
  fi

  if [[ -z "${rate}" ]]; then
    pick_rate "${output}" "${resolution}" || return $?
    [[ -n "${REPLY}" ]] && rate="${REPLY}" || return 0
  fi
  
  if [[ ! "${rate}" =~ ^[0-9][0-9]+(.[0-9][0-9])?$ ]]; then
    echo "Invalid refresh rate value"
    return 2
  elif ! has_rate "${output}" "${resolution}" "${rate}"; then
    echo "Refresh rate ${rate} is not supported"
    return 2
  fi

  xrandr --output "${name}" --mode "${resolution}" --rate "${rate}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to set output mode"
    return 2
  fi

  echo "Output ${name} mode set to ${resolution}@${rate}"
}

# Sets the output with the given name as primary.
# Globals:
#  REPLY
# Arguments:
#  name: the name of an output
set_primary () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 2
  elif ! is_connected "${output}"; then
    echo "Output ${name} is disconnected"
    return 2
  elif ! is_active "${output}"; then
    echo "Output ${name} is inactive"
    return 2
  elif is_primary "${output}"; then
    echo "Output ${name} is already primary"
    return 2
  fi

  xrandr --output "${name}" --primary

  if [[ $? -ne 0 ]]; then
    echo "Failed to set as primary output"
    return 2
  fi
  
  echo "Output ${name} set as primary"
}

# Sets the output with the given name on.
# Globals:
#  REPLY
# Arguments:
#  name: the name of an output
set_on () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "inactive" || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 2
  elif ! is_connected "${output}"; then
    echo "Output ${name} is disconnected"
    return 2
  elif is_active "${output}"; then
    echo "Output ${name} is already active"
    return 2
  fi

  # Find the last in order active monitor
  local query='[.[]|select(.is_connected and .resolution_width)]'
  query+='|sort_by(.offset_height, .offset_width)'
  query+='|if length > 0 then last|.device_name else "" end'
  
  local last=''
  last="$(find_outputs "all" | jq -cr "${query}")" || return 1

  if [[ -n "${last}" ]]; then
    xrandr --output "${name}" --auto --right-of "${last}"
  else
    xrandr --output "${name}" --auto
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to activate output"
    return 2
  fi
  
  echo "Output ${name} has been activated"
}

# Sets the output with the given name off.
# Globals:
#  REPLY
# Arguments:
#  name: the name of an output
set_off () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 2
  elif ! is_connected "${output}"; then
    echo "Output ${name} is disconnected"
    return 2
  elif ! is_active "${output}"; then
    echo "Output ${name} is already inactive"
    return 2
  elif is_primary "${output}"; then
    echo "Cannot deactivate the primary output"
    return 2
  fi

  xrandr --output "${name}" --off

  if [[ $? -ne 0 ]]; then
    echo "Failed to deactivate output"
    return 2
  fi
  
  echo "Output ${name} has been deactivated"
}

# Sets the reflection of the output with the given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of an output
#  mode: normal, x, y, xy
reflect () {
  local name="${1}"
  local mode="${2}"
  
  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 2
  elif ! is_connected "${output}"; then
    echo "Output ${name} is disconnected"
    return 2
  elif ! is_active "${output}"; then
    echo "Output ${name} is inactive"
    return 2
  fi

  if [[ -z "${mode}" ]]; then
    local modes=''
    modes+='{"key": "normal", "value": "Normal"},'
    modes+='{"key": "x", "value": "X Axis"},'
    modes+='{"key": "y", "value": "Y Axis"},'
    modes+='{"key": "xy", "value": "XY Axis"}'
    modes="[${modes}]"

    pick_one "Select a reflection mode:" "${modes}" "horizontal" || return $?
    [[ -n "${REPLY}" ]] && mode="${REPLY}" || return 0
  fi
  
  if [[ ! "${mode}" =~ ^(normal|x|y|xy)$ ]]; then
    echo "Invalid reflection value"
    return 2
  fi

  xrandr --output "${name}" --reflect "${mode}"
    
  if [[ $? -ne 0 ]]; then
    echo "Failed to reflect output"
    return 2
  fi

  echo "Reflection of output ${name} set to ${mode}"
}

# Sets the rotation of the output with the given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of an output
#  mode: normal, right, left, inverted
rotate () {
  local name="$1"
  local mode="$2"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 2
  elif ! is_connected "${output}"; then
    echo "Output ${name} is disconnected"
    return 2
  elif ! is_active "${output}"; then
    echo "Output ${name} is inactive"
    return 2
  fi

  if [[ -z "${mode}" ]]; then
    local modes=''
    modes+='{"key": "normal", "value": "Normal"},'
    modes+='{"key": "right", "value": "Right"},'
    modes+='{"key": "left", "value": "Left"},'
    modes+='{"key": "inverted", "value": "Inverted"}'
    modes="[${modes}]"

    pick_one "Select a rotation mode:" "${modes}" "horizontal" || return $?
    [[ -n "${REPLY}" ]] && mode="${REPLY}" || return 0
  fi
  
  if [[ ! "${mode}" =~ ^(normal|right|left|inverted)$ ]]; then
    echo "Invalid rotation value"
    return 2
  fi

  xrandr --output "${name}" --rotate "${mode}"
    
  if [[ $? -ne 0 ]]; then
    echo "Failed to rotate output"
    return 2
  fi
  
  echo "Rotation of output ${name} set to ${mode}"
}

# Mirrors the output with the given name to other outputs,
# having all mirrors run at a common resolution shared among
# the source output and the mirrors. All outputs will move to
# position equal to the position of the source output and
# inherit the rotation and reflection modes.
# Globals:
#  REPLY
# Arguments:
#  name: the name of an output
mirror () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_output "Select source output:" "active" || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 2
  elif ! is_connected "${output}"; then
    echo "Output ${name} is disconnected"
    return 2
  elif ! is_active "${output}"; then
    echo "Output ${name} is inactive"
    return 2
  fi

  local outputs=''
  outputs="$(find_outputs "active")" || return 1

  local len=0
  len="$(count "${outputs}")" || return 1

  if [[ ${len} -lt 2 ]]; then
    echo "No other output exists to mirror ${name} to"
    return 2
  fi

  local mirrors=''
  pick_outputs "Select target outputs:" "active" "1," "${name}" || return $?
  [[ -n "${REPLY}" ]] && mirrors="${REPLY}" || return 0

  # Find the common resolution modes among output and mirrors
  local names=''
  names="$(echo "${mirrors}" | jq -cer '.|join("|")')" || return 1
  names+="|${name}"

  local query=''
  query+="select(.device_name | match(\"(${names})\"))"
  query+=' |.associated_modes[]'
  query+=' |"\(.resolution_width)x\(.resolution_height)\(if .is_high_resolution then "i" else "" end)"'

  query="[.[]|${query}]"
  query+=' |[group_by(.)|map(select(length>1))|.[]|.[0]'
  query+=' |{key: "\(.)", value: "\(.)"}]'

  local modes=''
  modes="$(echo "${outputs}" | jq -cer "${query}")" || return 1

  if [[ "$(count "${modes}")" -eq 0 ]]; then
    echo "No common resolutions have found between outputs"
    return 2
  fi

  local mode=''
  pick_one "Select the mirroring resolution:" "${modes}" "vertical" || return $?
  [[ -n "${REPLY}" ]] && mode="${REPLY}" || return 0

  # Have mirrors inherit the position and rotate/reflect of the source output
  local pos="$(echo "${output}" | jq -r '"\(.offset_width)x\(.offset_height)"')"
  local rot="$(echo "${output}" | jq -r '.rotation')"
  local ref="$(echo "${output}" | jq -r '.reflection|ascii_downcase' |
    awk '{gsub(/( |and|axis)/,"",$0); print}')"

  local query='.[]|'
  query+="\"--output \(.) --mode ${mode} --pos ${pos} --rotate ${rot} --reflect ${ref}\""
  query="[${query}]|join(\" \")"

  local others=''
  others="$(echo "${mirrors}" | jq -cr "${query}")" || return 1

  xrandr --output "${name}" --mode "${mode}" ${others}

  if [[ $? -ne 0 ]]; then
    echo "Failed to mirror output"
    return 2
  fi
  
  echo "Output ${name} has been mirrored"
}

# Sets the layout of the currently active outputs.
# Globals:
#  REPLY
# Arguments:
#  None
set_layout () {
  local outputs=''
  outputs="$(find_outputs "active")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read active outputs"
    return 2
  fi

  local len=0
  len="$(count "${outputs}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No active outputs have found"
    return 2
  elif [[ ${len} -eq 1 ]]; then
    echo "Only one active output found"
    return 0
  elif [[ ${len} -gt 4 ]]; then
    echo "Too many active outputs have found"
    return 0
  fi

  local modes=''

  if [[ ${len} -eq 2 ]]; then
    modes+='{"key": "row-2", "value": "Row"},'
    modes+='{"key": "col-2", "value": "Column"}'
  elif [[ ${len} -eq 3 ]]; then
    modes+='{"key": "row-3", "value": "Row"},'
    modes+='{"key": "col-3", "value": "Column"},'
    modes+='{"key": "gamma-3", "value": "Gamma"},'
    modes+='{"key": "gamma-rev-3", "value": "Gamma Reverse"},'
    modes+='{"key": "lambda-3", "value": "Lambda"},'
    modes+='{"key": "lambda-rev-3", "value": "Lambda Reverse"}'
  elif [[ ${len} -eq 4 ]]; then
    modes+='{"key": "grid-4", "value": "Grid"},'
    modes+='{"key": "taph-4", "value": "Taph"},'
    modes+='{"key": "taph-rev-4", "value": "Taph Reverse"},'
    modes+='{"key": "taph-right-4", "value": "Taph Right"},'
    modes+='{"key": "taph-left-4", "value": "Taph Left"}'
  fi

  local mode=''
  pick_one "Select a layout mode:" "[${modes}]" "vertical" || return $?
  [[ -n "$REPLY" ]] && mode="${REPLY}" || return 0

  local outputs=''
  pick_outputs "Pick outputs by order:" "active" "all" || return $?
  [[ -n "$REPLY" ]] && outputs="${REPLY}" || return 0

  local query=''

  case "${mode}" in
    "row-2")
      query='--output \(.[1]) --right-of \(.[0])'
      ;;
    "col-2")
      query='--output \(.[1]) --below \(.[0])'
      ;;
    "row-3")
      query='--output \(.[1]) --right-of \(.[0]) '
      query+='--output \(.[2]) --right-of \(.[1])'
      ;;
    "col-3")
      query='--output \(.[1]) --below \(.[0]) '
      query+='--output \(.[2]) --below \(.[1])'
      ;;
    "gamma-3")
      query='--output \(.[1]) --right-of \(.[0]) '
      query+='--output \(.[2]) --below \(.[0])'
      ;;
    "gamma-rev-3")
      query='--output \(.[1]) --right-of \(.[0]) '
      query+='--output \(.[2]) --below \(.[1])'
      ;;
    "lambda-3")
      query='--output \(.[1]) --below \(.[0]) '
      query+='--output \(.[2]) --right-of \(.[1])'
      ;;
    "lambda-rev-3")
      query='--output \(.[2]) --right-of \(.[1]) '
      query+='--output \(.[0]) --above \(.[2])'
      ;;
    "grid-4")
      query='--output \(.[1]) --right-of \(.[0]) '
      query+='--output \(.[2]) --below \(.[0]) '
      query+='--output \(.[3]) --right-of \(.[2])'
      ;;
    "taph-4")
      query='--output \(.[1]) --right-of \(.[0]) '
      query+='--output \(.[2]) --right-of \(.[1]) '
      query+='--output \(.[3]) --below \(.[1])'
      ;;
    "taph-rev-4")
      query='--output \(.[2]) --below \(.[0]) '
      query+='--output \(.[1]) --left-of \(.[2]) '
      query+='--output \(.[3]) --right-of \(.[2])'
      ;;
    "taph-right-4")
      query='--output \(.[1]) --below \(.[0]) '
      query+='--output \(.[2]) --right-of \(.[1]) '
      query+='--output \(.[3]) --below \(.[1])'
      ;;
    "taph-left-4")
      query='--output \(.[0]) --above \(.[2]) '
      query+='--output \(.[1]) --left-of \(.[2]) '
      query+='--output \(.[3]) --below \(.[2])'
      ;;

    *) return 1;;
  esac

  local layout=''
  layout="$(echo "${outputs}" | jq -cr "\"${query}\"")"

  xrandr ${layout}

  if [[ $? -ne 0 ]]; then
    echo "Failed to set layout ${mode,,}"
    return 2
  fi

  echo "Layout has been set to ${mode,,}"
}

# Saves the current layout under a unique hashed signature
# which is based on the mapping between all outputs and
# their possibly connected devices.
# Globals:
#  REPLY, CONFIG_HOME, SETTINGS_FILE
# Arguments:
#  None
save_layout () {
  local outputs=''
  outputs="$(find_outputs "all")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read outputs"
    return 2
  fi

  local len=0
  len="$(count "${outputs}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No outputs have found"
    return 2
  fi

  # Create a hash map of <output,{device, mode}> entries
  local device=''
  device+='if .model_name and .is_connected and .resolution_width'
  device+=' then {model_name: .model_name, product_id: .product_id, serial_number: .serial_number}'
  device+=' else {} '
  device+='end'

  local res=''
  res+='.associated_modes[]'
  res+=' |"\(.resolution_width)x\(.resolution_height)\(if .is_high_resolution then "i" else "" end)" as $res'
  res+=' |.frequencies[]|select(.is_current)'
  res+=' |"--mode \($res) --rate \(.frequency)"'

  local pos='--pos \(.offset_width)x\(.offset_height)'
  local rotate='--rotate \(.rotation)'
  local reflect='--reflect \(.reflection|ascii_downcase|gsub("( |and|axis)";""))'
  local primary='if .is_primary then "--primary" else "" end'

  local query=''
  query+='if .resolution_width'
  query+=" then (${device}) * {mode: \"\(${res}) ${pos} ${rotate} ${reflect} \(${primary})\"}"
  query+=" else (${device}) * {mode: \"--off\"} "
  query+='end'

  query="map({(.device_name|tostring): (${query})})|add"

  local map=''
  map="$(echo "${outputs}" | jq -cer "${query}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to parse mapping"
    return 2
  fi

  # Assign a signature to the current layout mapping
  local sig=''
  sig="$(get_sig "${outputs}")" || return 1

  local layout="{\"sig\": \"${sig}\", \"map\": ${map}}"

  local settings='{}'

  if [[ -f "${SETTINGS_FILE}" ]]; then
    local layouts=''
    layouts="$(jq 'if .layouts then .layouts else empty end' "${SETTINGS_FILE}")"

    if [[ -n "${layouts}" ]]; then
      local query=''
      query=".layouts[]|select(.sig == \"${sig}\")"

      local exists=''
      exists="$(jq "${query}" "${SETTINGS_FILE}")"

      if [[ -n "${exists}" ]]; then
        query="(${query}|.map)|= ${map}"
      else
        query=".layouts += [${layout}]"
      fi

      settings="$(jq -e "${query}" "${SETTINGS_FILE}")" || return 1
    else
      settings="$(jq -e ".layouts = [${layout}] " "${SETTINGS_FILE}")" || return 1
    fi
  else
    settings="$(echo "{\"layouts\": [${layout}]}" | jq -e '.')" || return 1
  fi

  mkdir -p "${CONFIG_HOME}"
  echo "${settings}" > "${SETTINGS_FILE}"
  
  echo "Layout has been saved"
}

# Restores the layout setting with the signature matching
# the signature of the mapping between current outputs and 
# connected devices.
# Globals:
#  SETTINGS_FILE
# Arguments:
#  None
restore_layout () {
  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No layout settings found"
    return 0
  fi

  local layouts=''
  layouts="$(jq '.layouts|if . then . else empty end' "${SETTINGS_FILE}")"

  if [[ -z "${layouts}" ]]; then
    echo "No layout settings found"
    return 0
  fi

  local outputs=''
  outputs="$(find_outputs "all")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read outputs"
    return 2
  fi

  local len=0
  len="$(count "${outputs}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No outputs have found"
    return 2
  fi

  # Calculate the hashed signature of the current mapping
  local sig=''
  sig="$(get_sig "${outputs}")" || return 1

  # Search for a layout matching the current mapping
  local query='.[]'
  query+="|select(.sig == \"${sig}\")|.map|to_entries[]"
  query+='|"--output \(.key) \(.value.mode)"'
  query="[${query}]|join(\" \")"

  local layout=''
  layout="$(echo "${layouts}" | jq -cr "${query}")"

  if [[ -z "${layout}" ]]; then
    echo "No layout match found"
    return 0
  fi

  xrandr ${layout}

  if [[ $? -ne 0 ]]; then
    echo "Failed to restore the layout"
    return 2
  fi

  echo "Layout has been restored"
}

# Fixes the positioning of the current layout by
# setting forcefully to off any output being
# disconnected or inactive.
# Arguments:
#  None
fix_layout () {
  local outputs=''
  outputs="$(find_outputs "all")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read outputs"
    return 2
  fi

  local len=0
  len="$(count "${outputs}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No outputs have found"
    return 2
  fi

  # Set any disconnected monitors off
  local query='.[]|select(.is_connected|not)'
  query+='|"--output \(.device_name) --off"'
  query="[${query}]|join(\" \")"

  local disconnected=''
  disconnected="$(echo "${outputs}" | jq -cr "${query}")"

  # Set any inactive monitors off
  local query='.[]|select(.is_connected and .resolution_width == null)'
  query+='|"--output \(.device_name) --off"'
  query="[${query}]|join(\" \")"

  local inactive=''
  inactive="$(echo "${outputs}" | jq -cr "${query}")"

  if [[ -z "${disconnected// }" ]] && [[ -z "${inactive// }" ]]; then
    echo "No fix applied to layout"
    return 0
  fi

  xrandr ${disconnected} ${inactive}

  if [[ $? -ne 0 ]]; then
    echo "Failed to fix the layout"
    return 2
  fi

  echo "Layout has been fixed"
}

# Deletes the layout setting with the given index.
# Globals:
#  REPLY, SETTINGS_FILE
# Arguments;
#  index: the index of the layout setting
delete_layout () {
  local index="${1}"

  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No layout settings have found"
    return 2
  fi

  if [[ -z "${index}" ]]; then
    local devices=''
    devices+='\(if .value.model_name then "\(.key):\(.value.model_name)" else empty end)'
    devices="[.value.map|to_entries[]|\"${devices}\"]|join(\", \")"

    local query=''
    query+="{key: .key, value: \"\(.key):[\(${devices})]\"}"
    query="if .layouts|length > 0 then [.layouts|to_entries[]|${query}] else [] end"

    local layouts=''
    layouts="$(jq -cer "${query}" "${SETTINGS_FILE}")" || return 1
    
    local len=0
    len="$(count "${layouts}")" || return 1

    if [[ ${len} -eq 0 ]]; then
      echo "No layout settings have found"
      return 2
    fi

    pick_one "Select a layout setting:" "${layouts}" "vertical" || return $?
    [[ -n "${REPLY}" ]] && index="${REPLY}" || return 0
  fi

  if [[ ! "${index}" =~ ^[0-9][0-9]*$ ]]; then
    echo "Invalid index value"
    return 2
  fi

  local exists=''
  exists="$(jq "select(.layouts[${index}])" "${SETTINGS_FILE}")"

  if [[ -z "${exists}" ]]; then
    echo "Cannot find layout setting with index ${index}"
    return 2
  fi

  local settings=''
  settings="$(jq -e "del(.layouts|.[${index}])" "${SETTINGS_FILE}")"

  if [[ $? -ne 0 ]]; then
    echo "Failed to delete layout setting"
    return 2
  fi

  echo "${settings}" > "${SETTINGS_FILE}"
  
  echo "Layout setting has been deleted"
}

# List all the stored layout settings.
# Globals:
#  SETTINGS_FILE
# Arguments:
#  none
# Outputs:
#  A list of layout settings.
list_layouts () {
  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No layout settings have found"
    return 0
  fi

  local map=''
  map+='\(.key):\(.key|if (9-length)>0 then (" "*(9-length)) else "" end)'
  map+='\(if .value.model_name then "\(.value.model_name) " else "" end)'
  map+='\(if .value.mode == "--off" then "[OFF]" else "[ON]" end)'
  map="\([.value.map|to_entries[]|\"${map}\"]|join(\"\n\"))"

  local layout=''
  layout+='Index:    \(.key)\n'
  layout+="${map}"

  local query=''
  query+='if .layouts|length > 0'
  query+=" then .layouts|to_entries[]|\"${layout}\""
  query+=' else "No layout settings have found"'
  query+='end'

  query="[${query}]|join(\"\n\n\")"

  jq -cer "${query}" "${SETTINGS_FILE}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to list layout settings"
    return 2
  fi
}

# Sets the color profile of the device connected to the output
# with the given name and saves it to the color settings. The
# profile should be the filename of any .icc or .icm color
# calibration files stored in $COLORS_HOME.
# Globals:
#  REPLY, COLORS_HOME, DISPLAY, CONFIG_HOME, SETTINGS_FILE
# Arguments:
#  name:    the name of an output
#  profile: the file name of a color profile
set_color () {
  local name="$1"
  local profile="$2"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi
  
  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 2
  elif ! is_connected "${output}"; then
    echo "Output ${name} is disconnected"
    return 2
  elif ! is_active "${output}"; then
    echo "Output ${name} is inactive"
    return 2
  fi

  if [[ -z "${profile}" ]]; then
    # List all color calibration files under $COLORS_HOME
    local query='{key: .filename, value: .filename}'
    query="[.[]|select(.filename|test(\".ic(c|m)$\"))|${query}]"
  
    local profiles=''
    profiles="$(ls "${COLORS_HOME}" 2> /dev/null | jc --ls | jq -cr "${query}")"
    
    local len=0
    len="$(count "${profiles}")" || return 1

    if [[ ${len} -eq 0 ]]; then
      echo "No color profiles have found"
      return 2
    fi

    pick_one "Select a color profile:" "${profiles}" "vertical" || return $?
    [[ -n "${REPLY}" ]] && profile="${REPLY}" || return 0
  fi

  if [[ ! "${profile}" =~ .ic(c|m)$ ]]; then
    echo "Invalid profile file"
    return 2
  elif [[ ! -f "${COLORS_HOME}/${profile}" ]]; then
    echo "Profile file ${profile} not exists"
    return 2
  fi

  local index=''
  index="$(get "${output}" ".index")" || return 1

  local result=''
  result="$(xcalib -d "${DISPLAY}" -s 0 -o "${index}" "${COLORS_HOME}/${profile}" 2>&1)"

  if [[ $? -ne 0 ]] || [[ -n "${result}" ]]; then
    echo "Failed to set color profile"
    return 2
  fi

  echo "Color of output ${name} set to ${profile}"

  # Save color profile to color settings
  local query=''
  query+='model_name: .model_name,'
  query+='product_id: .product_id,'
  query+='serial_number: .serial_number,'
  query+="profile: \"${profile}\""
  query="{${query}}"

  local color=''
  color="$(echo "${output}" | jq -cr "${query}")"

  local settings='{}'

  if [[ -f "${SETTINGS_FILE}" ]]; then
    local colors=''
    colors="$(jq 'if .colors then .colors else empty end' "${SETTINGS_FILE}")"

    if [[ -n "${colors}" ]]; then
      local query=''
      query+='.model_name == $c.model_name and '
      query+='.product_id == $c.product_id and '
      query+='.serial_number == $c.serial_number'
      query=".colors[]|select(${query})"

      local exists=''
      exists="$(jq --argjson c "${color}" "${query}" "${SETTINGS_FILE}")"

      if [[ -n "${exists}" ]]; then
        query="(${query}|.profile)|=\"${profile}\""
      else
        query=".colors += [${color}]"
      fi

      settings="$(jq -e --argjson c "${color}" "${query}" "${SETTINGS_FILE}")" || return 1
    else
      settings="$(jq -e ".colors = [${color}]" "${SETTINGS_FILE}")" || return 1
    fi
  else
    settings="$(echo "{\"colors\": [${color}]}" | jq -e '.')" || return 1
  fi

  mkdir -p "${CONFIG_HOME}"
  echo "${settings}" > "${SETTINGS_FILE}"
}

# Resets the color profile of the device connected to the
# output with the given name and removes it from the color
# settings.
# Globals:
#  REPLY, DISPLAY, SETTINGS_FILE
# Arguments:
#  name: the name of an output
reset_color () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_output "Select an output:" "active" || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local output=''
  output="$(find_output "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find output ${name}"
    return 2
  elif ! is_connected "${output}"; then
    echo "Output ${name} is disconnected"
    return 2
  elif ! is_active "${output}"; then
    echo "Output ${name} is inactive"
    return 2
  fi

  local index=''
  index="$(get "${output}" ".index")" || return 1

  local result=''
  result="$(xcalib -d "${DISPLAY}" -s 0 -o "${index}" -c 2>&1)"

  if [[ $? -ne 0 ]] || [[ -n "${result}" ]]; then
    echo "Failed to reset color profile"
    return 2
  fi

  echo "Color of ${name} has been reset"

  # Try to remove color profile from color settings
  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    return 0
  fi

  local query=''
  query+='.model_name == $o.model_name and '
  query+='.product_id == $o.product_id and '
  query+='.serial_number == $o.serial_number'
  query="if .colors then .colors[]|select(${query}) else empty end"

  local settings=''
  settings="$(jq -e --argjson o "${output}" "del(${query})" "${SETTINGS_FILE}")" || return 1

  echo "${settings}" > "${SETTINGS_FILE}"
}

# Deletes the color setting with the given index.
# Globals:
#  SETTINGS_FILE, REPLY
# Arguments:
#  index: the index of a color setting
delete_color () {
  local index="${1}"

  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No color settings have found"
    return 2
  fi

  if [[ -z "${index}" ]]; then
    local query=''
    query+='{key: .key, value: "\(.key):\(.value.model_name) [\(.value.profile)]"}'
    query="if .colors|length > 0 then [.colors|to_entries[]|${query}] else [] end"

    local colors=''
    colors="$(jq -cer "${query}" "${SETTINGS_FILE}")" || return 1
    
    local len=0
    len="$(count "${colors}")" || return 1

    if [[ ${len} -eq 0 ]]; then
      echo "No color settings have found"
      return 2
    fi

    pick_one "Select a color setting:" "${colors}" "vertical" || return $?
    [[ -n "${REPLY}" ]] && index="${REPLY}" || return 0
  fi

  if [[ ! "${index}" =~ ^[0-9][0-9]*$ ]]; then
    echo "Invalid index value"
    return 2
  fi

  local exists=''
  exists="$(jq "select(.colors[${index}])" "${SETTINGS_FILE}")"

  if [[ -z "${exists}" ]]; then
    echo "Cannot find color setting with index ${index}"
    return 2
  fi

  local settings='{}'
  settings="$(jq -e "del(.colors|.[${index}])" "${SETTINGS_FILE}")"

  if [[ $? -ne 0 ]]; then
    echo "Failed to delete color setting"
    return 2
  fi

  echo "${settings}" > "${SETTINGS_FILE}"

  echo "Color setting has been deleted"
}

# List all the color settings per device being stored
# in settings.
# Globals:
#  SETTINGS_FILE
# Arguments:
#  none
# Outputs:
#  A list of color settings.
list_colors () {
  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No color settings have found"
    return 0
  fi

  local color=''
  color+='Index:    \(.key)\n'
  color+='Device:   \(.value.model_name)\n'
  color+='Product:  \(.value.product_id)\n'
  color+='Serial:   \(.value.serial_number)\n'
  color+='Profile:  \(.value.profile)'

  local query=''
  query+='if .colors|length > 0'
  query+=" then .colors|to_entries[]|\"${color}\""
  query+=' else "No color settings have found"'
  query+='end'

  query="[${query}]|join(\"\n\n\")"

  jq -cer "${query}" "${SETTINGS_FILE}"

  if [[ $? -ne 0 ]]; then
    echo "Unable to list color settings"
    return 2
  fi
}

# Restores the color settings of any devices currently
# connected to an output.
# Globals:
#  COLORS_HOME, SETTINGS_FILE, DISPLAY
# Arguments:
#  None
restore_colors () {
  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No color settings have found"
    return 0
  fi

  local colors=''
  colors="$(jq -cr 'if .colors then .colors else [] end' "${SETTINGS_FILE}")" || return 1

  local len=0
  len="$(count "${colors}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No color settings have found"
    return 0
  fi

  local outputs=''
  outputs="$(find_outputs "active")" || return 1

  local xcalib_cmd=''
  xcalib_cmd+="\"xcalib -d ${DISPLAY} -s 0 -o \(.index) ${COLORS_HOME}/\(.profile)\""

  local query=''
  query+='. + $c'
  query+=' |group_by([.model_name, .product_id, .serial_number])'
  query+=" |map({index: (.[0].index), profile: (.[].profile|select(.))})[]"
  query+=" |${xcalib_cmd}"

  local xcalib_cmds=''
  xcalib_cmds="$(echo "${outputs}" | jq -cr --argjson c "${colors}" "${query}")" || return 1

  # Iterate over xcalib commands and execute one by one
  local failed='false'
  local xcalib_cmd=''

  while read -r xcalib_cmd; do
    local result="$(${xcalib_cmd} 2>&1)"

    if [[ $? -ne 0 ]] || [[ -n "${result}" ]]; then
      failed='true'
    fi
  done <<< "${xcalib_cmds}"

  if [[ "${failed}" == "true" ]]; then
    echo "Failed to restore all color profiles"
    return 2
  fi

  echo "Color profiles have been restored"
}

# Shows the help message.
# Arguments:
#  mode: once or none
# Outputs:
#  A long help message.
show_help () {
  if [[ "${1}" == "once" ]]; then
    echo "Usage: displays COMMAND [OBJECT] [ARGUMENTS]..."

    echo -e "\nCOMMANDS"
    printf " %-16s %s\n" \
      "help" "Show this help message." \
      "" "" \
      "restore colors" "Restore colors to currently active displays." \
      "restore layout" "Restore the layout matching the current mapping." \
      "fix layout" "Fix the positioning of the current layout."

    return 0
  fi

  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf " %-44s %s\n" \
    "help" "Show this help message." \
    "" "" \
    "show status" "Show a report of the Xorg server and active outputs." \
    "show logs [<lines>]" "Show the last logs of the Xorg server." \
    "" "" \
    "list outputs [<status>]" "List outputs by their status," \
    "" "all, connected, disconnected, active, inactive, primary." \
    "show output [<name>]" "Show the data of an output." \
    "" "" \
    "set mode [<output> [<resolution> [<rate>]]]" "Set the mode of an output." \
    "set primary [<output>]" "Set an output as primary." \
    "set on|off [<output>]" "Activate or de-activate an output." \
    "rotate [<output> [<mode>]]" "Rotate an output's view to normal, right, left or inverted." \
    "reflect [<output> [<mode>]]" "Reflect an output's view to normal, x, y or xy." \
    "mirror [<output>]" "Mirror an output to other outputs." \
    "" "" \
    "set layout [mode]" "Set the layout of active outputs to row-2, col-2, row-3," \
    "" "col-3, gamma-3, gamma-rev-3, lambda-3 or lambda-rev-3." \
    "save layout" "Save the current layout of active outputs." \
    "list layouts" "List all layout settings." \
    "delete layout [<index>]" "Delete a layout setting." \
    "restore layout" "Restore the layout matching the current mapping." \
    "" "" \
    "set color [<output> [<profile>]]" "Set color profile of a display connected to an output." \
    "reset color [<output>]" "Reset color profile of a display connected to an output." \
    "list colors" "List all color settings per display." \
    "delete color [<index>]" "Delete a color setting." \
    "restore colors" "Restore colors to currently active displays."
}

loop () {
  clear

  while true; do
    prompt && history -s "${REPLY}"

    set -f
    set_separator "line"
    local cmd=($(xargs -n1 <<< "${REPLY}"))
    restore_separator && set +f

    if [[ "${cmd[0]}" == "help" ]]; then
      show_help
      continue
    elif [[ "${cmd[0]}" == "clear" ]]; then
      clear
      continue
    elif [[ "${cmd[0]}" == "quit" ]]; then
      break
    elif [[ -z "${cmd[0]}" ]]; then
      continue
    fi

    case "${cmd[0]}" in
      "show")
        case "${cmd[1]}" in
          "status") show_status;;
          "logs") show_logs "${cmd[2]}";;
          "output") show_output "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "list")
        case "${cmd[1]}" in
          "outputs") list_outputs "${cmd[2]}";;
          "colors") list_colors;;
          "layouts") list_layouts;;
          *) echo "Invalid or unknown command";;
        esac;;
      "set")
        case "${cmd[1]}" in
          "layout") set_layout;;
          "mode") set_mode "${cmd[2]}" "${cmd[3]}" "${cmd[4]}";;
          "primary") set_primary "${cmd[2]}";;
          "on") set_on "${cmd[2]}";;
          "off") set_off "${cmd[2]}";;
          "color") set_color "${cmd[2]}" "${cmd[3]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "reset")
        case "${cmd[1]}" in
          "color") reset_color "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "save")
        case "${cmd[1]}" in
          "layout") save_layout;;
          *) echo "Invalid or unknown command";;
        esac;;
      "delete")
        case "${cmd[1]}" in
          "layout") delete_layout "${cmd[2]}";;
          "color") delete_color "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "restore")
        case "${cmd[1]}" in
          "layout") restore_layout;;
          "colors") restore_colors;;
          *) echo "Invalid or unknown command";;
        esac;;
      "rotate") rotate "${cmd[1]}" "${cmd[2]}";;
      "reflect") reflect "${cmd[1]}" "${cmd[2]}";;
      "mirror") mirror "${cmd[1]}";;
      *) echo "Invalid or unknown command";;
    esac

    if [[ $? -eq 1 ]]; then
      echo "An unknown error has occurred"
    fi
  done

  clear
}

once () {
  case "${1}" in
    "help") show_help "once";;
    "restore")
      case "${2}" in
        "layout") restore_layout;;
        "colors") restore_colors;;
        *) abort "Invalid or unknown command";;
      esac;;
    "fix")
      case "${2}" in
        "layout") fix_layout;;
        *) abort "Invalid or unknown command";;
      esac;;
    *) abort "Invalid or unknown command";;
  esac

  if [[ $? -ne 0 ]]; then
    abort
  fi
}

if [[ $# -eq 0 ]]; then
  loop
else
  once "$@"
fi