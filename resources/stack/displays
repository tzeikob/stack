#!/usr/bin/env bash

set -o pipefail
source /opt/stack/utils

CONFIG_HOME="$HOME/.config/stack/displays"
LAYOUT_FILE="$CONFIG_HOME/layout"

require "xorg-xrandr"
require "xcalib"

screen () {
  xrandr --current | sed "/^Screen 0:/,/^Screen/!d;//d"
}

outputs () {
  local STATUS=$1

  local RE='^[A-Z]+-[0-9]+'
  if [[ "$STATUS" =~ ^(dis)?connected$ ]]; then
    RE+="\s$STATUS"
  elif [ "$STATUS" = "active" ]; then
    RE+='\sconnected.*\s([0-9]+x[0-9]+)\+.*'
  elif [ "$STATUS" = "inactive" ]; then
    RE+='\sconnected\s\(.*'
  elif [ "$STATUS" = "primary" ]; then
    RE+='\s.*\sprimary\s.*'
  fi

  screen | awk '{ORS="'$AES'";} /'${RE}'/{print $1}'
}

output () {
  local NAME=$1

  local CRITERION="^$NAME\s.*"

  if [ "$NAME" = "primary" ]; then
    CRITERION='.*\sprimary\s.*'
  fi

  local SCREEN="$(screen)"

  local HEAD=$(echo "$SCREEN" | awk '/'$CRITERION'/')
  
  if [ -z "$HEAD" ]; then
    return 1
  fi

  local RE='^(.*)\s(connected|disconnected)\s?(primary)?\s?'
  RE+='([0-9]+x[0-9]+)?(\+[0-9]+\+[0-9]+)?\s?'
  RE+='(normal|right|left|inverted)?\s?(X\saxis|Y\saxis|X\sand\sY\saxis)?\s.*'

  local STATE="$(echo "$HEAD" | awk 'match($0,/'$RE'/,a) {
    a[5]=gensub(/\+(.*)\+(.*)/,"\\1x\\2","g",a[5]);
    a[7]=tolower(a[7]); gsub(/( |and|axis)/,"",a[7]);
    print a[1]"'$AES'"a[2]"'$AES'"a[3]"'$AES'"a[4]"'$AES'"a[5]"'$AES'"a[6]"'$AES'"a[7]}')"

  RE='^\s+([0-9]+x[0-9]+)\s.*\s([0-9]{2}.[0-9]{2})\*.*'

  local MODE="$(echo "$SCREEN" | sed -n "/$CRITERION/{:a;N;/\*/!ba;/\*/p}" |
    awk 'match($0,/'$RE'/,a) {print a[1]"'$AES'"a[2]}')"

  [ -n "$MODE" ] && STATE+="$AES$MODE" || STATE+="$AES$AES"

  RE='^\s+([0-9]+x[0-9]+)\s.*\s([0-9][0-9]+.[0-9]{2})\*?\s?\+.*'

  local NATIVE="$(echo "$SCREEN" | sed -n "/$CRITERION/{:a;N;/\+/!ba;/\+/p}" |
    awk 'match($0,/'$RE'/,a) {print a[1]"@"a[2]"Hz"}')"
  
  [ -n "$NATIVE" ] && STATE+="$AES$NATIVE" || STATE+="$AES"

  local PROFILES="$(echo "$SCREEN" | awk '/'$CRITERION'/,!//' | tail -n +2 |
    sed -E 's/(\*|\+)//g' |
    awk -v AES="$AES" -v KVS="$KVS" '{
      if ($0 ~ /^\s+[0-9]+x[0-9]+/) {
        rates=""
        for (i=2; i<=NF; i++) {
          rates=rates $i AES
        }
        print $1 KVS rates
      } else exit
    }')"
  
  echo -e "$STATE\n$PROFILES"
}

index () {
  local NAME=$1

  local OUTPUTS="$(outputs)"
  local LEN=$(count "$OUTPUTS")

  local INDEX=""
  local I=0
  for ((I=0; I<$LEN; I++)); do
    local OUTPUT_NAME="$(element "$OUTPUTS" "$I" | value)"
    if [ "$NAME" = "$OUTPUT_NAME" ]; then
      INDEX=$I
      break
    fi
  done

  echo "$INDEX"
}

is_connected () {
  local OUTPUT=$1

  echo "$OUTPUT" | head -n 1 |
    awk '/'$AES'connected'$AES'/ {c=0;next} {c=1} END {exit c}'
}

is_active () {
  local OUTPUT=$1

  echo "$OUTPUT" | head -n 1 |
    awk '/'$AES'connected'$AES'(primary)?'$AES'[0-9]+x[0-9]+'$AES'/ {c=0;next} {c=1} END {exit c}'
}

is_primary () {
  local OUTPUT=$1

  echo "$OUTPUT" | head -n 1 |
    awk '/'$AES'primary'$AES'/ {c=0;next} {c=1} END {exit c}'
}

pick_output () {
  local STATUS=$1

  local OUTPUTS=$(outputs "$STATUS")
  local LEN=$(count "$OUTPUTS")

  if [ ! $LEN -gt 0 ]; then
    echo "No ${STATUS:-\b} outputs have been found"
    return 1
  fi
  
  pick_one "Select an output:" "$OUTPUTS"
}

pick_resolution () {
  local OUTPUT=$1

  local RESOLUTIONS="$(echo "$OUTPUT" |
    awk -F$KVS '{ORS="'$AES'";} {if ($0 ~ /^[0-9]+x[0-9]+/) {print $1}}')"

  local LEN=$(count "$RESOLUTIONS")

  if [ ! $LEN -gt 0 ]; then
    echo "No available resolutions have been found"
    return 1
  fi
  
  pick_one "Select a resolution:" "$RESOLUTIONS" "tabular-4"
}

pick_rate () {
  local OUTPUT=$1
  local RESOLUTION=$2

  local RATES="$(echo "$OUTPUT" |
    awk -F$KVS '/^[0-9]+x[0-9]+/{if ($1 == "'$RESOLUTION'") {print $2; exit}}')"

  local LEN=$(count "$RATES")

  if [ ! $LEN -gt 0 ]; then
    echo "No available refresh rates have been found"
    return 1
  fi
  
  pick_one "Select a refresh rate:" "$RATES" "tabular-4"
}

prompt () {
  local OUTPUTS="$(outputs primary)"
  local STATUS="$(element "$OUTPUTS" 0 | value)"

  read -rep "[displays:$YE${STATUS}$RS] " REPLY
}

show_status () {
  if [ -z "$DISPLAY" ]; then
    echo "Unable to resolve the display of xorg server"
    return 1
  fi

  local PATTERN='/^('
  PATTERN+='name\sof\sdisplay|'
  PATTERN+='version\snumber|'
  PATTERN+='vendor\sstring|'
  PATTERN+='vendor\srelease\snumber|'
  PATTERN+='X.Org\sversion|'
  PATTERN+='motion\sbuffer\ssize|'
  PATTERN+='image\sbyte\sorder|'
  PATTERN+='default\sscreen\snumber|'
  PATTERN+='number\sof\sscreens'
  PATTERN+=')/'

  xdpyinfo -display "$DISPLAY" |
    awk -F': ' $PATTERN'{ \
      gsub(/[ \t]+$/, "", $1); \
      gsub(/^[ \t]+/, "", $2); \
      printf "%-23s %s\n",$1":",$2 \
    }' | sed -r 's/\<./\U&/g'

  local OUTPUTS=$(outputs active)
  local LEN=$(count "$OUTPUTS")

  if [ $LEN = 0 ]; then
    echo "Active Outputs:         none"
    return
  fi

  echo "$OUTPUTS" | awk -F$AES '{
    out=$1; for(i=2;i<=NF;i++) if ($i) out=out ","$i;
    print "Active Outputs:         "out
  }'

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    echo

    local NAME="$(element "$OUTPUTS" "$INDEX" | value)"
    local OUTPUT="$(output "$NAME")"

    local FRM=""
    FRM+="Output: %s\n"
    FRM+="Mode:   %s@%sHz\n"
    FRM+="Area:   %s\n"
    FRM+="Pos:    %s\n"
    FRM+="RoRe:   %s %s\n"

    echo "$OUTPUT" | head -n 1 | awk -F$AES -v FRM="$FRM" '{
      if ($3) {$1=$1"*"};
      if (!$6) $6="normal";
      if (!$7) $7="normal";
      printf FRM,$1,$8,$9,$4,$5,$6,$7
    }'

    local NAME="$(echo "$OUTPUT" | head -n 1 | awk -F$AES '{print $1}')"
    if [ -f "$CONFIG_HOME/$NAME.color" ]; then
      local COLOR=`cat "$CONFIG_HOME/$NAME.color"`
      COLOR="$(value "$COLOR")"
      echo "Color:  $COLOR"
    fi
  done
}

show_output () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi

  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find output $NAME"
    return 1
  fi

  if ! is_connected "$OUTPUT"; then
    local FRM=""
    FRM+="Name:       %s\n"
    FRM+="Status:     %s\n"

    echo "$OUTPUT" | head -n 1 | awk -F$AES -v FRM="$FRM" '{printf FRM,$1,$2}'
    return
  fi

  if ! is_active "$OUTPUT"; then
    local FRM=""
    FRM+="Name:       %s\n"
    FRM+="Status:     %s\n"
    FRM+="Native:     %s\n"

    echo "$OUTPUT" | head -n 1 | awk -F$AES -v FRM="$FRM" '{printf FRM,$1,$2,$10}'
  else
    local FRM=""
    FRM+="Name:       %s\n"
    FRM+="Status:     %s\n"
    FRM+="Primary:    %s\n"
    FRM+="Resolution: %s\n"
    FRM+="Rate:       %sHz\n"
    FRM+="Rotate:     %s\n"
    FRM+="Reflect:    %s\n"
    FRM+="Area:       %s\n"
    FRM+="Position:   %s\n"
    FRM+="Native:     %s\n"

    echo "$OUTPUT" | head -n 1 | awk -F$AES -v FRM="$FRM" '{
      if ($3) {$3="true"} else {$3="false"};
      if (!$6) $6="normal";
      if (!$7) $7="normal";
      printf FRM,$1,$2,$3,$8,$9,$6,$7,$4,$5,$10
    }'
  fi

  local NAME="$(echo "$OUTPUT" | head -n 1 | awk -F$AES '{print $1}')"
  if [ -f "$CONFIG_HOME/$NAME.color" ]; then
    local COLOR=`cat "$CONFIG_HOME/$NAME.color"`
    COLOR="$(value "$COLOR")"
    echo "Color:      $COLOR"
  fi

  echo "$OUTPUT" | tail -n +2 | head -n 1 |
    awk -F$KVS '{gsub(/'$AES'/," ",$2); printf "Profiles:   %-9s %s\n",$1,$2}'
  echo "$OUTPUT" | tail -n +3 |
    awk -F$KVS '{gsub(/'$AES'/," ",$2); printf "            %-9s %s\n",$1,$2}'
}

list_outputs () {
  local STATUS=$1

  if [[ ! "$STATUS" =~ ^(|connected|disconnected|active|inactive|primary)$ ]]; then
    echo "Invalid output status argument"
    return 1
  fi

  local OUTPUTS=$(outputs "$STATUS")
  local LEN=$(count "$OUTPUTS")

  if [ ! $LEN -gt 0 ]; then
    echo "No ${STATUS:-\b} outputs have been found"
    return
  fi

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    [ $INDEX -gt 0 ] && echo

    local NAME=$(element "$OUTPUTS" "$INDEX" | value)
    show_output "$NAME"
  done
}

set_mode () {
  local NAME=$1
  local RESOLUTION=$2
  local RATE=$3

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi

  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find output $NAME"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot set mode of a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot set mode of an inactive"
    return 1
  fi

  if [ -z "$RESOLUTION" ]; then
    pick_resolution "$OUTPUT" || return 1
    [ -z "$REPLY" ] && return
    
    RESOLUTION=$(value "$REPLY")
  elif [[ ! "$RESOLUTION" =~ ^[0-9]+x[0-9]+$ ]]; then
    echo "Invalid resolution argument"
    return 1
  fi

  if [ -z "$RATE" ]; then
    pick_rate "$OUTPUT" "$RESOLUTION" || return 1
    [ -z "$REPLY" ] && return
    
    RATE=$(value "$REPLY")
  elif [[ ! "$RATE" =~ ^[0-9][0-9]+.[0-9][0-9]$ ]]; then
    echo "Invalid refresh rate argument"
    return 1
  fi

  xrandr --output "$NAME" --mode "$RESOLUTION" --rate "$RATE" &&
    echo "Output $NAME mode set to $RESOLUTION" ||
    echo "Failed to set mode of output $NAME"
}

set_primary () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find output $NAME"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot set primary a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot set primary an inactive output"
    return 1
  elif is_primary "$OUTPUT"; then
    echo "Output $NAME is already the primary"
    return 1
  fi

  xrandr --output "$NAME" --primary &&
    echo "Output $NAME has been set as primary" ||
    echo "Failed to set output $NAME as primary"
}

set_on () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output inactive || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find output $NAME"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot activate a disconnected output"
    return 1
  elif is_active "$OUTPUT"; then
    echo "Output $NAME is already active"
    return 1
  fi

  xrandr --output "$NAME" --auto &&
    echo "Output $NAME has been activated" ||
    echo "Failed to activate output $NAME"
}

set_off () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find output $NAME"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot deactivate a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Output $NAME is already inactive"
    return 1
  elif is_primary "$OUTPUT"; then
    echo "Cannot deactivate the primary output"
    return 1
  fi

  xrandr --output "$NAME" --off &&
    echo "Output $NAME has been deactivated" ||
    echo "Failed to deactivate output $NAME"
}

reflect () {
  local NAME=$1
  local MODE=$2

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find output $NAME"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot reflect a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot reflect an inactive output"
    return 1
  fi

  if [ -z "$MODE" ]; then
    local MODES=""
    MODES+="Normal${KVS}normal${AES}"
    MODES+="X${KVS}x${AES}"
    MODES+="Y${KVS}y${AES}"
    MODES+="XY${KVS}xy"

    pick_one "Select a reflection mode:" "$MODES"
    [ -z "$REPLY" ] && return
    
    MODE=$(value "$REPLY")
  fi
  
  if [[ ! "$MODE" =~ ^(normal|x|y|xy)$ ]]; then
    echo "Invalid reflection mode argument"
    return 1
  fi

  xrandr --output "$NAME" --reflect "$MODE" &&
    echo "Output $NAME has been reflected to $MODE mode" ||
    echo "Failed to reflect output $NAME"
}

rotate () {
  local NAME=$1
  local MODE=$2

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find output $NAME"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot reflect a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot reflect an inactive output"
    return 1
  fi

  if [ -z "$MODE" ]; then
    local MODES=""
    MODES+="Normal${KVS}normal${AES}"
    MODES+="Right${KVS}right${AES}"
    MODES+="Left${KVS}left${AES}"
    MODES+="Inverted${KVS}inverted"

    pick_one "Select a rotation mode:" "$MODES"
    [ -z "$REPLY" ] && return
    
    MODE=$(value "$REPLY")
  fi
  
  if [[ ! "$MODE" =~ ^(normal|right|left|inverted)$ ]]; then
    echo "Invalid rotation mode argument"
    return 1
  fi

  xrandr --output "$NAME" --rotate "$MODE" &&
    echo "Output $NAME has been rotated to $MODE mode" ||
    echo "Failed to rotate output $NAME"
}

mirror () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    local ACTIVE="$(outputs active)"
    local ACTIVE_LEN="$(count "$ACTIVE")"
    
    if [ $ACTIVE_LEN = 0 ]; then
      echo "Unable to find active outptus"
      return 1
    elif [ $ACTIVE_LEN = 1 ]; then
      echo "Cannot set mirror for one active output"
      return 1
    fi

    pick_one "Select which output to mirror:" "$ACTIVE" || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi

  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find output $NAME"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot mirror a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot mirror an inactive output"
    return 1
  fi

  local OTHERS="$(outputs active | sed -E "s/${NAME}(${AES})?//g")"
  local OTHERS_LEN=$(count "$OTHERS")

  local MIRRORS=""

  if [ $OTHERS_LEN = 0 ]; then
    echo "Cannot set mirror mode for one active output"
    return 1
  elif [ $OTHERS_LEN = 1 ]; then
    MIRRORS="$OTHERS"
  else
    pick_many "Select on which outputs to mirror $NAME:" "${OTHERS}" 1 "$OTHERS_LEN" || return 1
    [ -z "$REPLY" ] && return

    MIRRORS="$REPLY"
  fi

  local MODES="$(echo "$OUTPUT" | tail -n +2 | awk -F$KVS '{ORS="'$AES'";} {print $1}')"

  local I=0
  local MIRRORS_LEN=$(count "$MIRRORS")
  for ((I=0; I<$MIRRORS_LEN; I++)); do
    local MIRROR_NAME="$(element "$MIRRORS" "$I" | value)"
    local MIRROR="$(output "$MIRROR_NAME")"
    local MIRROR_MODES="$(echo "$MIRROR" | tail -n +2 | awk -F$KVS '{ORS="'$AES'";} {print $1}')"

    local SHARED=""
    local K=0
    local MODES_LEN=$(count "$MODES")
    for ((K=0; K<$MODES_LEN; K++)); do
      local MODE=$(element "$MODES" "$K" | value)

      if [[ "$MIRROR_MODES" =~ "$MODE" ]]; then
        SHARED+=$MODE$AES
      fi
    done

    MODES=$SHARED
  done

  local MODES_LEN=$(count "$MODES")
  local MODE=""

  if [ $MODES_LEN = 0 ]; then
    echo "Unable to mirror, mirrors do not share common modes"
    return 1
  elif [ $MODES_LEN = 1 ]; then
    MODE=$MODES
    [[ "$MODE" =~ .*${AES}$ ]] && MODE="${MODE::-${#AES}}"
  else
    pick_one "Select the mirroring resolution:" "$MODES" "tabular-4" || return 1
    [ -z "$REPLY" ] && return

    MODE="$(value "$REPLY")"
  fi

  local POS=$(echo "$OUTPUT" | head -n 1 | awk -F$AES '{print $5}')
  local ARGS="--output $NAME --mode $MODE --pos $POS --rotate normal --reflect normal"

  local I=0
  for ((I=0; I<$MIRRORS_LEN; I++)); do
    local MIRROR_NAME="$(element "$MIRRORS" "$I" | value)"
    ARGS+=" --output $MIRROR_NAME --mode $MODE --pos $POS --rotate normal --reflect normal"
  done

  xrandr $ARGS &&
    echo "Output $NAME has been mirrored successfully" ||
    echo "Failed to mirror output $NAME"
}

pick_layout () {
  local OUTPUTS=$1

  local LAYOUTS=""

  if [ $OUTPUTS = 2 ]; then
    LAYOUTS+="SideBySide${KVS}row-2${AES}"
    LAYOUTS+="TopBottom${KVS}col-2"

    echo "SideBySide  TopBottom"
    echo "----------  ----------"
    echo "[A][B]      [A]"
    echo "            [B]"
    echo
  elif [ $OUTPUTS = 3 ]; then
    LAYOUTS+="SideBySide${KVS}row-3${AES}"
    LAYOUTS+="TopBottom${KVS}col-3${AES}"
    LAYOUTS+="LeftGamma${KVS}gamma-3${AES}"
    LAYOUTS+="RightGamma${KVS}gamma-rev-3${AES}"
    LAYOUTS+="LeftLambda${KVS}lambda-3${AES}"
    LAYOUTS+="RightLambda${KVS}lambda-rev-3"

    echo "SideBySide  TopBottom   LeftGamma"
    echo "----------  ----------  -----------"
    echo "[A][B][C]   [A]         [A][B]"
    echo "            [B]         [C]"
    echo "            [C]"
    echo
    echo "RightGamma  LeftLambda  RightLambda"
    echo "----------  ----------  -----------"
    echo "[A][B]      [A]            [A]"
    echo "   [C]      [B][C]      [B][C]"
    echo
  else
    return 1
  fi

  pick_one "Select a layout mode:" "$LAYOUTS" "tabular-3"
}

set_layout () {
  local OUTPUTS=$(outputs active)
  local LEN=$(count "$OUTPUTS")

  if [ $LEN = 0 ]; then
    echo "No active outputs have been found"
    return
  elif [ $LEN = 1 ]; then
    echo "Cannot set layout for one active output"
    return
  elif [ $LEN -gt 3 ]; then
    echo "No layout options found for more than 3 active outputs"
    return
  fi

  pick_layout "$LEN" || return 1
  [ -z "$REPLY" ] && return

  local LAYOUT=$(value "$REPLY")

  local SPOTS=$(echo "$LEN" | awk '{for(i=65; i<65+$0; i++) printf "%c,",i}')

  pick_many "Pick outputs by order to match ${SPOTS::-1}:" "$OUTPUTS" "$LEN" "$LEN"
  [ -z "$REPLY" ] && return

  local A=$(element "$REPLY" 0 | value)
  local B=$(element "$REPLY" 1 | value)
  if [ $LEN = 3 ]; then
    local C=$(element "$REPLY" 2 | value)
  fi

  case "$LAYOUT" in
    "row-2")
      xrandr --output "$A" --left-of "$B";;
    "col-2")
      xrandr --output "$A" --above "$B";;
    "row-3")
      xrandr --output "$A" --left-of "$B" --output "$B" --left-of "$C";;
    "col-3")
      xrandr --output "$A" --above "$B" --output "$B" --above "$C";;
    "gamma-3")
      xrandr --output "$A" --left-of "$B" --output "$C" --below "$A";;
    "gamma-rev-3")
      xrandr --output "$A" --left-of "$B" --output "$C" --below "$B";;
    "lambda-3")
      xrandr --output "$A" --above "$B" --output "$B" --left-of "$C";;
    "lambda-rev-3")
      xrandr --output "$A" --left-of "$C" --output "$A" --above "$C";;
  esac

  if [ ! $? = 0 ]; then
    echo "Failed to set layout mode"
    return 1
  fi

  echo "Layout has been set successfully"
}

save_layout () {
  local OUTPUTS=$(outputs)
  local LEN=$(count "$OUTPUTS")
  
  if [ $LEN = 0 ]; then
    echo "Unable to save layout, no outputs have found"
    return 1
  fi

  if [ -f "$LAYOUT_FILE" ]; then
    confirm "Should overwrite existing layout?"
    [ -z "$REPLY" ] && return
    [ "$(value "$REPLY")" = "no" ] && return
  fi

  mkdir -p "$CONFIG_HOME"
  rm -f "$LAYOUT_FILE"

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    local NAME=$(element "$OUTPUTS" "$INDEX" | value)
    local OUTPUT=$(output "$NAME")

    echo "$OUTPUT" | head -n 1 >> "$LAYOUT_FILE"
  done

  echo "Layout has been saved successfully"
}

load_layout () {
  if [ ! -f "$LAYOUT_FILE" ]; then
    echo "Unable to load layout, no layout file found"
    return
  fi

  local ARGS=$(awk -F$AES '{
    if ($2 == "connected" && $4) {
      if (!$6) $6="normal";
      if (!$7) $7="normal";
      args="--output "$1" --mode "$8" --rate "$9" --pos "$5" --rotate "$6" --reflect "$7
      if ($3 == "primary") args=args" --primary"
      print args
    } else {
      print "--output "$1" --off"
    }
  }' "$LAYOUT_FILE" | tr $'\n' ' ')

  xrandr $ARGS && echo "Displays layout loaded successfully"

  if [ ! $? = 0 ]; then
    echo "Failed to load the displays layout"
    return 1
  fi
}

set_color () {
  local NAME=$1
  local COLOR=$2

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find output $NAME"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot set color profile of a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot set color profile of an inactive output"
    return 1
  fi

  if [ -z "$COLOR" ]; then
    local COLORS="$(ls /usr/share/color 2>/dev/null | awk '{ORS="'$AES'";} /.ic(c|m)$/')"
    local COLORS_LEN=$(count "$COLORS")

    if [ ! $COLORS_LEN -gt 0 ]; then
      echo "No available color profiles have found"
      return 1
    fi

    pick_one "Select a color profile:" "$COLORS" "vertical-4" || return 1
    [ -z "$REPLY" ] && return

    COLOR="$(value "$REPLY")"
  fi

  local INDEX="$(index "$NAME")"
  local RESULT="$(xcalib -d "$DISPLAY" -s 0 -o "$INDEX" "/usr/share/color/$COLOR" 2>&1)"

  if [ -n "$RESULT" ]; then
    echo "Failed to set color profile $COLOR"
    return 1
  fi

  echo "Color profile of $NAME set to $COLOR"

  confirm "Do you want to persist color profile?"
  [ -z "$REPLY" ] && return
  [ "$(value "$REPLY")" = "no" ] && return

  mkdir -p "$CONFIG_HOME"
  echo "$INDEX${KVS}$COLOR" > "$CONFIG_HOME/$NAME.color"
  echo "Profile saved to $CONFIG_HOME/$NAME.color"
}

reset_color () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find output $NAME"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot reset color profile of a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot reset color profile of an inactive output"
    return 1
  fi

  local INDEX="$(index "$NAME")"
  local RESULT="$(xcalib -d "$DISPLAY" -s 0 -o "$INDEX" -c 2>&1)"

  if [ -n "$RESULT" ]; then
    echo "Failed to reset color profile"
    return 1
  fi

  rm -f "$CONFIG_HOME/$NAME.color"
  echo "Color profile of $NAME reset to default"
}

load_colors () {
  local COUNT=$(ls -1 $CONFIG_HOME/*.color 2>/dev/null | wc -l)

  if [ ! $COUNT -gt 0 ]; then
    echo "No color files found, operation is skipped"
    return
  fi

  local COLORS=($(ls $CONFIG_HOME/*.color))

  local FAILURES=()
  local I=0
  for ((I=0; I<${#COLORS[@]}; I++)); do
    local COLOR_FILE="${COLORS[I]}"
    local COLOR=`cat "$COLOR_FILE"`
    local INDEX="$(key "$COLOR")"
    local FILE_NAME="$(value "$COLOR")"

    local RESULT="$(xcalib -d "$DISPLAY" -s 0 -o "$INDEX" "/usr/share/color/$FILE_NAME" 2>&1)"

    if [ -n "$RESULT" ]; then
      echo "Failed to load color profile $COLOR_FILE"
      FAILURES+=("$COLOR_FILE")
    else
      echo "Color profile $COLOR_FILE has been loaded"
    fi
  done

  if [ ${#FAILURES[@]} -gt 0 ]; then
    return 1
  fi
}

help () {
  if [ "$1" = "once" ]; then
    echo "Usage: displays COMMAND [OBJECT] [ARGUMENTS]..."

    echo -e "\nCOMMANDS"
    printf " %-12s\t%s\n" \
      "help" "Show this message." \
      "load layout" "Load the default displays layout." \
      "load colors" "Load displays profile colors."

    return
  fi

  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf " %-32s\t%s\n" \
    "help" "Show this help message." \
    "show status" "Show a report of the xorg server and active outputs." \
    "show output [<name>]" "Show the data of the given output." \
    "" "" \
    "list outputs [<status>]" "List all outputs or by the given status," \
    "" "connected, disconnected, active, inactive or primary." \
    "" "" \
    "set mode [<name> [<res> [<rate>]]]" "Set the mode of the given output." \
    "set primary [<name>]" "Set the given output as primary." \
    "set on|off [<name>]" "Set active or inactive the given output." \
    "" "" \
    "rotate [<name> [<mode>]]" "Set output rotation to normal, right, left or inverted." \
    "reflect [<name> [<mode>]]" "Set output reflection to normal, x, y or xy axes." \
    "mirror [<name>]" "Mirror the given active output to other outputs." \
    "" "" \
    "set color [<name> [<profile>]]" "Set the color profile of the given output." \
    "reset color [<name>]" "Reset the color profile of the given output." \
    "" "" \
    "set layout" "Set the layout of active outputs." \
    "save layout" "Persist the current displays layout to disk." \
    "restore layout" "Restore the displays layout from disk."
}

loop () {
  clear

  while true; do
    prompt && history -s "$REPLY"

    set -f
    set_separator "line"
    local CMD=($(xargs -n1 <<< "$REPLY"))
    restore_separator && set +f

    if [ "${CMD[0]}" = "help" ]; then
      help
      continue
    elif [ "${CMD[0]}" = "clear" ]; then
      clear
      continue
    elif [ "${CMD[0]}" = "quit" ]; then
      break
    elif [ -z "${CMD[0]}" ]; then
      continue
    fi

    case "${CMD[0]}" in
      "show")
        case "${CMD[1]}" in
          "status") show_status;;
          "output") show_output "${CMD[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "list")
        case "${CMD[1]}" in
          "outputs") list_outputs "${CMD[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "set")
        case "${CMD[1]}" in
          "layout") set_layout;;
          "mode") set_mode "${CMD[2]}" "${CMD[3]}" "${CMD[4]}";;
          "primary") set_primary "${CMD[2]}";;
          "on") set_on "${CMD[2]}";;
          "off") set_off "${CMD[2]}";;
          "color") set_color "${CMD[2]}" "${CMD[3]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "reset")
        case "${CMD[1]}" in
          "color") reset_color "${CMD[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "save")
        case "${CMD[1]}" in
          "layout") save_layout;;
          *) echo "Invalid or unknown command";;
        esac;;
      "restore")
        case "${CMD[1]}" in
          "layout") load_layout;;
          *) echo "Invalid or unknown command";;
        esac;;
      "rotate") rotate "${CMD[1]}" "${CMD[2]}";;
      "reflect") reflect "${CMD[1]}" "${CMD[2]}";;
      "mirror") mirror "${CMD[1]}";;
      *) echo "Invalid or unknown command";;
    esac
  done

  clear
}

once () {
  case "$1" in
    "help") help once;;
    "load")
      case "$2" in
        "layout") load_layout || abort;;
        "colors") load_colors || abort;;
        *) abort "Invalid or unknown command";;
      esac;;
    *) abort "Invalid or unknown command";;
  esac
}

if [ $# = 0 ]; then
  loop
else
  once "$@"
fi
