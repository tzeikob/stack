#!/bin/bash

set -o pipefail
source /opt/stack/utils

SETTINGS_FILE="${CONFIG_HOME}/desktop.json"

# Returns the list of any wallpapers found under
# the wallpapers home.
# Globals:
#  WALLPAPERS_HOME
# Arguments:
#  None
# Outputs:
#  A json array of image objects.
find_wallpapers () {
  if [[ ! -d  "${WALLPAPERS_HOME}" ]]; then
    echo '[]'
    return 0
  fi

  local wallpaper=''
  wallpaper+='"\"name\": \""$1"\","'
  wallpaper+='"\"type\": \""$2"\","'
  wallpaper+='"\"resolution\": \""$3"\","'
  wallpaper+='"\"bit\": \""$5"\","'
  wallpaper+='"\"color\": \""$6"\","'
  wallpaper+='"\"size\": \""$7"\""'
  wallpaper="\"{\"${wallpaper}\"},\""

  local wallpapers=''
  wallpapers="$(identify -quiet "${WALLPAPERS_HOME}/*" 2> /dev/null |
    awk '{
      if ($1 ~ /.(jpg|jpeg|png)$/) {
        n=split($1,a,"/")
        $1=a[n]
        print '"${wallpaper}"'
      }
    }'
  )"
  
  # Remove the extra comma after the last array element
  if [[ -n "${wallpapers}" ]]; then
    wallpapers="${wallpapers::-1}"
  fi

  echo "[${wallpapers}]"
}

# Shows a menu asking the user to select one wallpaper,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of wallpaper filenames.
pick_wallpaper () {
  local query='{key: .name, value: "\(.name) [\(.resolution)]"}'
  query="[.[]|${query}]"

  local wallpapers=''
  wallpapers="$(find_wallpapers | jq -cer "${query}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find wallpaper files"
    return 2
  fi

  local len=0
  len="$(count "${wallpapers}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No wallpaper files have found"
    return 2
  fi

  pick_one "Select a wallpaper:" "${wallpapers}" "vertical" || return $?
}

# Returns the list of pointing devices currently
# connected to the system.
# Arguments:
#  None
# Outputs:
#  A json array of pointing device objects.
find_pointers () {
  local pointers=''
  pointers="$(xinput --list | awk '{
    if ($0 ~ "Virtual core pointer") {
      next
    } else if ($0 ~ "Virtual core keyboard") {
      exit
    }

    match($0, ".*â†³ (.*)id=([0-9]+).*", a)
    gsub(/^[ \t]+/,"",a[1])
    gsub(/[ \t]+$/,"",a[1])
    gsub(/^[ \t]+/,"",a[2])
    gsub(/[ \t]+$/,"",a[2])

    schema="\"id\": \"%s\","
    schema=schema"\"name\": \"%s\""
    schema="{"schema"},"

    printf schema, a[2], a[1]
  }')" || return 1

  # Remove the extra comma after the last element
  if [[ -n "${pointers}" ]]; then
    pointers="${pointers::-1}"
  fi

  echo "[${pointers}]"
}

# Returns the pointing device with the given id.
# Arguments:
#  id: the id of the pointing device
# Outputs:
#  A json object of pointing device.
find_pointer () {
  local id="${1}"

  local name=''
  name="$(find_pointers |
    jq -cer ".[]|select(.id == \"${id}\")|.name")" || return 1

  local pointer=''
  pointer+="\"id\":\"${id}\","
  pointer+="\"name\":\"${name}\","

  pointer+="$(xinput --list-props "${id}" | awk '{
    match($0, "(.*)\\([0-9]{3}\\):(.*)", a)
    gsub(/^[ \t]+/,"",a[1])
    gsub(/[ \t]+$/,"",a[1])
    gsub(/^[ \t]+/,"",a[2])
    gsub(/[ \t]+$/,"",a[2])
    key=a[1];value=a[2]

    if (key == "Device Node") {
      key="node"
      gsub(/"/,"",value)
    } else if (key == "Device Enabled") {
      key="enabled"
    } else if (key == "libinput Accel Speed") {
      key="accel_speed"
    } else if (key == "libinput Accel Profile Enabled") {
      key="accel"
    } else if (key == "Device Accel Constant Deceleration") {
      key="const_decel"
    } else if (key == "Device Accel Adaptive Deceleration") {
      key="adapt_decel"
    } else if (key == "Device Accel Velocity Scaling") {
      key="velocity"
    } else {
      next
    }

    print "\""key"\":\""value"\","
  }')" || return 1

  # Remove the extra comma after the last element
  if [[ -n "${pointer}" ]]; then
    pointer="${pointer::-1}"
  fi

  echo "{${pointer}}"
}

# Shows a menu asking the user to select one pointing device,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of pointing devices.
pick_pointer () {
  local pointers=''
  pointers="$(find_pointers)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find pointers"
    return 2
  fi

  local len=0
  len="$(count "${pointers}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No pointers have found"
    return 2
  fi

  local query='[.[]|{key: .id, value: "\(.id):\(.name)"}]'
  pointers="$(echo "${pointers}" | jq -cer "${query}")" || return 1

  pick_one "Select a pointer:" "${pointers}" "vertical" || return $?
}

# Returns the list of stylus-pen devices currently
# connected to the system.
# Arguments:
#  None
# Outputs:
#  A json array of stylus-pen device objects.
find_tablets () {
  local tablets=''
  tablets="$(xsetwacom --list devices | awk '{
    match($0, "(.*)id:(.*)type:(.*)", a)
    gsub(/^[ \t]+/,"",a[1])
    gsub(/[ \t]+$/,"",a[1])
    gsub(/^[ \t]+/,"",a[2])
    gsub(/[ \t]+$/,"",a[2])
    gsub(/^[ \t]+/,"",a[3])
    gsub(/[ \t]+$/,"",a[3])

    schema="\"id\": \"%s\","
    schema=schema"\"name\": \"%s\","
    schema=schema"\"type\": \"%s\","
    schema=schema"\"vendor\": \"wacom\""
    schema="{"schema"},"

    printf schema, a[2], a[1], a[3]
  }')" || return 1

  # Remove the extra comma after the last element
  if [[ -n "${tablets}" ]]; then
    tablets="${tablets::-1}"
  fi

  echo "[${tablets}]"
}

# Returns the tablet device with the given name.
# Arguments:
#  name: the name of the tablet device
# Outputs:
#  A json object of tablet device.
find_tablet () {
  local name="${1}"

  local query=".[]|select(.name == \"${name}\")"

  local tablet=''
  tablet="$(find_tablets | jq -cer "${query}")" || return 1

  local vendor=''
  vendor="$(get "${tablet}" '.vendor')" || return 1

  # Merge properties specific to wacom devices
  if [[ "${vendor}" == "wacom" ]]; then
    local props=''
    props="$(xsetwacom --get "${name}" all 2>&1 | awk '/^Option/{
      match($0, "Option \"(.*)\" \"(.*)\"", a)
      print "\""a[1]"\": \""a[2]"\","
    }')" || return 1

    # Remove the extra comma after the last key/value pair
    if [[ -n "${props}" ]]; then
      props="${props::-1}"
    fi

    tablet="$(echo "${tablet}" | jq -cer --argjson p "{${props}}" '. + $p')" || return 1
  fi

  echo "${tablet}"
}

# Checks if the given name corresponds to an
# existing tablet device.
# Arguments:
#  name: the name of a tablet device
# Returns:
#  0 if it is a tablet otherwise 1.
is_tablet () {
  local name="${1}"

  local query=".[]|select(.name == \"${name}\")"

  local tablet=''
  tablet="$(find_tablets | jq -cer "${query}")" || return 1

  if [[ -n "${tablet}" ]]; then
    return 0
  else
    return 1
  fi
}

# Checks if the tablet device with the given name
# has a scalable and mappable area.
# Arguments:
#  name: the name of a tablet device
# Returns:
#  0 if it is scalable otherwise 1.
is_scalable () {
  local name="${1}"

  local area=''
  area="$(find_tablet "${name}" | jq -cer '.Area')" || return 1

  if [[ -n "${area}" ]]; then
    return 0
  else
    return 1
  fi
}

# Shows a menu asking the user to select one tablet device,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of tablet devices.
pick_tablet () {
  local tablets=''
  tablets="$(find_tablets)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find tablets"
    return 2
  fi

  local len=0
  len="$(count "${tablets}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No tablets have found"
    return 2
  fi

  local query='[.[]|{key: .name, value: .name}]'
  tablets="$(echo "${tablets}" | jq -cer "${query}")" || return 1

  pick_one "Select a tablet:" "${tablets}" "vertical" || return $?
}

# START: TO BE REMOVED AS DUPS IN DISPLAYS

# Returns a list of outputs having the given status.
# Arguments:
#  status: all, connected, disconnected, active,
#          inactive, primary
# Outputs:
#  A json array of outputs.
find_outputs () {
  local status="${1:-"all"}"

  local states='all|connected|disconnected|active|inactive|primary'
  if [[ ! "${status}" =~ ^(${states})$ ]]; then
    return 1
  fi

  local criteria='true'
  if [[ "${status}" == "connected" ]]; then
    criteria='.is_connected == true'
  elif [[ "${status}" == "disconnected" ]]; then
    criteria='.is_connected == false'
  elif [[ "${status}" == "active" ]]; then
    criteria='.is_connected == true and .resolution_width != null'
  elif [[ "${status}" == "inactive" ]]; then
    criteria='.is_connected == true and .resolution_width == null'
  elif [[ "${status}" == "primary" ]]; then
    criteria='.is_primary == true'
  fi

  local a=''
  a+='.screens[]|select(.screen_number==0)'
  a+=" |.associated_device|select(${criteria})"
  a="[${a}]"

  local b=''
  b+=".unassociated_devices[]|select(${criteria})"
  b="[${b}]"

  local query="[${a}+${b}|to_entries[]|{index: .key} + .value]"

  xrandr --props | jc --xrandr | jq -cer "${query}" || return 1
}

# Returns the output with the given name.
# Arguments:
#  name: any string
# Outputs:
#  A json object of output.
find_output () {
  local name="${1}"

  local query=".[]|select(.device_name == \"${name}\")"

  find_outputs "all" | jq -cer "${query}" || return 1
}

# Asserts if the given output is active.
# Arguments:
#  output: a json object output
# Returns:
#  0 if is active otherwise 1.
is_active () {
  local output="${1}"

  local query='select(.is_connected and .resolution_width)'

  echo "${output}" | jq -cer "${query}" &> /dev/null || return 1
}

# Shows a menu asking the user to select one output, where the
# answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  prompt: a prompt text line
#  status: all, connected, disconnected, active,
#          inactive, primary
# Outputs:
#  A menu of output names.
pick_output () {
  local prompt="${1}"
  local status="${2}"

  # Convert outputs list into an array of {key, value} options
  local key='\(.device_name)'
  local value='\(.device_name):[\(if .model_name then .model_name else "NA" end)]'

  local query="[.[]|{key: \"${key}\", value: \"${value}\"}]"
  query+='|. + [{key: "desktop", value: "ALL:[DESKTOP]"}]'

  local options=''
  options="$(find_outputs "${status}" | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${options}")" || return 1
  
  if [[ ${len} -eq 0 ]]; then
    echo "No ${status:-\b} outputs have found"
    return 2
  fi

  pick_one "${prompt}" "${options}" "vertical" || return $?
}

# END: TO BE REMOVED AS DUPS IN DISPLAYS

# Shows a prompt status and asks user to enter the
# next command, which is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A minimal prompt status line.
prompt () {
  read -rep "[desktop:ready] " REPLY
}

# Shows the current status of the desktop environment.
# Globals:
#  SETTINGS_FILE
# Arguments:
#  None
# Outputs:
#  A verbose list of text data.
show_status () {
  local status=''

  local server=''
  server="$(xdpyinfo -display "${DISPLAY}" | awk -F': ' '{
    ORS=""
    gsub(/^[ \t]+/,"",$2)
    gsub(/[ \t]+$/,"",$2)
    switch ($1) {
      case "version number": print $2; break
      case "X.Org version": print "/"$2")"; break
      default: break
    }
  }')" || return 1
  status+="\"server\": \"Xorg ${server::-1}\","

  local compositor=''
  compositor="$(pacman -Qi picom | grep -Po '^Version\s*: \K.+')" || return 1
  status+="\"compositor\": \"Picom ${compositor}\","

  local wm=''
  wm="$(bspwm -v)" || return 1
  status+="\"wm\": \"BSPWM ${wm}\","

  local bars=''
  bars="$(polybar -v | head -n +1 | cut -d ' ' -f 2)" || return 1
  status+="\"bars\": \"Polybar ${bars}\","

  if [[ -f "${SETTINGS_FILE}" ]]; then
    local query='.wallpaper|if . then "\(.name) [\(.mode|ascii_upcase)]" else "none" end'
    local wallpaper=''
    wallpaper="$(jq -cr "${query}" "${SETTINGS_FILE}")" || return 1
    status+="\"wallpaper\": \"${wallpaper}\","
  fi

  local fields='OS|Kernel|Shell|Theme|Icons'
  status+="$(neofetch --off --stdout |
    awk -F':' '/^('"${fields}"')/{
      gsub(/^[ \t]+/,"",$2)
      gsub(/[ \t]+$/,"",$2)
      printf "\"%s\":\"%s\",",tolower($1),$2
    }'
  )" || return 1

  # Remove the last extra comma after the last field
  if [[ -n "${status}" ]]; then
    status="${status::-1}"
  fi

  status="{${status}}"

  local query=''
  query+='OS:          \(.os)\n'
  query+='Kernel:      \(.kernel)\n'
  query+='Shell:       \(.shell)\n'
  query+='Server:      \(.server)\n'
  query+='Compositor:  \(.compositor)\n'
  query+='WM:          \(.wm)\n'
  query+='Bars:        \(.bars)\n'
  query+='Theme:       \(.theme)\n'
  query+='Icons:       \(.icons)\n'
  query+='Wallpaper:   \(if .wallpaper then .wallpaper else "none" end)'

  echo "${status}" | jq -cer "\"${query}\"" || return 1
}

# show the list of all the wallpapers found under
# the wallpapers home.
# Arguments:
#  None
# Outputs:
#  A list of wallpaper data.
list_wallpapers () {
  local wallpapers=''
  wallpapers="$(find_wallpapers)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find wallpaper files"
    return 2
  fi

  local len=0
  len="$(count "${wallpapers}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No wallpaper files have found"
    return 2
  fi

  local query=''
  query+='Name:        \(.name)\n'
  query+='Type:        \(.type)\n'
  query+='Color:       \(.color) \(.bit)\n'
  query+='Size:        \(.size)\n'
  query+='Resolution:  \(.resolution)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${wallpapers}" | jq -cer "${query}" || return 1
}

# Sets the desktop wallpaper to the wallpaper with the given
# file name and scale mode.
# Globals:
#  REPLY, WALLPAPERS_HOME, SETTINGS_FILE, CONFIG_HOME
# Arguments:
#  name:    the filename of the wallpaper
#  mode:    center, fill, max, scale or tile
#  persist: save or nosave, default is save
set_wallpaper () {
  local name="${1}"
  local mode="${2}"
  local persist="${3:-"save"}"

  if [[ -z "${name}" ]]; then
    pick_wallpaper || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if [[ "${name}" =~ /+ ]]; then
    echo "Invalid wallpaper name"
    return 2
  fi

  name="$(basename "${name}")"
  local wallpaper_file="${WALLPAPERS_HOME}/${name}"

  if [[ ! "${wallpaper_file}" =~ .+\.(jpg|jpeg|png)$ ]]; then
    echo "Invalid wallpaper file type"
    return 2
  elif [[ ! -f "${wallpaper_file}" ]]; then
    echo "No wallpaper found with name ${name}"
    return 2
  fi

  if [[ -z "${mode}" ]]; then
    local modes=''
    modes+='{"key": "center", "value": "Center"},'
    modes+='{"key": "fill", "value": "Fill"},'
    modes+='{"key": "max", "value": "Max"},'
    modes+='{"key": "scale", "value": "Scale"},'
    modes+='{"key": "tile", "value": "Tile"}'
    modes="[${modes}]"

    pick_one "Select a mode:" "${modes}" "vertical" || return $?
    [[ -n "${REPLY}" ]] && mode="${REPLY}" || return 0
  fi
  
  if [[ ! "${mode}" =~ ^(center|fill|max|scale|tile)$ ]]; then
    echo "Invalid wallpaper mode"
    return 2
  fi

  feh --no-fehbg --bg-"${mode}" "${wallpaper_file}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to set wallpaper"
    return 2
  fi

  echo "Wallpaper has been set to ${name}"

  # Save wallpaper into settings file
  if [[ "${persist}" == "save" ]]; then
    local settings='{}'
    local wallpaper="{\"name\": \"${name}\", \"mode\": \"${mode}\"}"

    if [[ -f "${SETTINGS_FILE}" ]]; then
      settings="$(jq -e ".wallpaper = ${wallpaper} " "${SETTINGS_FILE}")" || return 1
    else
      settings="$(echo "{\"wallpaper\": ${wallpaper}}" | jq -e '.')" || return 1
    fi

    mkdir -p "${CONFIG_HOME}"
    echo "${settings}" > "${SETTINGS_FILE}"
  fi
}

# Show the data of the pointing device with the
# given id.
# Globals:
#  REPLY
# Arguments:
#  id: the id of the pointing device
# Outputs:
#  A long list of pointing device data.
show_pointer () {
  local id="${1}"

  if [[ -z "${id}" ]]; then
    pick_pointer || return $?
    [[ -n "${REPLY}" ]] && id="${REPLY}" || return 0
  fi

  local pointer=''
  pointer="$(find_pointer "${id}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find pointer ${id}"
    return 2
  fi

  local query=''
  query+='ID:          \(.id)\n'
  query+='Name:        \(.name)'
  query+='\(.node|if . then "\nNode:        \(.)" else "" end)'
  query+='\(.enabled|if . then "\nEnabled:     \(.)" else "" end)'
  query+='\(.accel_speed|if . then "\nSpeed:       \(.)" else "" end)'
  query+='\(.accel|if . then "\nAccel:       \(.)" else "" end)'
  query+='\(.velocity|if . then "\nVelocity:    \(.)" else "" end)'
  query+='\(if .const_decel then "\nDecel:       \(.const_decel) \(.adapt_decel)" else "" end)'

  echo "${pointer}" | jq -cer "\"${query}\"" || return 1
}

# Shows the list of pointing devices currently
# connected to the system.
# Arguments:
#  None
# Outputs:
#  A list of pointing devices.
list_pointers () {
  local pointers=''
  pointers="$(find_pointers)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find pointers"
    return 2
  fi

  local len=0
  len="$(count "${pointers}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No pointers have found"
    return 0
  fi

  local query=''
  query+='ID:    \(.id)\n'
  query+='Name:  \(.name)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${pointers}" | jq -cer "${query}" || return 1
}

# Sets the acceleration speed of every pointing device
# to the given speed factor, where 0 means slow and 1
# means fast.
# Globals:
#  REPLY
# Arguments:
#  factor:  a speed factor between [0, 1]
#  persist: save or nosave, default is save
set_pointer_speed () {
  local factor="${1}"
  local persist="${2:-"save"}"

  if [[ -z "${factor}" ]]; then
    ask "Enter the speed factor [0,1]:" "^[0-9]+\.?[0-9]*$" || return $?
    factor="${REPLY}"
  fi

  if (( $(echo "${factor} < 0" | bc -l) )); then
    echo "Speed factor can't be lower than 0"
    return 2
  elif (( $(echo "${factor} > 1" | bc -l) )); then
    echo "Speed factor can't be greater than 1"
    return 2
  fi

  # Convert factor to acceleration speed [-1,1]
  local speed=0
  speed="$(echo "${factor}" | awk '{print 2*$0 - 1}')" || return 1

  # Convert factor to velocity [0,15]
  local velocity=0
  velocity="$(echo "${factor}" | awk '{
    if ($0 == 0) {
      velocity=0.001
    } else {
      velocity=15*$0
    }

    print velocity
  }')" || return 1

  local devices=''
  devices="$(xinput --list | awk '{
    if ($0 ~ "Virtual core pointer") {
      next
    } else if ($0 ~ "Virtual core keyboard") {
      exit
    }

    match($0, ".*id=([0-9]+).*", a)
    print a[1]
  }')" || return 1

  local succeed="false"

  local device=''
  while read -r device; do
    # Assume this is a mouse device and set its acceleration speed
    xinput --set-prop "${device}" "libinput Accel Speed" "${speed}" &> /dev/null &&
    succeed="true" && continue

    # Otherwise assume this is a touch device and set its velocity
    xinput --set-prop "${device}" "Device Accel Constant Deceleration" 1 &> /dev/null &&
    xinput --set-prop "${device}" "Device Accel Adaptive Deceleration" 1 &> /dev/null &&
    xinput --set-prop "${device}" "Device Accel Velocity Scaling" "${velocity}" &> /dev/null &&
    succeed="true"
  done <<< "${devices}"

  if [[ "${succeed}" == "false" ]]; then
    echo "Failed to set pointer speed"
    return 2
  fi

  echo "Pointer speed set to ${factor}"

  # Save factor into settings file
  if [[ "${persist}" == "save" ]]; then
    local settings='{}'
    local pointer="{\"speed\": \"${factor}\"}"

    if [[ -f "${SETTINGS_FILE}" ]]; then
      settings="$(jq -e ".pointer = ${pointer} " "${SETTINGS_FILE}")" || return 1
    else
      settings="$(echo "{\"pointer\": ${pointer}}" | jq -e '.')" || return 1
    fi

    mkdir -p "${CONFIG_HOME}"
    echo "${settings}" > "${SETTINGS_FILE}"
  fi
}

# Show the data of the tablet device with the
# given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of a tablet device
# Outputs:
#  A long list of tablet device data.
show_tablet () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_tablet || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local tablet=''
  tablet="$(find_tablet "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find tablet ${name}"
    return 2
  fi

  local query=''
  query+='ID:           \(.id)\n'
  query+='Name:         \(.name)\n'
  query+='Type:         \(.type)\n'
  query+='Vendor:       \(.vendor)'
  query+='\(.Area|if . then "\nArea:         \(.)" else "" end)'
  query+='\(.Rotate|if . then "\nRotate:       \(.)" else "" end)'
  query+='\(.PressureRecalibration|if . then "\nPressure:     \(.)" else "" end)'
  query+='\(.PressCurve|if . then "\nPress Curve:  \(.)" else "" end)'
  query+='\(.RawSample|if . then "\nSample:       \(.)" else "" end)'
  query+='\(.Mode|if . then "\nMode:         \(.)" else "" end)'
  query+='\(.Touch|if . then "\nTouch:        \(.)" else "" end)'
  query+='\(.Gesture|if . then "\nGesture:      \(.)" else "" end)'
  query+='\(.TapTime|if . then "\nTap Time:     \(.)" else "" end)'
  query+='\(.CursorProx|if . then "\nCursor:       \(.)" else "" end)'
  query+='\(.Threshold|if . then "\nThreshold:    \(.)" else "" end)'

  echo "${tablet}" | jq -cer "\"${query}\"" || return 1
}

# Shows the list of stylus-pen devices currently
# connected to the system.
# Arguments:
#  None
# Outputs:
#  A list of stylus-pen devices.
list_tablets () {
  local tablets=''
  tablets="$(find_tablets)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find tablets"
    return 2
  fi

  local len=0
  len="$(count "${tablets}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No tablets have found"
    return 0
  fi

  local query=''
  query+='ID:      \(.id)\n'
  query+='Name:    \(.name)\n'
  query+='Type:    \(.type)\n'
  query+='Vendor:  \(.vendor)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${tablets}" | jq -cer "${query}" || return 1
}

# Scales the area of the tablet with the given name,
# keeping the current aspect ratio.
# Globals:
#  REPLY
# Arguments:
#  name:    the name of a tablet device
#  scale:   the scale factor [0.1-1]
#  persist: save or nosave, default is save
scale_tablet () {
  local name="${1}"
  local scale="${2}"
  local persist="${3:-"save"}"

  if [[ -z "${name}" ]]; then
    pick_tablet || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local tablet=''
  tablet="$(find_tablet "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find tablet ${name}"
    return 2
  elif ! is_scalable "${name}"; then
    echo "Tablet ${name} is not scalable"
    return 2
  fi

  if [[ -z "${scale}" ]]; then
    ask "Enter the scale factor [0.1-1]:" "^[0-9]+\.?[0-9]*$" || return $?
    scale="${REPLY}"
  fi

  if (( $(echo "${scale} <= 0" | bc -l) )); then
    echo "Scale can't be lower or equal to 0"
    return 2
  elif (( $(echo "${scale} > 1" | bc -l) )); then
    echo "Scale can't be larger than 1"
    return 2
  fi

  # Read the current aspect ratio
  local ratio=0
  ratio="$(get "${tablet}" '.Area' | awk '{print $3/$4}')" || return 1

  # Reset tablet area before applying the new scaling
  xsetwacom --set "${name}" ResetArea &> /dev/null || return 1

  # Restore the aspect ratio
  tablet="$(find_tablet "${name}")" || return 1

  local area=0
  area="$(get "${tablet}" '.Area' | awk -v "scale=${scale}" -v "ratio=${ratio}" '{
    if (ratio > 1) ratio=1/ratio

    width=int($3*scale)
    height=int(width*ratio)

    print 0" "0" "width" "height
  }')" || return 1

  xsetwacom --set "${name}" area "${area}" &> /dev/null

  if [[ $? -ne 0 ]]; then
    echo "Unable to scale tablet ${name}"
    return 2
  fi

  echo "Tablet ${name} scaled by ${scale}"

  # Save tablet's scale factor into settings file
  if [[ "${persist}" == "save" ]]; then
    local settings='{}'
    local tablet="{\"name\": \"${name}\", \"scale\": \"${scale}\"}"

    if [[ -f "${SETTINGS_FILE}" ]]; then
      local tablets=''
      tablets="$(jq '.tablets|if . then . else empty end' "${SETTINGS_FILE}")"

      if [[ -n "${tablets}" ]]; then
        local query=''
        query=".tablets[]|select(.name == \"${name}\")"

        local exists=''
        exists="$(jq "${query}" "${SETTINGS_FILE}")"

        if [[ -n "${exists}" ]]; then
          query="(${query}|.scale)|= ${scale}"
        else
          query=".tablets += [${tablet}]"
        fi

        settings="$(jq -e "${query}" "${SETTINGS_FILE}")" || return 1
      else
        settings="$(jq -e ".tablets = [${tablet}] " "${SETTINGS_FILE}")" || return 1
      fi
    else
      settings="$(echo "{\"tablets\": [${tablet}]}" | jq -e '.')" || return 1
    fi

    mkdir -p "${CONFIG_HOME}"
    echo "${settings}" > "${SETTINGS_FILE}"
  fi
}

# Maps the area of the tablet with the given name
# to a display device, where the special word desktop
# resets the tablet's mapping and ratio.
# Globals:
#  REPLY
# Arguments:
#  name:    the name of a tablet device
#  display: the name of a display device or desktop
map_tablet () {
  local name="${1}"
  local display="${2}"

  if [[ -z "${name}" ]]; then
    pick_tablet || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local tablet=''
  tablet="$(find_tablet "${name}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find tablet ${name}"
    return 2
  elif ! is_scalable "${name}"; then
    echo "Tablet ${name} is not scalable"
    return 2
  fi

  if [[ -z "${display}" ]]; then
    pick_output "Select a display:" "active" || return $?
    [[ -n "${REPLY}" ]] && display="${REPLY}" || return 0
  fi

  # Reset mapping and area if desktop is given
  if [[ "${display}" == "desktop" ]]; then
    xsetwacom --set "${name}" MapToOutput desktop &> /dev/null

    if [[ $? -ne 0 ]]; then
      echo "Failed to reset mapping"
      return 2
    fi

    # Restore area keeping the current scale
    local width=0
    width="$(get "${tablet}" '.Area' | awk '{print $3}')" || return 1

    xsetwacom --set "${name}" ResetArea &> /dev/null || return 1

    tablet="$(find_tablet "${name}")" || return 1

    local area=''
    area="$(get "${tablet}" '.Area' | awk -v "width=${width}" '{
      scale=width/$3
      width=int($3*scale)
      height=int($4*scale)

      print 0" "0" "width" "height
    }')" || return 1

    xsetwacom --set "${name}" area "${area}" &> /dev/null || return 1

    echo "Tablet mapping has been reset"
    return 0
  fi

  local output=''
  output="$(find_output "${display}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to find display ${display}"
    return 2
  elif ! is_active "${output}"; then
    echo "Display ${display} is not active"
    return 2
  fi

  # Re-calculate tablet's area to match display's ratio
  local display_width=0
  display_width="$(get "${output}" '.resolution_width')" || return 1

  local display_height=0
  display_height="$(get "${output}" '.resolution_height')" || return 1

  local ratio=0
  ratio="$(echo "${display_width} ${display_height}" | awk '{print $1/$2}')" || return 1

  local area=0
  area="$(get "${tablet}" '.Area' | awk -v "ratio=${ratio}" '{
    if (ratio > 1) ratio=1/ratio

    width=$3
    height=int(width*ratio)

    print 0" "0" "width" "height
  }')" || return 1

  xsetwacom --set "${name}" MapToOutput "${display}" &> /dev/null &&
  xsetwacom --set "${name}" area "${area}" &> /dev/null

  if [[ $? -ne 0 ]]; then
    echo "Failed to map tablet ${name}"
    return 2
  fi

  echo "Tablet ${name} mapped to ${display}"
}

# Applies the pointer settings being set in the
# settings file.
# Globals:
#  SETTINGS_FILE
# Arguments:
#  None
init_pointer () {
  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No pointer settings found"
    return 0
  fi

  local pointer=''
  pointer="$(jq '.pointer|if . then . else empty end' "${SETTINGS_FILE}")"

  if [[ -z "${pointer}" ]]; then
    echo "No pointer settings found"
    return 0
  fi

  local speed=''
  speed="$(get "${pointer}" '.speed')" || return 1

  set_pointer_speed "${speed}" "nosave"

  if [[ $? -ne 0 ]]; then
    echo "Failed to set pointer speed"
    return 2
  fi

  echo "Pointer speed has been set"
}

# Applies the settings for those tablets being stored
# in the settings file.
# Globals:
#  SETTINGS_FILE
# Arguments:
#  None
init_tablets () {
  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No tablets settings found"
    return 0
  fi

  local tablets=''
  tablets="$(jq '.tablets|if . then . else empty end' "${SETTINGS_FILE}")"

  if [[ -z "${tablets}" ]]; then
    echo "No tablets settings found"
    return 0
  fi

  local output=''
  output="$(find_outputs "primary" | jq -cer '.[0]|.device_name')" || return 1

  tablets="$(echo "${tablets}" | jq -cr '.[]|{name, scale}')" || return 1

  # Iterate over tablet commands and execute one by one
  local failed='false'
  local tablet=''

  while read -r tablet; do
    local name=''
    name="$(get "${tablet}" '.name')"

    local scale=1
    scale="$(get "${tablet}" '.scale')"

    scale_tablet "${name}" "${scale}" "nosave" &&
    map_tablet "${name}" "${output}" || failed='true'
  done <<< "${tablets}"

  if [[ "${failed}" == "true" ]]; then
    echo "Failed to set all tablets"
    return 2
  fi

  echo "Tablets have been set"
}

# Sets the desktop wallpaper to the wallpaper
# being set in the settings file.
# Globals:
#  SETTINGS_FILE
# Arguments:
#  None
init_wallpaper () {
  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No wallpaper settings found"
    return 0
  fi

  local wallpaper=''
  wallpaper="$(jq '.wallpaper|if . then . else empty end' "${SETTINGS_FILE}")"

  if [[ -z "${wallpaper}" ]]; then
    echo "No wallpaper settings found"
    return 0
  fi

  local name=''
  name="$(get "${wallpaper}" '.name')" || return 1

  if [[ ! -f "${WALLPAPERS_HOME}/${name}" ]]; then
    echo "Wallpaper ${name} does not exist"
    return 2
  fi

  local mode=''
  mode="$(get "${wallpaper}" '.mode')" || return 1

  set_wallpaper "${name}" "${mode:-"center"}" "nosave"

  if [[ $? -ne 0 ]]; then
    echo "Failed to set the wallpaper"
    return 2
  fi

  echo "Wallpaper has been set"
}

# Shows the help message.
# Arguments:
#  mode: once or none
# Outputs:
#  A long help message.
show_help () {
  if [[ "${1}" == "once" ]]; then
    echo "Usage: desktop COMMAND [OBJECT] [ARGUMENTS]..."

    echo -e "\nCOMMANDS"
    printf " %-16s %s\n" \
      "help" "Show this help message." \
      "" "" \
      "init pointer" "Apply pointer stored settings." \
      "init tablets" "Apply tablets stored settings" \
      "init wallpaper" "Set the desktop stored wallpaper."

    return 0
  fi

  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf " %-36s %s\n" \
    "help" "Show this help message." \
    "" "" \
    "show status" "Show the status of the desktop environment." \
    "show pointer [<id>]" "Show a pointing device." \
    "show tablet [<name>]" "Show a tablet device." \
    "" "" \
    "list wallpapers" "List the available wallapers." \
    "list pointers" "List the available pointing devices." \
    "list tablets" "List the connected tablets." \
    "" "" \
    "set wallpaper [<name> [<mode>]]" "Set the desktop wallpaper in center" \
    "" "fill, scale, max or tile mode." \
    "speed pointer [<factor>]" "Set the pointer's speed to a factor between" \
    "" "[0, 1] where 0 means slow and 1 fast." \
    "scale tablet [<name> [<factor>]]" "Scale down the area of a tablet (e.g. 0.5)" \
    "" "or use factor 1 to reset scaling." \
    "map tablet [<name> [<display>]]" "Map a tablet to a screen display" \
    "" "or just use desktop to reset mapping."
}

loop () {
  clear

  while true; do
    prompt && history -s "${REPLY}"

    set -f
    set_separator "line"
    local cmd=($(xargs -n1 <<< "${REPLY}"))
    restore_separator && set +f

    if [[ "${cmd[0]}" == "help" ]]; then
      show_help
      continue
    elif [[ "${cmd[0]}" == "clear" ]]; then
      clear
      continue
    elif [[ "${cmd[0]}" == "quit" ]]; then
      break
    elif [[ -z "${cmd[0]}" ]]; then
      continue
    fi

    case "${cmd[0]}" in
      "show")
        case "${cmd[1]}" in
          "status") show_status;;
          "pointer") show_pointer "${cmd[2]}";;
          "tablet") show_tablet "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "set")
        case "${cmd[1]}" in
          "wallpaper") set_wallpaper "${cmd[2]}" "${cmd[3]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "speed")
        case "${cmd[1]}" in
          "pointer") set_pointer_speed "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "scale")
        case "${cmd[1]}" in
          "tablet") scale_tablet "${cmd[2]}" "${cmd[3]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "map")
        case "${cmd[1]}" in
          "tablet") map_tablet "${cmd[2]}" "${cmd[3]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "list")
        case "${cmd[1]}" in
          "wallpapers") list_wallpapers;;
          "pointers") list_pointers;;
          "tablets") list_tablets;;
          *) echo "Invalid or unknown command";;
        esac;;
      *) echo "Invalid or unknown command";; 
    esac
    
    if [[ $? -eq 1 ]]; then
      echo "An unknown error has occurred"
    fi
  done

  clear
}

once () {
  case "${1}" in
    "help") show_help "once";;
    "init")
      case "${2}" in
        "pointer") init_pointer || abort;;
        "tablets") init_tablets || abort;;
        "wallpaper") init_wallpaper || abort;;
        *) abort "Invalid or unknown command";;
      esac;;
    *) abort "Invalid or unknown command";;
  esac

  if [[ $? -ne 0 ]]; then
    abort
  fi
}

if [[ $# -eq 0 ]]; then
  loop
else
  once "$@"
fi