#!/usr/bin/env bash

set -o pipefail

source /opt/stack/utils

require "xorg-xrandr"

get_screen () {
  local INDEX=${1:-"0"}

  local SCREEN=$(xrandr --current | sed "/^Screen ${INDEX}:/,/^Screen/!d;//d" || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  echo "$SCREEN"
}

get_outputs () {
  local STATUS=$1

  [[ ! "$STATUS" =~ ^( *|connected|disconnected|active|inactive|primary)$ ]] && return 1

  local SCREEN=$(get_screen || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local PATTERN='^[A-Z]+-[0-9]+'

  if [[ "$STATUS" =~ (dis)?connected ]]; then
    PATTERN+="\s${STATUS}"
  elif [ "$STATUS" = "active" ]; then
    PATTERN+='\sconnected.*\s([0-9]+x[0-9]+)\+.*'
  elif [ "$STATUS" = "inactive" ]; then
    PATTERN+='\sconnected\s\(.*'
  elif [ "$STATUS" = "primary" ]; then
    PATTERN+='.* primary .*'
  fi

  local OUTPUTS=$(echo "$SCREEN" | awk '/'${PATTERN}'/{print $1}' | tr $'\n' "$AES")

  [[ "$OUTPUTS" =~ .*${AES}$ ]] &&
    echo "${OUTPUTS::-1}" || echo "$OUTPUTS"
}

get_output () {
  local OUTPUT=$1
  [ -z "$OUTPUT" ] && return 1

  if [ "$OUTPUT" = "primary" ]; then
    OUTPUT=$(get_outputs "primary" || echo "err:$?")
    [[ "$OUTPUT" =~ ^err: ]] && return 1
  fi

  local SCREEN=$(get_screen || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local RATE="$(echo "$SCREEN" | sed -n "/$OUTPUT .*/{:a;N;/\*/!ba;/\*/p}" |
    awk 'match($0, /.* ([0-9]{2}.[0-9]{2})\*.*/, a) {print a[1]}')"

  local RESOLUTION="$(echo "$SCREEN" | sed -n "/$OUTPUT .*/{:a;N;/\*/!ba;/\*/p}" |
      awk 'match($0, /.* ([0-9]+x[0-9]+) .*\*.*/, a) {print a[1]}')"

  local PROFILES=""
  PROFILES="$(echo "$SCREEN" | awk /^$OUTPUT/,!// | tail -n +2 |
    awk -v AES="$AES" -v KVS="$KVS" '{
      if ($0 ~ /^\s+[0-9]+x[0-9]+/) {
        rates=""
        for(i=2;i<=NF;i++) rates=rates $i AES
        print "profile" KVS $1 KVS rates
      } else exit
    }' | tr -d '+*')"

  local HEAD=$(echo "$SCREEN" | awk "/^${OUTPUT} /")
  [ -z "$HEAD" ] && return 1

  local NAME="$(echo "$HEAD" | awk 'match($0, /(.*) ((dis)?connected) .*/, a) {print a[1]}')"
  local STATUS="$(echo "$HEAD" | awk 'match($0, /.* ((dis)?connected) .*/, a) {print a[1]}')"
  local AREA="$(echo "$HEAD" | awk 'match($0, /.* ([0-9]+x[0-9]+)\+.*/, a) {print a[1]}')"
  local POSITION="$(echo "$HEAD" | awk 'match($0, /.* [0-9]+x[0-9]+\+([0-9]+\+[0-9]+) .*/, a) {print a[1]}' | tr '+' ",")"
  local DIMS="$(echo "$HEAD" | awk 'match($0, /.* ([0-9]+mm x [0-9]+mm).*/, a) {print a[1]}' | tr -d ' m')"

  local PRIMARY="$(echo "$HEAD" | awk 'match($0, /.* (primary) .*/, a) {print a[1]}')"
  [ -n "$PRIMARY" ] && PRIMARY="true" || PRIMARY="false"

  local ACTIVE="false"
  [ "$STATUS" = "connected" ] && [[ "$AREA" =~ ^[0-9]+x[0-9]+$ ]] && ACTIVE="true"

  local ROTATE="$(echo "$HEAD" | awk 'match($0, /.* (normal|right|left|inverted) .*\(.*/, a) {print a[1]}')"
  [ -z "$ROTATE" ] && [ "$ACTIVE" = "true" ] && ROTATE="normal"

  local REFLECT="$(echo "$HEAD" | awk 'match($0, /.* (X) .*\(.*/, a) {print tolower(a[1])}')"
  REFLECT+="$(echo "$HEAD" | awk 'match($0, /.* (Y) .*\(.*/, a) {print tolower(a[1])}')"
  [ -z "$REFLECT" ] && [ "$ACTIVE" = "true" ] && REFLECT="normal"

  echo "name${KVS}$NAME"
  echo "status${KVS}$STATUS"
  echo "active${KVS}$ACTIVE"

  if [ "$ACTIVE" = "true" ]; then
    echo "primary${KVS}$PRIMARY"
    echo "resolution${KVS}$RESOLUTION"
    echo "rate${KVS}$RATE"
    echo "rotate${KVS}$ROTATE"
    echo "reflect${KVS}$REFLECT"
    echo "area${KVS}$AREA"
    echo "position${KVS}$POSITION"
    echo "dims${KVS}$DIMS"
    echo "$PROFILES"
  fi
}

get_resolutions () {
  local OUTPUT=$1

  local SCREEN=$(get_screen 0 || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local RESOLUTIONS="$(echo "$SCREEN" | awk /^$OUTPUT/,!// | tail -n +2 |
    awk '{if ($0 ~ /^\s+[0-9]+x[0-9]+/) {print $1} else {exit}}' | tr $'\n' "$AES")"

  [[ "$RESOLUTIONS" =~ .*${AES}$ ]] &&
    echo "${RESOLUTIONS::-1}" || echo "$RESOLUTIONS"
}

get_rates () {
  local OUTPUT=$1
  local RESOLUTION=$2

  local SCREEN=$(get_screen 0 || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local RATES="$(echo "$SCREEN" | awk /^$OUTPUT/,!// | tail -n +2 |
    awk '{if ($0 ~ /\s'$RESOLUTION'\s/) {print $0; exit}}' |
    sed 's/'$RESOLUTION'//' | trim | tr -d '+*' | sed 's/ \{1,\}/\n/g' | tr $'\n' "$AES")"

  [[ "$RATES" =~ .*${AES}$ ]] &&
    echo "${RATES::-1}" || echo "$RATES"
}

exists () {
  local OUTPUT=$1

  local SCREEN=$(get_screen || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local HEAD=$(echo "$SCREEN" | awk "/^${OUTPUT} /")

  [ -n "$HEAD" ] && return 0 || return 1
}

is_connected () {
  local OUTPUT=$1

  local SCREEN=$(get_screen || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local HEAD=$(echo "$SCREEN" | awk "/^${OUTPUT} /")
  [ -z "$HEAD" ] && return 1

  local STATUS="$(echo "$HEAD" | awk 'match($0, /.* ((dis)?connected) .*/, a) {print a[1]}')"

  [ "$STATUS" = "connected" ] && return 0 || return 1
}

is_active () {
  local OUTPUT=$1

  local SCREEN=$(get_screen || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local HEAD=$(echo "$SCREEN" | awk "/^${OUTPUT} /")
  [ -z "$HEAD" ] && return 1

  local STATUS="$(echo "$HEAD" | awk 'match($0, /.* ((dis)?connected) .*/, a) {print a[1]}')"
  local RESOLUTION="$(echo "$HEAD" | awk 'match($0, /.* ([0-9]+x[0-9]+)\+.*/, a) {print a[1]}')"

  [ "$STATUS" = "connected" ] && [ -n "$RESOLUTION" ] &&
    return 0 || return 1
}

is_primary () {
  local NAME=$1

  local OUTPUT=$(get_output "$NAME" || echo "err:$?")
  [[ "$OUTPUT" =~ ^err: ]] && return 1
  
  local PRIMARY=$(property "$OUTPUT" "primary" | value)

  [ "$PRIMARY" = "true" ] && return 0 || return 1
}

pick_output () {
  local STATUS=$1

  local OUTPUTS=$(get_outputs "$STATUS" || echo "err:$?")
  [[ "$OUTPUTS" =~ ^err: ]] && echo "Unable to find ${STATUS:-\b} outputs" && return 1

  local LEN=$(count "$OUTPUTS")
  [ ! $LEN -gt 0 ] && echo "No ${STATUS:-\b} outputs have been found" && return 1

  local MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"
  
  pick_one "Select an output:" "$OUTPUTS" "$MODE"
}

pick_resolution () {
  local OUTPUT=$1

  local RES=$(get_resolutions "$OUTPUT" || echo "err:$?")
  [[ "$RES" =~ ^err: ]] && echo "Unable to find resolutions for $OUTPUT output" && return 1

  local LEN=$(count "$RES")
  [ ! $LEN -gt 0 ] && echo "No resolutions have been found for $OUTPUT output" && return 1

  local MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"
  
  pick_one "Select a resolution:" "$RES" "$MODE"
}

pick_rate () {
  local OUTPUT=$1
  local RESOLUTION=$2

  local RATES=$(get_rates "$OUTPUT" "$RESOLUTION" || echo "err:$?")
  [[ "$RATES" =~ ^err: ]] && echo "Unable to find rates for $OUTPUT output" && return 1

  local LEN=$(count "$RATES")
  [ ! $LEN -gt 0 ] && echo "No rates have been found for $OUTPUT output" && return 1

  local MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"
  
  pick_one "Select a rate:" "$RATES" "$MODE"
}

prompt () {
  local PRIMARY=$(get_output primary || echo "err:$?")
  
  if [[ "$PRIMARY" =~ ^err: ]]; then
    read -rep "[screens:${RE}none$RS] " REPLY
    return 1
  fi

  local NAME=$(property "$PRIMARY" name)
  local RES=$(property "$PRIMARY" resolution)
  local RATE=$(property "$PRIMARY" rate)

  local STATUS="$YE${NAME}$RS"

  if [ -n "$RES" ]; then
    STATUS+=" $YE${RES}$RS"
    [ -n "$RATE" ] && STATUS+="$GR@${RATE}$RS"
  fi

  read -rep "[screens:$STATUS] " REPLY
}

show_status () {
  if [ -z "$DISPLAY" ]; then
    echo "Unable to resolve the xorg server"
    return 1
  fi

  local PATTERN='/^('
  PATTERN+='name\sof\sdisplay|'
  PATTERN+='version\snumber|'
  PATTERN+='vendor\sstring|'
  PATTERN+='vendor\srelease\snumber|'
  PATTERN+='X.Org\sversion|'
  PATTERN+='motion\sbuffer\ssize|'
  PATTERN+='image\sbyte\sorder|'
  PATTERN+='default\sscreen\snumber|'
  PATTERN+='number\sof\sscreens'
  PATTERN+=')/'

  xdpyinfo -display "$DISPLAY" |
    awk -F': ' $PATTERN'{ \
      gsub(/[ \t]+$/, "", $1); \
      gsub(/^[ \t]+/, "", $2); \
      printf "%-23s %s\n",$1":",$2 \
    }' | sed -r 's/\<./\U&/g'

  local OUTPUTS=$(get_outputs connected || echo "err:$?")

  if [[ "$OUTPUTS" =~ ^err ]]; then
    echo "Unable to get connected outputs"
    return 1
  fi

  LEN=$(count "$OUTPUTS")

  if [ $LEN = 0 ]; then
    echo "Connected Outputs:      none"
    return
  fi

  local CONNECTED="Connected Outputs:      "

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    local OUTPUT=$(element "$OUTPUTS" "$INDEX")
    OUTPUT=$(get_output "$OUTPUT")

    local NAME="$(property "$OUTPUT" name)"

    local RES="$(property "$OUTPUT" resolution)"
    [ -z "$RES" ] && RES="inactive"

    local RATE="$(property "$OUTPUT" rate)"

    local PRIMARY="$(property "$OUTPUT" primary)"
    [ "$PRIMARY" = "true" ] && PRIMARY="*"

    if [ $INDEX = 0 ]; then
      CONNECTED+="$NAME [${RES}$RATE]$PRIMARY"
    else
      CONNECTED+="\n                        $NAME [${RES}$RATE]$PRIMARY"
    fi
  done

  echo -e "$CONNECTED"
}

show_output () {
  local OUTPUT=$1

  if [ -z "$OUTPUT" ]; then
    pick_output || return 1    
    [ -z "$REPLY" ] && return || OUTPUT=$(value "$REPLY")
  fi

  local OUTPUT=$(get_output "$OUTPUT" || echo "err:$?")

  if [[ "$SCREEN" =~ ^err: ]]; then
    echo "Unable to find $OUTPUT output"
    return 1
  fi

  local NAME="$(property "$OUTPUT" name)"
  local STATUS="$(property "$OUTPUT" status)"
  local ACTIVE="$(property "$OUTPUT" active)"
  local PRIMARY="$(property "$OUTPUT" primary)"
  local RESOLUTION="$(property "$OUTPUT" resolution)"
  local RATE="$(property "$OUTPUT" rate)"
  local ROTATE="$(property "$OUTPUT" rotate)"
  local REFLECT="$(property "$OUTPUT" reflect)"
  local POSITION="$(property "$OUTPUT" position)"
  local SIZE="$(property "$OUTPUT" size)"
  local DIMS="$(property "$OUTPUT" dims)"
  local PROFILES="$(property "$OUTPUT" profiles)"

  echo -e \
    "Name:       $NAME\n" \
    "Status:     $STATUS\n" \
    "Active:     $ACTIVE\n" \
    "Primary:    $PRIMARY\n" \
    "Resolution: $RESOLUTION\n" \
    "Rate:       $RATE\n" \
    "Rotate:     $ROTATE\n" \
    "Reflect:    $REFLECT\n" \
    "Position:   $POSITION\n" \
    "Size:       $SIZE\n" \
    "Dimensions: $DIMS\n" \
    "Profiles:   $PROFILES"
}

list_outputs () {
  local STATUS=$1

  if [[ ! "$STATUS" =~ ^( *|connected|disconnected|active|inactive|primary)$ ]]; then
    echo "Invalid status argument: '$STATUS'"
    return 1
  fi

  local OUTPUTS=$(get_outputs "$STATUS" || echo "err:$?")

  if [[ "$OUTPUTS" =~ ^err: ]]; then
    echo -e "Unable to retrieve ${STATUS:-\b} outputs"
    return 1
  fi

  local LEN=$(count "$OUTPUTS")

  if [ ! $LEN -gt 0 ]; then
    echo "No ${STATUS:-\b} outputs have been found"
    return
  fi

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    local OUTPUT=$(element "$OUTPUTS" "$INDEX" | value)

    [ $INDEX -gt 0 ] && echo
    show_output "$OUTPUT" | head -n 11
  done
}

set_layout () {
  local OUTPUTS=$(get_outputs active || echo "err:$?")

  if [[ "$OUTPUTS" =~ ^err: ]]; then
    echo "Unable to retrieve active outputs"
    return 1
  fi

  local LEN=$(count "$OUTPUTS")

  if [ $LEN = 0 ]; then
    echo "No active outputs have been found"
    return
  elif [ $LEN = 1 ]; then
    echo "No layout can be set for one active output"
    return
  elif [ $LEN -gt 3 ]; then
    echo "No layouts found for more than three outputs"
    return
  fi

  local LAYOUTS=""

  if [ $LEN = 2 ]; then
    LAYOUTS+="Side by Side${KVS}row-2${AES}"
    LAYOUTS+="Top Bottom${KVS}col-2"

    echo "Side by Side | Top Bottom"
    echo "[A][B]         [A]"
    echo "               [B]"
  elif [ $LEN = 3 ]; then
    LAYOUTS+="Side by Side${KVS}row-3${AES}"
    LAYOUTS+="Top Bottom${KVS}col-3${AES}"
    LAYOUTS+="Left Gamma${KVS}gamma-3${AES}"
    LAYOUTS+="Right Gamma${KVS}gamma-rev-3${AES}"
    LAYOUTS+="Left Lambda${KVS}lambda-3${AES}"
    LAYOUTS+="Right Lambda${KVS}lambda-rev-3"

    echo "Side by Side | Top Bottom | Left Gamma | Right Gamma | Left Lambda | Right Lambda"
    echo "[A][B][C]      [A]          [A][B]       [A][B]        [A]              [A]"
    echo "               [B]          [C]             [C]        [B][C]        [B][C]"
    echo "               [C]"
  fi

  local MODE="vertical-6"
  [ $(count "$LAYOUTS") -lt 3 ] && MODE="horizontal"

  pick_one "Select a layout mode:" "$LAYOUTS" "$MODE"
  [ -z "$REPLY" ] && return

  local LAYOUT=$(value "$REPLY")

  MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"

  local SPOTS=$(echo "$LEN" | awk '{for(i=65; i<65+$0; i++) printf "%c,",i}')
  pick_by_order "Pick outputs by order to match ${SPOTS::-1}:" "$OUTPUTS" "$LEN" "$MODE"
  [ -z "$REPLY" ] && return

  local A=$(element "$REPLY" 0 | value)
  local B=$(element "$REPLY" 1 | value)
  if [ $LEN = 3 ]; then
    local C=$(element "$REPLY" 2 | value)
  fi

  case "$LAYOUT" in
    "row-2")
      xrandr --output "$A" --left-of "$B" &&
        echo "Outputs laid out in side by side mode" ||
        echo "Unable to lay out outputs in side by side mode";;
    "col-2")
      xrandr --output "$A" --above "$B" &&
        echo "Outputs laid out in top bottom mode" ||
        echo "Unable to lay out outputs in top bottom mode";;
    "row-3")
      xrandr --output "$A" --left-of "$B" --output "$B" --left-of "$C" &&
        echo "Outputs laid out in side by side mode" ||
        echo "Unable to lay out outputs in side by side mode";;
    "col-3")
      xrandr --output "$A" --above "$B" --output "$B" --above "$C" &&
        echo "Outputs laid out in top bottom mode" ||
        echo "Unable to lay out outputs in top bottom mode";;
    "gamma-3")
      xrandr --output "$A" --left-of "$B" --output "$C" --below "$A" &&
        echo "Outputs laid out in left gamma mode" ||
        echo "Unable to lay out outputs in left gamma mode";;
    "gamma-rev-3")
      xrandr --output "$A" --left-of "$B" --output "$C" --below "$B" &&
        echo "Outputs laid out in right gamma mode" ||
        echo "Unable to lay out outputs in right gamma mode";;
    "lambda-3")
      xrandr --output "$A" --above "$B" --output "$B" --left-of "$C" &&
        echo "Outputs laid out in left lambda mode" ||
        echo "Unable to lay out outputs in left lambda mode";;
    "lambda-rev-3")
      xrandr --output "$A" --left-of "$C" --output "$A" --above "$C" &&
        echo "Outputs laid out in right lambda mode" ||
        echo "Unable to lay out outputs in right lambda mode";;
    *) echo "Unable to set the layout: '$LAYOUT'"; return 1;;
  esac
}

set_mode () {
  local OUTPUT=$1
  local RESOLUTION=$2
  local RATE=$3

  if [ -z "$OUTPUT" ]; then
    pick_output "active" || return 1

    [ -z "$REPLY" ] && return || OUTPUT=$(value "$REPLY")
  fi
  
  if ! exists "$OUTPUT"; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot set mode of a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot set mode of an inactive"
    return 1
  fi

  if [ -z "$RESOLUTION" ]; then
    pick_resolution "$OUTPUT" || return 1

    [ -z "$REPLY" ] && return || RESOLUTION=$(value "$REPLY")
  fi

  if [ -z "$RATE" ]; then
    pick_rate "$OUTPUT" "$RESOLUTION" || return 1

    [ -z "$REPLY" ] && return || RATE=$(value "$REPLY")
  fi

  xrandr --output "$OUTPUT" --mode "$RESOLUTION" --rate "$RATE" &&
    echo "Output $OUTPUT mode set to $RESOLUTION@${RATE}Hz" ||
    echo "Unable to set mode for output $OUTPUT"
}

restore () {
  local OUTPUT=$1

  if [ -z "$OUTPUT" ]; then
    pick_output "active" || return 1

    [ -z "$REPLY" ] && return || OUTPUT=$(value "$REPLY")
  fi
  
  if ! exists "$OUTPUT"; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot restore a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot restore an inactive output"
    return 1
  fi

  xrandr --output "$OUTPUT" --auto &&
    echo "Output $OUTPUT has been set to auto mode" ||
    echo "Unable to restore the output $OUTPUT"
}

set_primary () {
  local OUTPUT=$1

  if [ -z "$OUTPUT" ]; then
    pick_output "active" || return 1
    [ -z "$REPLY" ] && return || OUTPUT=$(value "$REPLY")
  fi
  
  if ! exists "$OUTPUT"; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot set primary a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot set primary an inactive output"
    return 1
  elif is_primary "$OUTPUT"; then
    echo "Output $OUTPUT is already the primary"
    return 1
  fi

  xrandr --output "$OUTPUT" --primary &&
    echo "Output $OUTPUT has been set as primary" ||
    echo "Unable to set the primary output $OUTPUT"
}

set_on () {
  local OUTPUT=$1

  if [ -z "$OUTPUT" ]; then
    pick_output inactive || return 1
    [ -z "$REPLY" ] && return || OUTPUT=$(value "$REPLY")
  fi
  
  if ! exists "$OUTPUT"; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot activate a disconnected output"
    return 1
  elif is_active "$OUTPUT"; then
    echo "Output $OUTPUT is already active"
    return 1
  fi

  xrandr --output "$OUTPUT" --auto &&
    echo "Output $OUTPUT has been activated" ||
    echo "Unable to activate the output $OUTPUT"
}

set_off () {
  local OUTPUT=$1

  if [ -z "$OUTPUT" ]; then
    pick_output active || return 1

    [ -z "$REPLY" ] && return || OUTPUT=$(value "$REPLY")
  fi
  
  if ! exists "$OUTPUT"; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot deactivate a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Output $OUTPUT is already inactive"
    return 1
  elif is_primary "$OUTPUT"; then
    echo "Cannot deactivate the primary output"
    return 1
  fi

  xrandr --output "$OUTPUT" --off &&
    echo "Output $OUTPUT has been deactivated" ||
    echo "Unable to deactivate the output $OUTPUT"
}

reflect () {
  local OUTPUT=$1
  local MODE=$2

  if [ -z "$OUTPUT" ]; then
    pick_output "active" || return 1

    [ -z "$REPLY" ] && return || OUTPUT=$(value "$REPLY")
  fi
  
  if ! exists "$OUTPUT"; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot reflect a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot reflect an inactive output"
    return 1
  fi

  if [ -z "$MODE" ]; then
    local MODES=""
    MODES+="Normal${KVS}normal${AES}"
    MODES+="X Axis${KVS}x${AES}"
    MODES+="Y Axis${KVS}y${AES}"
    MODES+="XY Axes${KVS}xy"

    pick_one "Select a reflection mode:" "$MODES" "vertical-4"
    [ -z "$REPLY" ] && return || MODE=$(value "$REPLY")
  fi
  
  if [[ ! "$MODE" =~ ^(normal|x|y|xy)$ ]]; then
    echo "Invalid reflection mode argument: '$MODE'"
    return 1
  fi

  xrandr --output "$OUTPUT" --reflect "$MODE" &&
    echo "Output $OUTPUT has been reflected to $MODE mode" ||
    echo "Unable to reflect the output $OUTPUT"
}

rotate () {
  local OUTPUT=$1
  local MODE=$2

  if [ -z "$OUTPUT" ]; then
    pick_output "active" || return 1

    [ -z "$REPLY" ] && return || OUTPUT=$(value "$REPLY")
  fi
  
  if ! exists "$OUTPUT"; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot reflect a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot reflect an inactive output"
    return 1
  fi

  if [ -z "$MODE" ]; then
    local MODES=""
    MODES+="Normal${KVS}normal${AES}"
    MODES+="Right 90°${KVS}right${AES}"
    MODES+="Left 90°${KVS}left${AES}"
    MODES+="Inverted 180°${KVS}inverted"

    pick_one "Select a rotation mode:" "$MODES" "vertical-6"
    [ -z "$REPLY" ] && return || MODE=$(value "$REPLY")
  fi
  
  if [[ ! "$MODE" =~ ^(normal|right|left|inverted)$ ]]; then
    echo "Invalid rotation mode argument: '$MODE'"
    return 1
  fi

  xrandr --output "$OUTPUT" --rotate "$MODE" &&
    echo "Output $OUTPUT has been rotated to $MODE mode" ||
    echo "Unable to rotate the output $OUTPUT"
}

save_layout () {
  local OUTPUTS=$(get_outputs || echo "err:$?")
  [[ "$OUTPUTS" =~ ^err: ]] && echo "Unable to retrieve outputs" && return 1

  local LEN=$(count "$OUTPUTS")
  [ $LEN = 0 ] && echo "No outputs have found" && return 1

  local LAYOUT=""

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    [ $INDEX -gt 0 ] && LAYOUT+=$'\n'

    local NAME=$(element "$OUTPUTS" "$INDEX" | value)

    local OUTPUT=$(get_output "$NAME" || echo "err$?")
    [[ "$OUTPUT" =~ ^err: ]] && continue

    local ACTIVE=$(property "$OUTPUT" "active" | value)
    [ "$ACTIVE" = "false" ] && LAYOUT+="$NAME off" && continue

    local PRIMARY=$(property "$OUTPUT" "primary" | value)
    [ "$PRIMARY" = "true" ] && LAYOUT+="$NAME primary" || LAYOUT+="$NAME secondary"

    local RESOLUTION=$(property "$OUTPUT" "resolution" | value)
    local RATE=$(property "$OUTPUT" "rate" | value)
    local POSITION=$(property "$OUTPUT" "position" | value | tr ',' 'x')
    local ROTATE=$(property "$OUTPUT" "rotate" | value)
    local REFLECT=$(property "$OUTPUT" "reflect" | value)

    LAYOUT+=" $RESOLUTION $RATE $POSITION $ROTATE $REFLECT"
  done

  echo -e "$LAYOUT" > ~/.config/stack/layout
}

load_layout () {
  if [ ! -f ~/.config/stack/layout ]; then
    echo "No layout config file found, fallback to auto"
    return
  fi

  local ARGS=$(awk '{
    if ($2 == "off") {
      print "--output "$1" --off"
    } else {
      args="--output "$1" --mode "$3" --rate "$4" --pos "$5" --rotate "$6" --reflect "$7
      if ($2 == "primary") args=args" --primary"
      print args
    }
  }' ~/.config/stack/layout | tr $'\n' ' ')

  xrandr $ARGS &&
    echo "Layout configuration has been loaded" ||
    echo "Unable to load layout configuration"
}

help () {
  local FRM=" %-45s\t%s\n"

  if [ "$1" = "once" ]; then
    echo "Usage: screens COMMAND"

    echo -e "\nCOMMANDS"
    printf "$FRM" \
      "help" "Show this message" \
      "load layout" "Load screens output layout"

    return
  fi

  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf "$FRM" \
    "help" "Show this help message." \
    "show status" "Show a report of the xorg server and screens." \
    "show output [<output>]" "Show the data of the given output." \
    "" "" \
    "list outputs [<status>]" "List all outputs or by the given status," \
    "" "connected, disconnected or active." \
    "" "" \
    "set layout" "Set the layout of active outputs." \
    "set mode [<output> [<res> [<rate>]]]" "Set the mode of the given output." \
    "set primary [<output>]" "Set the primary output." \
    "set on|off [<output>]" "Set active or inactive the given output." \
    "save layout" "Persist the current screen layout to be applied in next boot." \
    "" "" \
    "rotate [<output> normal|right|left|inverted]" "Set output rotation to normal, right, left or inverted." \
    "reflect [<output> normal|x|y|xy]" "Set output reflection to normal, x, y or xy axes." \
    "restore [<output>]" "Restore the given output to auto mode."

  echo -e "\nOBJECTS"
  printf "$FRM" \
    "status" "The status of xorg server and screen layouts." \
    "output" "An output display device." \
    "layout" "The layout of multiple outputs setup." \
    "mode" "The resolution and rate of an output." \
    "primary" "The main output in a multihead layout."
}

loop () {
  clear

  while true; do
    prompt && history -s "$REPLY"

    set -f
    set_separator "line"
    local CMD=($(xargs -n1 <<< "$REPLY"))
    restore_separator && set +f

    if [ "${CMD[0]}" = "help" ]; then
      help
      continue
    elif [ "${CMD[0]}" = "clear" ]; then
      clear
      continue
    elif [ "${CMD[0]}" = "quit" ]; then
      break
    elif [ -z "${CMD[0]}" ]; then
      continue
    fi

    case "${CMD[0]}" in
      "show")
        case "${CMD[1]}" in
          "status") show_status;;
          "output") show_output "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "list")
        case "${CMD[1]}" in
          "outputs") list_outputs "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "set")
        case "${CMD[1]}" in
          "layout") set_layout;;
          "mode") set_mode "${CMD[2]}" "${CMD[3]}" "${CMD[4]}";;
          "primary") set_primary "${CMD[2]}";;
          "on") set_on "${CMD[2]}";;
          "off") set_off "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "save")
        case "${CMD[1]}" in
          "layout") save_layout;;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "rotate") rotate "${CMD[1]}" "${CMD[2]}";;
      "reflect") reflect "${CMD[1]}" "${CMD[2]}";;
      "restore") restore "${CMD[1]}";;
      *) echo "Unknown or invalid command: '$REPLY'";;
    esac
  done

  clear
}

once () {
  case "$1" in
    "help") help "once";;
    "load")
      case "$2" in
        "layout") load_layout;;
        *) abort "Unknown or invalid command: '$1'";; 
      esac;;
    *) abort "Unknown or invalid command: '$1'";; 
  esac
}

if [ $# = 0 ]; then
  loop
else
  once "$@"
fi
