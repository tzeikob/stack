#!/usr/bin/env bash

set -o pipefail

source /opt/stack/utils

require "xorg-xrandr"

screen () {
  local INDEX=${1:-"0"}

  xrandr --current | sed "/^Screen ${INDEX}:/,/^Screen/!d;//d"
}

outputs () {
  local STATUS=$1

  local RE='^[A-Z]+-[0-9]+'
  if [[ "$STATUS" =~ ^(dis)?connected$ ]]; then
    RE+="\s$STATUS"
  elif [ "$STATUS" = "active" ]; then
    RE+='\sconnected.*\s([0-9]+x[0-9]+)\+.*'
  elif [ "$STATUS" = "inactive" ]; then
    RE+='\sconnected\s\(.*'
  elif [ "$STATUS" = "primary" ]; then
    RE+='\s.*\sprimary\s.*'
  fi

  local OUTPUTS=$(screen | awk '{ORS="'$AES'";} /'${RE}'/{print $1}')

  if [[ "$OUTPUTS" =~ .*${AES}$ ]]; then
    echo "${OUTPUTS::-${#AES}}"
  else
    echo "$OUTPUTS"
  fi
}

output () {
  local NAME=$1

  local CRITERION="^$NAME\s.*"

  if [ "$NAME" = "primary" ]; then
    CRITERION='.*\sprimary\s.*'
  fi

  local SCREEN="$(screen)"

  local HEAD=$(echo "$SCREEN" | awk '/'$CRITERION'/')
  
  if [ -z "$HEAD" ]; then
    return 1
  fi

  local RE='^(.*)\s(connected|disconnected)\s?(primary)?\s?'
  RE+='([0-9]+x[0-9]+)?(\+[0-9]+\+[0-9]+)?\s?'
  RE+='(normal|right|left|inverted)?\s?(X\saxis|Y\saxis|X\sand\sY\saxis)?\s.*'

  local STATE="$(echo "$HEAD" | awk 'match($0,/'$RE'/,a) {
    a[5]=gensub(/\+(.*)\+(.*)/,"\\1x\\2","g",a[5]);
    a[7]=tolower(a[7]); gsub(/( |and|axis)/,"",a[7]);
    print a[1]"'$AES'"a[2]"'$AES'"a[3]"'$AES'"a[4]"'$AES'"a[5]"'$AES'"a[6]"'$AES'"a[7]}')"

  RE='^\s+([0-9]+x[0-9]+)\s.*\s([0-9]{2}.[0-9]{2})\*.*'

  local MODE="$(echo "$SCREEN" | sed -n "/$CRITERION/{:a;N;/\*/!ba;/\*/p}" |
    awk 'match($0,/'$RE'/,a) {print a[1]"'$AES'"a[2]}')"

  [ -n "$MODE" ] && STATE+="$AES$MODE" || STATE+="$AES$AES"

  local PROFILES="$(echo "$SCREEN" | awk '/'$CRITERION'/,!//' | tail -n +2 |
    awk -v AES="$AES" -v KVS="$KVS" '{
      if ($0 ~ /^\s+[0-9]+x[0-9]+/) {
        rates=""
        for (i=2; i<=NF; i++) {
          rates=rates $i
          if (i<NF) rates=rates AES
        }
        print $1 KVS rates
      } else exit
    }' | tr -d '+*')"
  
  echo -e "$STATE\n$PROFILES"
}

is_connected () {
  local OUTPUT=$1

  echo "$OUTPUT" | head -n 1 |
    awk '/'$AES'connected'$AES'/ {c=0;next} {c=1} END {exit c}'
}

is_active () {
  local OUTPUT=$1

  echo "$OUTPUT" | head -n 1 |
    awk '/'$AES'connected'$AES'.*'$AES'[0-9]+x[0-9]+'$AES'/ {c=0;next} {c=1} END {exit c}'
}

is_primary () {
  local OUTPUT=$1

  echo "$OUTPUT" | head -n 1 |
    awk '/'$AES'primary'$AES'/ {c=0;next} {c=1} END {exit c}'
}

pick_output () {
  local STATUS=$1

  local OUTPUTS=$(outputs "$STATUS")
  local LEN=$(count "$OUTPUTS")

  if [ ! $LEN -gt 0 ]; then
    echo "No ${STATUS:-\b} outputs have been found"
    return 1
  fi

  local MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"
  
  pick_one "Select an output:" "$OUTPUTS" "$MODE"
}

pick_resolution () {
  local OUTPUT=$1

  local RESOLUTIONS="$(echo "$OUTPUT" |
    awk -F$KVS '{ORS="'$AES'";} {if ($0 ~ /^[0-9]+x[0-9]+/) {print $1}}')"

  if [[ "$RESOLUTIONS" =~ .*${AES}$ ]]; then
    RESOLUTIONS="${RESOLUTIONS::-${#AES}}"
  fi

  local LEN=$(count "$RESOLUTIONS")

  if [ ! $LEN -gt 0 ]; then
    echo "No available resolutions have been found"
    return 1
  fi

  local MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"
  
  pick_one "Select a resolution:" "$RESOLUTIONS" "$MODE"
}

pick_rate () {
  local OUTPUT=$1
  local RESOLUTION=$2

  local RATES="$(echo "$OUTPUT" |
    awk -F$KVS '{if ($0 ~ /^'$RESOLUTION'/) {print $2; exit}}')"

  local LEN=$(count "$RATES")

  if [ ! $LEN -gt 0 ]; then
    echo "No rates have been found"
    return 1
  fi

  local MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"
  
  pick_one "Select a rate:" "$RATES" "$MODE"
}

prompt () {
  local PRIMARY="$(output primary)"

  local STATUS="$(echo "$PRIMARY" | head -n 1 | awk -F$AES '{
    out=$1; if ($8 && $9) out=out " "$8"@"int($9)"Hz"; print out
  }')"

  read -rep "[screens:$YE${STATUS}$RS] " REPLY
}

show_status () {
  if [ -z "$DISPLAY" ]; then
    echo "Unable to resolve the xorg server"
    return 1
  fi

  local PATTERN='/^('
  PATTERN+='name\sof\sdisplay|'
  PATTERN+='version\snumber|'
  PATTERN+='vendor\sstring|'
  PATTERN+='vendor\srelease\snumber|'
  PATTERN+='X.Org\sversion|'
  PATTERN+='motion\sbuffer\ssize|'
  PATTERN+='image\sbyte\sorder|'
  PATTERN+='default\sscreen\snumber|'
  PATTERN+='number\sof\sscreens'
  PATTERN+=')/'

  xdpyinfo -display "$DISPLAY" |
    awk -F': ' $PATTERN'{ \
      gsub(/[ \t]+$/, "", $1); \
      gsub(/^[ \t]+/, "", $2); \
      printf "%-23s %s\n",$1":",$2 \
    }' | sed -r 's/\<./\U&/g'

  local OUTPUTS=$(outputs connected)
  local LEN=$(count "$OUTPUTS")

  if [ $LEN = 0 ]; then
    echo "Connected Outputs:      none"
    return
  fi

  echo "$OUTPUTS" | awk -F$AES '{
    out=$1; for(i=2;i<=NF;i++) out=out ","$i;
    print "Connected Outputs:      "out}'

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    echo

    local NAME="$(element "$OUTPUTS" "$INDEX" | value)"
    local OUTPUT="$(output "$NAME")"

    local FRM=""
    FRM+="Output: %s\n"
    FRM+="Mode:   %s@%sHz\n"
    FRM+="Area:   %s\n"
    FRM+="Pos:    %s\n"
    FRM+="RoRe:   %s %s\n"

    echo "$OUTPUT" | head -n 1 | awk -F$AES -v FRM="$FRM" '{
      if ($3) {$1=$1"*"};
      if (!$6) $6="normal";
      if (!$7) $7="normal";
      printf FRM,$1,$8,$9,$4,$5,$6,$7
    }'
  done
}

show_output () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi

  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find $NAME output"
    return 1
  fi

  if ! is_active "$OUTPUT"; then
    local FRM=""
    FRM+="Name:       %s\n"
    FRM+="Status:     %s\n"

    echo "$OUTPUT" | head -n 1 | awk -F$AES -v FRM="$FRM" '{printf FRM,$1,$2}'
    return
  fi

  local FRM=""
  FRM+="Name:       %s\n"
  FRM+="Status:     %s\n"
  FRM+="Primary:    %s\n"
  FRM+="Resolution: %s\n"
  FRM+="Rate:       %sHz\n"
  FRM+="Rotate:     %s\n"
  FRM+="Reflect:    %s\n"
  FRM+="Area:       %s\n"
  FRM+="Position:   %s\n"

  echo "$OUTPUT" | head -n 1 | awk -F$AES -v FRM="$FRM" '{
    if ($3) {$3="true"} else {$3="false"};
    if (!$6) $6="normal";
    if (!$7) $7="normal";
    printf FRM,$1,$2,$3,$8,$9,$6,$7,$4,$5
  }'

  echo "$OUTPUT" | tail -n +2 | head -n 1 |
    awk -F$KVS '{gsub(/'$AES'/," ",$2); printf "Profiles:   %-9s %s\n",$1,$2}'
  echo "$OUTPUT" | tail -n +3 |
    awk -F$KVS '{gsub(/'$AES'/," ",$2); printf "            %-9s %s\n",$1,$2}'
}

list_outputs () {
  local STATUS=$1

  local OUTPUTS=$(outputs "$STATUS")
  local LEN=$(count "$OUTPUTS")

  if [ ! $LEN -gt 0 ]; then
    echo "No ${STATUS:-\b} outputs have been found"
    return
  fi

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    [ $INDEX -gt 0 ] && echo

    local NAME=$(element "$OUTPUTS" "$INDEX" | value)
    show_output "$NAME"
  done
}

set_layout () {
  local OUTPUTS=$(outputs active)
  local LEN=$(count "$OUTPUTS")

  if [ $LEN = 0 ]; then
    echo "No active outputs have been found"
    return
  elif [ $LEN = 1 ]; then
    echo "No layout can be set for one active output"
    return
  elif [ $LEN -gt 3 ]; then
    echo "No layouts found for more than three outputs"
    return
  fi

  local LAYOUTS=""

  if [ $LEN = 2 ]; then
    LAYOUTS+="Side by Side${KVS}row-2${AES}"
    LAYOUTS+="Top Bottom${KVS}col-2"

    echo "Side by Side | Top Bottom"
    echo "[A][B]         [A]"
    echo "               [B]"
  elif [ $LEN = 3 ]; then
    LAYOUTS+="Side by Side${KVS}row-3${AES}"
    LAYOUTS+="Top Bottom${KVS}col-3${AES}"
    LAYOUTS+="Left Gamma${KVS}gamma-3${AES}"
    LAYOUTS+="Right Gamma${KVS}gamma-rev-3${AES}"
    LAYOUTS+="Left Lambda${KVS}lambda-3${AES}"
    LAYOUTS+="Right Lambda${KVS}lambda-rev-3"

    echo "Side by Side | Top Bottom | Left Gamma | Right Gamma | Left Lambda | Right Lambda"
    echo "[A][B][C]      [A]          [A][B]       [A][B]        [A]              [A]"
    echo "               [B]          [C]             [C]        [B][C]        [B][C]"
    echo "               [C]"
  fi

  local MODE="vertical-6"
  [ $(count "$LAYOUTS") -lt 3 ] && MODE="horizontal"

  pick_one "Select a layout mode:" "$LAYOUTS" "$MODE"
  [ -z "$REPLY" ] && return

  local LAYOUT=$(value "$REPLY")

  MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"

  local SPOTS=$(echo "$LEN" | awk '{for(i=65; i<65+$0; i++) printf "%c,",i}')
  pick_by_order "Pick outputs by order to match ${SPOTS::-1}:" "$OUTPUTS" "$LEN" "$MODE"
  [ -z "$REPLY" ] && return

  local A=$(element "$REPLY" 0 | value)
  local B=$(element "$REPLY" 1 | value)
  if [ $LEN = 3 ]; then
    local C=$(element "$REPLY" 2 | value)
  fi

  case "$LAYOUT" in
    "row-2")
      xrandr --output "$A" --left-of "$B" &&
        echo "Outputs laid out in side by side mode" ||
        echo "Unable to lay out outputs in side by side mode";;
    "col-2")
      xrandr --output "$A" --above "$B" &&
        echo "Outputs laid out in top bottom mode" ||
        echo "Unable to lay out outputs in top bottom mode";;
    "row-3")
      xrandr --output "$A" --left-of "$B" --output "$B" --left-of "$C" &&
        echo "Outputs laid out in side by side mode" ||
        echo "Unable to lay out outputs in side by side mode";;
    "col-3")
      xrandr --output "$A" --above "$B" --output "$B" --above "$C" &&
        echo "Outputs laid out in top bottom mode" ||
        echo "Unable to lay out outputs in top bottom mode";;
    "gamma-3")
      xrandr --output "$A" --left-of "$B" --output "$C" --below "$A" &&
        echo "Outputs laid out in left gamma mode" ||
        echo "Unable to lay out outputs in left gamma mode";;
    "gamma-rev-3")
      xrandr --output "$A" --left-of "$B" --output "$C" --below "$B" &&
        echo "Outputs laid out in right gamma mode" ||
        echo "Unable to lay out outputs in right gamma mode";;
    "lambda-3")
      xrandr --output "$A" --above "$B" --output "$B" --left-of "$C" &&
        echo "Outputs laid out in left lambda mode" ||
        echo "Unable to lay out outputs in left lambda mode";;
    "lambda-rev-3")
      xrandr --output "$A" --left-of "$C" --output "$A" --above "$C" &&
        echo "Outputs laid out in right lambda mode" ||
        echo "Unable to lay out outputs in right lambda mode";;
    *) echo "Unable to set the layout: '$LAYOUT'"; return 1;;
  esac
}

set_mode () {
  local NAME=$1
  local RESOLUTION=$2
  local RATE=$3

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi

  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find $NAME output"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot set mode of a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot set mode of an inactive"
    return 1
  fi

  if [ -z "$RESOLUTION" ]; then
    pick_resolution "$OUTPUT" || return 1
    [ -z "$REPLY" ] && return
    
    RESOLUTION=$(value "$REPLY")
  fi

  if [ -z "$RATE" ]; then
    pick_rate "$OUTPUT" "$RESOLUTION" || return 1
    [ -z "$REPLY" ] && return
    
    RATE=$(value "$REPLY")
  fi

  xrandr --output "$NAME" --mode "$RESOLUTION" --rate "$RATE" &&
    echo "Output $NAME mode set to $RESOLUTION@${RATE}Hz" ||
    echo "Unable to set mode for output $NAME"
}

restore () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find $NAME output"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot restore a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot restore an inactive output"
    return 1
  fi

  xrandr --output "$NAME" --auto &&
    echo "Output $NAME has been set to auto mode" ||
    echo "Unable to restore the output $NAME"
}

set_primary () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find $NAME output"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot set primary a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot set primary an inactive output"
    return 1
  elif is_primary "$OUTPUT"; then
    echo "Output $NAME is already the primary"
    return 1
  fi

  xrandr --output "$NAME" --primary &&
    echo "Output $NAME has been set as primary" ||
    echo "Unable to set the primary output $NAME"
}

set_on () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output inactive || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find $NAME output"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot activate a disconnected output"
    return 1
  elif is_active "$OUTPUT"; then
    echo "Output $NAME is already active"
    return 1
  fi

  xrandr --output "$NAME" --auto &&
    echo "Output $NAME has been activated" ||
    echo "Unable to activate the output $NAME"
}

set_off () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find $NAME output"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot deactivate a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Output $NAME is already inactive"
    return 1
  elif is_primary "$OUTPUT"; then
    echo "Cannot deactivate the primary output"
    return 1
  fi

  xrandr --output "$NAME" --off &&
    echo "Output $NAME has been deactivated" ||
    echo "Unable to deactivate the output $NAME"
}

reflect () {
  local NAME=$1
  local MODE=$2

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find $NAME output"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot reflect a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot reflect an inactive output"
    return 1
  fi

  if [ -z "$MODE" ]; then
    local MODES=""
    MODES+="Normal${KVS}normal${AES}"
    MODES+="X Axis${KVS}x${AES}"
    MODES+="Y Axis${KVS}y${AES}"
    MODES+="XY Axes${KVS}xy"

    pick_one "Select a reflection mode:" "$MODES" "vertical-4"
    [ -z "$REPLY" ] && return
    
    MODE=$(value "$REPLY")
  fi
  
  if [[ ! "$MODE" =~ ^(normal|x|y|xy)$ ]]; then
    echo "Invalid reflection mode argument: '$MODE'"
    return 1
  fi

  xrandr --output "$NAME" --reflect "$MODE" &&
    echo "Output $NAME has been reflected to $MODE mode" ||
    echo "Unable to reflect the output $NAME"
}

rotate () {
  local NAME=$1
  local MODE=$2

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find $NAME output"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot reflect a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot reflect an inactive output"
    return 1
  fi

  if [ -z "$MODE" ]; then
    local MODES=""
    MODES+="Normal${KVS}normal${AES}"
    MODES+="Right 90°${KVS}right${AES}"
    MODES+="Left 90°${KVS}left${AES}"
    MODES+="Inverted 180°${KVS}inverted"

    pick_one "Select a rotation mode:" "$MODES" "vertical-6"
    [ -z "$REPLY" ] && return
    
    MODE=$(value "$REPLY")
  fi
  
  if [[ ! "$MODE" =~ ^(normal|right|left|inverted)$ ]]; then
    echo "Invalid rotation mode argument: '$MODE'"
    return 1
  fi

  xrandr --output "$NAME" --rotate "$MODE" &&
    echo "Output $NAME has been rotated to $MODE mode" ||
    echo "Unable to rotate the output $NAME"
}

save_layout () {
  local OUTPUTS=$(outputs)
  local LEN=$(count "$OUTPUTS")
  
  if [ $LEN = 0 ]; then
    echo "No outputs have found"
    return 1
  fi

  rm -f ~/.config/stack/layout

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    local NAME=$(element "$OUTPUTS" "$INDEX" | value)
    local OUTPUT=$(output "$NAME")

    echo "$OUTPUT" | head -n 1 >> ~/.config/stack/layout
  done
}

load_layout () {
  if [ ! -f ~/.config/stack/layout ]; then
    echo "No layout config file found, fallback to auto"
    return
  fi

  local ARGS=$(awk -F$AES '{
    if ($8) {
      if (!$6) $6="normal";
      if (!$7) $7="normal";
      args="--output "$1" --mode "$8" --rate "$9" --pos "$5" --rotate "$6" --reflect "$7
      if ($3 == "primary") args=args" --primary"
      print args
    } else {
      print "--output "$1" --off"
    }
  }' ~/.config/stack/layout | tr $'\n' ' ')

  xrandr $ARGS &&
    echo "Layout configuration has been loaded" ||
    echo "Unable to load layout configuration"
}

help () {
  local FRM=" %-45s\t%s\n"

  if [ "$1" = "once" ]; then
    echo "Usage: screens COMMAND"

    echo -e "\nCOMMANDS"
    printf "$FRM" \
      "help" "Show this message" \
      "load layout" "Load screens output layout"

    return
  fi

  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf "$FRM" \
    "help" "Show this help message." \
    "show status" "Show a report of the xorg server and screens." \
    "show output [<name>]" "Show the data of the given output." \
    "" "" \
    "list outputs [<status>]" "List all outputs or by the given status," \
    "" "connected, disconnected, active or primary." \
    "" "" \
    "set layout" "Set the layout of active outputs." \
    "set mode [<name> [<res> [<rate>]]]" "Set the mode of the given output." \
    "set primary [<name>]" "Set the primary output." \
    "set on|off [<name>]" "Set active or inactive the given output." \
    "save layout" "Persist the current screen layout to be applied in next boot." \
    "" "" \
    "rotate [<name> normal|right|left|inverted]" "Set output rotation to normal, right, left or inverted." \
    "reflect [<name> normal|x|y|xy]" "Set output reflection to normal, x, y or xy axes." \
    "restore [<name>]" "Restore the given output to auto mode."

  echo -e "\nOBJECTS"
  printf "$FRM" \
    "status" "The status of xorg server and screen layouts." \
    "output" "An output display device." \
    "layout" "The layout of multiple outputs setup." \
    "mode" "The resolution and rate of an output." \
    "primary" "The main output in a multihead layout."
}

loop () {
  clear

  while true; do
    prompt && history -s "$REPLY"

    set -f
    set_separator "line"
    local CMD=($(xargs -n1 <<< "$REPLY"))
    restore_separator && set +f

    if [ "${CMD[0]}" = "help" ]; then
      help
      continue
    elif [ "${CMD[0]}" = "clear" ]; then
      clear
      continue
    elif [ "${CMD[0]}" = "quit" ]; then
      break
    elif [ -z "${CMD[0]}" ]; then
      continue
    fi

    case "${CMD[0]}" in
      "show")
        case "${CMD[1]}" in
          "status") show_status;;
          "output") show_output "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "list")
        case "${CMD[1]}" in
          "outputs") list_outputs "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "set")
        case "${CMD[1]}" in
          "layout") set_layout;;
          "mode") set_mode "${CMD[2]}" "${CMD[3]}" "${CMD[4]}";;
          "primary") set_primary "${CMD[2]}";;
          "on") set_on "${CMD[2]}";;
          "off") set_off "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "save")
        case "${CMD[1]}" in
          "layout") save_layout;;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "rotate") rotate "${CMD[1]}" "${CMD[2]}";;
      "reflect") reflect "${CMD[1]}" "${CMD[2]}";;
      "restore") restore "${CMD[1]}";;
      *) echo "Unknown or invalid command: '$REPLY'";;
    esac
  done

  clear
}

once () {
  case "$1" in
    "help") help "once";;
    "load")
      case "$2" in
        "layout") load_layout;;
        *) abort "Unknown or invalid command: '$1'";; 
      esac;;
    *) abort "Unknown or invalid command: '$1'";; 
  esac
}

if [ $# = 0 ]; then
  loop
else
  once "$@"
fi
