#!/usr/bin/env bash

set -o pipefail

source /opt/stack/utils

require "xorg-xrandr"

get_screen () {
  local INDEX=${1:-"0"}

  local SCREEN=$(xrandr --current | sed "/^Screen ${INDEX}:/,/^Screen/!d;//d" || echo "err:$?")

  if [[ "$SCREEN" =~ ^err: ]]; then
    return 1
  fi

  echo "$SCREEN"
}

get_primary () {
  local SCREEN=$(get_screen 0 || echo "err:$?")
  
  if [[ "$SCREEN" =~ ^err: ]]; then
    return 1
  fi

  local NAME=$(echo "$SCREEN" |
    awk 'match($0, /(.*) connected primary .*/, a) {print a[1]}')
  
  local RESOLUTION=$(echo "$SCREEN" |
    awk 'match($0, /.* connected primary ([0-9]+x[0-9]+)\+.*/, a) {print a[1]}')

  local RATE=$(echo "$SCREEN" |
    sed -n '/.* connected primary .*/{:a;N;/\*/!ba;/\*/p}' |
    awk 'match($0, /.* ([0-9]{2}).[0-9]{2}\*.*/, a) {print a[1]"Hz"}')
  
  local PRIMARY="${NAME}|${RESOLUTION}|${RATE}"

  echo "$PRIMARY"
}

get_outputs () {
  local STATUS=$1

  if [ -n "$STATUS" ] && [[ ! "$STATUS" =~ ^(connected|disconnected|active|inactive)$ ]]; then
    return 1
  fi

  local SCREEN=$(get_screen 0 || echo "err:$?")

  if [[ "$SCREEN" =~ ^err: ]]; then
    return 1
  fi

  local PATTERN='^[A-Z]+-[0-9]+'
  if [[ "$STATUS" =~ (dis)?connected ]]; then
    PATTERN+="\s${STATUS}"
  elif [ "$STATUS" = "active" ]; then
    PATTERN+='\sconnected.*\s([0-9]+x[0-9]+)\+.*'
  elif [ "$STATUS" = "inactive" ]; then
    PATTERN+='\sconnected\s\(.*'
  fi

  local OUTPUTS=$(echo "$SCREEN" | awk '/'${PATTERN}'/{print $1}')

  echo "$OUTPUTS" | tr $'\n' "$ES"
}

count_outputs () {
  local STATUS=$1

  local OUTPUTS=$(get_outputs "$STATUS")

  if [ -z "$OUTPUTS" ]; then
    return 0
  fi

  echo "$OUTPUTS" | wc -l
}

get_resolutions () {
  local OUTPUT=$1

  local SCREEN=$(get_screen 0 || echo "err:$?")

  if [[ "$SCREEN" =~ ^err: ]]; then
    return 1
  fi

  local RESOLUTIONS="$(echo "$SCREEN" | awk /^$OUTPUT/,!// | tail -n +2 |
    awk '{if ($0 ~ /^\s+[0-9]+x[0-9]+/) {print $1} else {exit}}')"

  echo "$RESOLUTIONS"
}

get_rates () {
  local OUTPUT=$1
  local RESOLUTION=$2

  local SCREEN=$(get_screen 0 || echo "err:$?")

  if [[ "$SCREEN" =~ ^err: ]]; then
    return 1
  fi

  local RATES="$(echo "$SCREEN" | awk /^$OUTPUT/,!// | tail -n +2 |
    awk '{if ($0 ~ /\s'$RESOLUTION'\s/) {print $0; exit}}' |
    sed 's/'$RESOLUTION'//' | trim | tr -d '+*' | sed 's/ \{1,\}/\n/g')"

  echo "$RATES"
}

exists () {
  local OUTPUT=$1

  local SCREEN=$(get_screen 0 || echo "err:$?")

  if [[ "$SCREEN" =~ ^err: ]]; then
    return 1
  fi

  local HEAD=$(echo "$SCREEN" | awk "/^${OUTPUT} /")

  [ -n "$HEAD" ] && return 0 || return 1
}

is_connected () {
  local OUTPUT=$1

  local SCREEN=$(get_screen 0 || echo "err:$?")

  if [[ "$SCREEN" =~ ^err: ]]; then
    return 1
  fi

  local HEAD=$(echo "$SCREEN" | awk "/^${OUTPUT} /")

  if [ -z "$HEAD" ]; then
    return 1
  fi

  local STATUS="$(echo "$HEAD" | awk 'match($0, /.* ((dis)?connected) .*/, a) {print a[1]}')"

  [ "$STATUS" = "connected" ] && return 0 || return 1
}

is_active () {
  local OUTPUT=$1

  local SCREEN=$(get_screen 0 || echo "err:$?")

  if [[ "$SCREEN" =~ ^err: ]]; then
    return 1
  fi

  local HEAD=$(echo "$SCREEN" | awk "/^${OUTPUT} /")

  if [ -z "$HEAD" ]; then
    return 1
  fi

  local STATUS="$(echo "$HEAD" | awk 'match($0, /.* ((dis)?connected) .*/, a) {print a[1]}')"
  local RESOLUTION="$(echo "$HEAD" | awk 'match($0, /.* ([0-9]+x[0-9]+)\+.*/, a) {print a[1]}')"

  [ "$STATUS" = "connected" ] && [ -n "$RESOLUTION" ] &&
    return 0 || return 1
}

is_primary () {
  local OUTPUT=$1

  local PRIMARY=$(get_primary || echo "err:$?")

  if [[ "$PRIMARY" =~ ^err: ]]; then
    return 1
  fi
  
  [[ "$PRIMARY" =~ ^$OUTPUT ]] && return 0 || return 1
}

pick_output () {
  local STATUS=$1

  local OUTPUTS=$(get_outputs "$STATUS" | awk '{if ($0) {print NR-1"|"$0"|"$0}}' || echo "err:$?")
  
  if [[ "$OUTPUTS" =~ ^err: ]]; then
    [ -n "$STATUS" ] && echo "Unable to find $STATUS outputs" ||
      echo "Unable to find outputs"
    return 1
  fi
  
  OUTPUTS=($OUTPUTS)

  if [ ! ${#OUTPUTS[@]} -gt 0 ]; then
    [ -n "$STATUS" ] && echo "No $STATUS outputs have been found" ||
      echo "No outputs have been found"
    return 1
  fi
  
  pick "Select an output:" "${OUTPUTS[@]}"
  REPLY=$(echo "${OUTPUTS[$REPLY]}" | cut -d '|' -f 2)
}

pick_resolution () {
  local OUTPUT=$1

  local RESOLUTIONS=$(get_resolutions "$OUTPUT" | awk '{if ($0) {print NR-1"|"$0"|"$0}}' || echo "err:$?")
  
  if [[ "$RESOLUTIONS" =~ ^err: ]]; then
    echo "Unable to find resolutions for $OUTPUT output"
    return 1
  fi
  
  RESOLUTIONS=($RESOLUTIONS)

  if [ ! ${#RESOLUTIONS[@]} -gt 0 ]; then
    echo "No resolutions have been found for $OUTPUT output"
    return 1
  fi
  
  pick "Select a resolution:" "${RESOLUTIONS[@]}"
  REPLY=$(echo "${RESOLUTIONS[$REPLY]}" | cut -d '|' -f 2)
}

pick_rate () {
  local OUTPUT=$1
  local RESOLUTION=$2

  local RATES=$(get_rates "$OUTPUT" "$RESOLUTION" | awk '{if ($0) {print NR-1"|"$0"|"$0}}' || echo "err:$?")

  if [[ "$RATES" =~ ^err: ]]; then
    echo "Unable to find rates for $OUTPUT output"
    return 1
  fi
  
  RATES=($RATES)

  if [ ! ${#RATES[@]} -gt 0 ]; then
    echo "No rates have been found for $OUTPUT output"
    return 1
  fi
  
  pick "Select a rate:" "${RATES[@]}"
  REPLY=$(echo "${RATES[$REPLY]}" | cut -d '|' -f 2)
}

prompt () {
  local PRIMARY=$(get_primary || echo "err:$?")

  if [[ "$PRIMARY" =~ ^err: ]]; then
    read -rep "[screens:${RE}none$RS] " REPLY
    return 1
  fi

  local NAME=$(echo "$PRIMARY" | cut -d '|' -f 1)
  local RESOLUTION=$(echo "$PRIMARY" | cut -d '|' -f 2)
  local RATE=$(echo "$PRIMARY" | cut -d '|' -f 3)

  local STATUS="$YE${NAME}$RS"

  if [ -n "$RESOLUTION" ]; then
    STATUS+=" $YE${RESOLUTION}$RS"
    [ -n "$RATE" ] && STATUS+="$GR@${RATE}$RS"
  fi

  read -rep "[screens:$STATUS] " REPLY
}

show_status () {
  if [ -z "$DISPLAY" ]; then
    echo "Unable to resolve the xorg server"
    return 1
  fi

  local PATTERN='/^('
  PATTERN+='name\sof\sdisplay|'
  PATTERN+='version\snumber|'
  PATTERN+='vendor\sstring|'
  PATTERN+='vendor\srelease\snumber|'
  PATTERN+='X.Org\sversion|'
  PATTERN+='motion\sbuffer\ssize|'
  PATTERN+='image\sbyte\sorder|'
  PATTERN+='default\sscreen\snumber|'
  PATTERN+='number\sof\sscreens'
  PATTERN+=')/'

  xdpyinfo -display "$DISPLAY" |
    awk -F': ' $PATTERN'{ \
      gsub(/[ \t]+$/, "", $1); \
      gsub(/^[ \t]+/, "", $2); \
      printf "%-23s %s\n",$1":",$2 \
    }' | sed -r 's/\<./\U&/g'
  
  local SCREEN=$(get_screen 0 || echo "err:$?")

  if [[ "$SCREEN" =~ ^err: ]]; then
    echo "Unable to find the default screen"
    return 1
  fi

  local OUTPUTS=$(get_outputs connected || echo "err:$?")

  if [[ "$OUTPUTS" =~ ^err ]]; then
    echo "Unable to get connected outputs"
    return 1
  fi

  OUTPUTS=($OUTPUTS)
  LEN=${#OUTPUTS[@]}

  if [ $LEN = 0 ]; then
    echo "Connected Outputs:      none"
    return
  fi

  local CONNECTED="Connected Outputs:      "

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    local OUTPUT=${OUTPUTS[$INDEX]}
    local HEAD=$(echo "$SCREEN" | awk "/^$OUTPUT /")

    local NAME="$(echo "$HEAD" | awk 'match($0, /(.*) connected .*/, a) {print a[1]}')"

    local RESOLUTION="$(echo "$HEAD" | awk 'match($0, /.* ([0-9]+x[0-9]+)\+.*/, a) {print a[1]}')"
    [ -z "$RESOLUTION" ] && RESOLUTION="inactive"

    local PRIMARY="$(echo "$HEAD" | awk 'match($0, /.* connected (primary) .*/, a) {print a[1]}')"
    [ -n "$PRIMARY" ] && PRIMARY="*"

    local RATE="$(echo "$SCREEN" | sed -n "/$OUTPUT .*/{:a;N;/\*/!ba;/\*/p}" |
      awk 'match($0, /.* ([0-9]{2}).[0-9]{2}\*.*/, a) {print "@"a[1]"Hz"}')"

    if [ $INDEX = 0 ]; then
      CONNECTED+="$NAME [${RESOLUTION}$RATE]$PRIMARY"
    else
      CONNECTED+="\n                        $NAME [${RESOLUTION}$RATE]$PRIMARY"
    fi
  done

  echo -e "$CONNECTED"
}

show_output () {
  local OUTPUT=$1

  if [ -z "$OUTPUT" ]; then
    pick_output || return 1
    OUTPUT=$REPLY
  fi

  local SCREEN=$(get_screen 0 || echo "err:$?")

  if [[ "$SCREEN" =~ ^err: ]]; then
    echo "Unable to find the default screen"
    return 1
  fi

  local HEAD=$(echo "$SCREEN" | awk "/^${OUTPUT} /")

  if [ -z "$HEAD" ]; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  fi

  local NAME="$(echo "$HEAD" | awk 'match($0, /(.*) ((dis)?connected) .*/, a) {print a[1]}')"
  local STATUS="$(echo "$HEAD" | awk 'match($0, /.* ((dis)?connected) .*/, a) {print a[1]}')"

  local PRIMARY="no"
  if is_primary "$OUTPUT"; then
    PRIMARY="yes"
  fi

  local ACTIVE="no"
  local RESOLUTION="N/A"
  local RATE="N/A"
  local POSITION="N/A"
  local DIMS="N/A"

  if is_active "$OUTPUT"; then
    ACTIVE="yes"
  
    RESOLUTION="$(echo "$HEAD" | awk 'match($0, /.* ([0-9]+x[0-9]+)\+.*/, a) {print a[1]}')"
    [ -z "$RESOLUTION" ] && RESOLUTION="N/A"

    RATE="$(echo "$SCREEN" | sed -n "/$OUTPUT .*/{:a;N;/\*/!ba;/\*/p}" |
      awk 'match($0, /.* ([0-9]{2}).[0-9]{2}\*.*/, a) {print a[1]"Hz"}')"
    [ -z "$RATE" ] && RATE="N/A"

    POSITION="$(echo "$HEAD" | awk 'match($0, /.* [0-9]+x[0-9]+\+([0-9]+\+[0-9]+) .*/, a) {print a[1]}')"
    [ -n "$POSITION" ] && POSITION="[$(echo "$POSITION" | tr '+' ",")]" || POSITION="N/A"

    DIMS="$(echo "$HEAD" | awk 'match($0, /.* ([0-9]+mm x [0-9]+mm).*/, a) {print a[1]}')"
    [ -z "$DIMS" ] && DIMS="N/A"
  fi

  local ORIENTATION="$(echo "$HEAD" | awk 'match($0, /.* (\(.*\)).*/, a) {print a[1]}')"
  [ -n "$ORIENTATION" ] && ORIENTATION="$(echo "$ORIENTATION" | tr -d "(,)")"

  local PROFILES="$(echo "$SCREEN" | awk /^$OUTPUT/,!// | tail -n +2 |
    awk '{if ($0 ~ /^\s+[0-9]+x[0-9]+/) {print "          "$0} else {exit}}')"
  [ -n "$PROFILES" ] && PROFILES="${PROFILES:13}" || PROFILES="N/A"

  local FRM=""
  FRM+="Name:        %s\n"
  FRM+="Primary:     %s\n"
  FRM+="Active:      %s\n"
  FRM+="Status:      %s\n"
  FRM+="Resolution:  %s\n"
  FRM+="Frequency:   %s\n"
  FRM+="Position:    %s\n"
  FRM+="Dimensions:  %s\n"
  FRM+="Orientation: %s\n"
  FRM+="Profiles:    %s\n"

  printf "$FRM" \
    "$NAME" "$PRIMARY" "$ACTIVE" "$STATUS" "$RESOLUTION" "$RATE" "$POSITION" "$DIMS" "$ORIENTATION" "$PROFILES"
}

list_outputs () {
  local STATUS=$1

  if [ -n "$STATUS" ] && [[ ! "$STATUS" =~ ^(connected|disconnected|active|inactive)$ ]]; then
    echo "Invalid status argument: '$STATUS'"
    return 1
  fi

  local OUTPUTS=$(get_outputs "$STATUS" || echo "err:$?")

  if [[ "$OUTPUTS" =~ ^err: ]]; then
    [ -n "$STATUS" ] && echo "Unable to retrieve $STATUS outputs" ||
      echo "Unable to retrieve outputs"
    return 1
  fi

  OUTPUTS=($OUTPUTS)
  local LEN=${#OUTPUTS[@]}

  if [ ! $LEN -gt 0 ]; then
    [ -n "$STATUS" ] && echo "No $STATUS outputs have been found" ||
      echo "No outputs have been found"
    return
  fi

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    [ $INDEX -gt 0 ] && echo
    show_output "${OUTPUTS[$INDEX]}" | head -n 7
  done
}

set_layout () {
  local OUTPUTS=$(get_outputs "active" || echo "err:$?")

  if [[ "$OUTPUTS" =~ ^err: ]]; then
    echo "Unable to retrieve outputs"
    return 1
  elif [ -z "$OUTPUTS" ]; then
    echo "No outputs have been found"
    return 1
  fi

  local LEN=$(count "$OUTPUTS")

  if [ $LEN = 1 ]; then
    echo "No layout can be set for one active output"
    return
  elif [ $LEN -gt 3 ]; then
    echo "No layouts found for more than three outputs"
    return
  fi

  local LAYOUTS=""

  if [ $LEN = 2 ]; then
    LAYOUTS+="Side by Side${LS}row-2${ES}"
    LAYOUTS+="Top Bottom${LS}col-2"

    echo "Side by Side | Top Bottom"
    echo "[A][B]         [A]"
    echo "               [B]"
  elif [ $LEN = 3 ]; then
    LAYOUTS+="Side by Side${LS}row-3${ES}"
    LAYOUTS+="Top Bottom${LS}col-3${ES}"
    LAYOUTS+="Left Gamma${LS}gamma-3${ES}"
    LAYOUTS+="Right Gamma${LS}gamma-rev-3${ES}"
    LAYOUTS+="Left Lambda${LS}lambda-3${ES}"
    LAYOUTS+="Right Lambda${LS}lambda-rev-3"

    echo "Side by Side | Top Bottom | Left Gamma | Right Gamma | Left Lambda | Right Lambda"
    echo "[A][B][C]      [A]          [A][B]       [A][B]        [A]              [A]"
    echo "               [B]          [C]             [C]        [B][C]        [B][C]"
    echo "               [C]"
  fi

  local MODE="vertical-6"
  [ $(count "$LAYOUTS") -lt 3 ] && MODE="horizontal"
  pick_one "Select a layout mode:" "$LAYOUTS" "$MODE"
  
  if [ -z "$REPLY" ]; then
    return
  fi

  local LAYOUT=$(get_value "$REPLY")

  MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"

  local SPOTS=$(echo "$LEN" | awk '{for(i=65; i<65+$0; i++) printf "%c,",i}')
  pick_by_order "Pick outputs by order to match ${SPOTS::-1}:" "$OUTPUTS" "$LEN" "$MODE"

  if [ -z "$REPLY" ]; then
    return
  fi

  set_separator "$ES"
  OUTPUTS=($REPLY)
  restore_separator

  case "$LAYOUT" in
    "row-2")
      xrandr --output "${OUTPUTS[0]}" --left-of "${OUTPUTS[1]}" &&
        echo "Outputs laid out in side by side mode" ||
        echo "Unable to lay out outputs in side by side mode";;
    "col-2")
      xrandr --output "${OUTPUTS[0]}" --above "${OUTPUTS[1]}" &&
        echo "Outputs laid out in top bottom mode" ||
        echo "Unable to lay out outputs in top bottom mode";;
    "row-3")
      xrandr --output "${OUTPUTS[0]}" --left-of "${OUTPUTS[1]}" \
        --output "${OUTPUTS[1]}" --left-of "${OUTPUTS[2]}" &&
        echo "Outputs laid out in side by side mode" ||
        echo "Unable to lay out outputs in side by side mode";;
    "col-3")
      xrandr --output "${OUTPUTS[0]}" --above "${OUTPUTS[1]}" \
        --output "${OUTPUTS[1]}" --above "${OUTPUTS[2]}" &&
        echo "Outputs laid out in top bottom mode" ||
        echo "Unable to lay out outputs in top bottom mode";;
    "gamma-3")
      xrandr --output "${OUTPUTS[0]}" --left-of "${OUTPUTS[1]}" \
        --output "${OUTPUTS[2]}" --below "${OUTPUTS[0]}" &&
        echo "Outputs laid out in gamma mode" ||
        echo "Unable to lay out outputs in gamma mode";;
    "gamma-rev-3")
      xrandr --output "${OUTPUTS[0]}" --left-of "${OUTPUTS[1]}" \
        --output "${OUTPUTS[2]}" --below "${OUTPUTS[1]}" &&
        echo "Outputs laid out in reverse gamma mode" ||
        echo "Unable to lay out outputs in reverse gamma mode";;
    "lambda-3")
      xrandr --output "${OUTPUTS[0]}" --above "${OUTPUTS[1]}" \
        --output "${OUTPUTS[1]}" --left-of "${OUTPUTS[2]}" &&
        echo "Outputs laid out in lambda mode" ||
        echo "Unable to lay out outputs in lambda mode";;
    "lambda-rev-3")
      xrandr --output "${OUTPUTS[1]}" --left-of "${OUTPUTS[2]}" \
        --output "${OUTPUTS[0]}" --above "${OUTPUTS[2]}" &&
        echo "Outputs laid out in reverse lambda mode" ||
        echo "Unable to lay out outputs in reverse lambda mode";;
    *) echo "Unable to set the layout: '$LAYOUT'"; return 1;;
  esac
}

set_mode () {
  local OUTPUT=$1
  local RESOLUTION=$2
  local RATE=$3

  if [ -z "$OUTPUT" ]; then
    pick_output "active" || return 1
    OUTPUT=$REPLY
  fi
  
  if ! exists "$OUTPUT"; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot set mode of a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot set mode of an inactive"
    return 1
  fi

  if [ -z "$RESOLUTION" ]; then
    pick_resolution "$OUTPUT" || return 1
    RESOLUTION=$REPLY
  fi

  if [ -z "$RATE" ]; then
    pick_rate "$OUTPUT" "$RESOLUTION" || return 1
    RATE=$REPLY
  fi

  xrandr --output "$OUTPUT" --mode "$RESOLUTION" --rate "$RATE" &&
    echo "Output $OUTPUT mode set to $RESOLUTION@${RATE}Hz" ||
    echo "Unable to set mode for output $OUTPUT"
}

restore () {
  local OUTPUT=$1

  if [ -z "$OUTPUT" ]; then
    pick_output "active" || return 1
    OUTPUT=$REPLY
  fi
  
  if ! exists "$OUTPUT"; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot restore a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot restore an inactive output"
    return 1
  fi

  xrandr --output "$OUTPUT" --auto &&
    echo "Output $OUTPUT has been set to auto mode" ||
    echo "Unable to restore the output $OUTPUT"
}

set_primary () {
  local OUTPUT=$1

  if [ -z "$OUTPUT" ]; then
    pick_output "active" || return 1
    OUTPUT=$REPLY
  fi
  
  if ! exists "$OUTPUT"; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot set primary a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot set primary an inactive output"
    return 1
  elif is_primary "$OUTPUT"; then
    echo "Output $OUTPUT is already the primary"
    return 1
  fi

  xrandr --output "$OUTPUT" --primary &&
    echo "Output $OUTPUT has been set as primary" ||
    echo "Unable to set the primary output $OUTPUT"
}

set_on () {
  local OUTPUT=$1

  if [ -z "$OUTPUT" ]; then
    pick_output "inactive" || return 1
    OUTPUT=$REPLY
  fi
  
  if ! exists "$OUTPUT"; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot activate a disconnected output"
    return 1
  elif is_active "$OUTPUT"; then
    echo "Output $OUTPUT is already active"
    return 1
  fi

  xrandr --output "$OUTPUT" --auto &&
    echo "Output $OUTPUT has been activated" ||
    echo "Unable to activate the output $OUTPUT"
}

set_off () {
  local OUTPUT=$1

  if [ -z "$OUTPUT" ]; then
    pick_output "active" || return 1
    OUTPUT=$REPLY
  fi
  
  if ! exists "$OUTPUT"; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot deactivate a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Output $OUTPUT is already inactive"
    return 1
  elif is_primary "$OUTPUT"; then
    echo "Cannot deactivate the primary output"
    return 1
  elif [ $(count_outputs "active") -lt 2 ]; then
    echo "Cannot deactivate the only active output"
    return 1
  fi

  xrandr --output "$OUTPUT" --off &&
    echo "Output $OUTPUT has been deactivated" ||
    echo "Unable to deactivate the output $OUTPUT"
}

reflect () {
  local OUTPUT=$1
  local MODE=$2

  if [ -z "$OUTPUT" ]; then
    pick_output "active" || return 1
    OUTPUT=$REPLY
  fi
  
  if ! exists "$OUTPUT"; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot reflect a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot reflect an inactive output"
    return 1
  fi

  if [ -z "$MODE" ]; then
    local MODES=("0|normal|Normal" "1|x|X Axis" "2|y|Y Axis" "3|xy|XY Axes")

    pick "Select a reflection mode:" "${MODES[@]}"
    MODE=$(echo "${MODES[$REPLY]}" | cut -d '|' -f 2)
  elif [[ ! "$MODE" =~ ^(normal|x|y|xy)$ ]]; then
    echo "Invalid reflection mode argument: '$MODE'"
    return 1
  fi

  xrandr --output "$OUTPUT" --reflect "$MODE" &&
    echo "Output $OUTPUT has been reflected to $MODE mode" ||
    echo "Unable to reflect the output $OUTPUT"
}

rotate () {
  local OUTPUT=$1
  local MODE=$2

  if [ -z "$OUTPUT" ]; then
    pick_output "active" || return 1
    OUTPUT=$REPLY
  fi
  
  if ! exists "$OUTPUT"; then
    echo "Unable to find output: '$OUTPUT'"
    return 1
  elif ! is_connected "$OUTPUT"; then
    echo "Cannot reflect a disconnected output"
    return 1
  elif ! is_active "$OUTPUT"; then
    echo "Cannot reflect an inactive output"
    return 1
  fi

  if [ -z "$MODE" ]; then
    local MODES=("0|normal|Normal" "1|right|Right 90°" "2|left|Left 90°" "3|inverted|Inverted 180°")

    pick "Select a rotation mode:" "${MODES[@]}"
    MODE=$(echo "${MODES[$REPLY]}" | cut -d '|' -f 2)
  elif [[ ! "$MODE" =~ ^(normal|right|left|inverted)$ ]]; then
    echo "Invalid rotation mode argument: '$MODE'"
    return 1
  fi

  xrandr --output "$OUTPUT" --rotate "$MODE" &&
    echo "Output $OUTPUT has been rotated to $MODE mode" ||
    echo "Unable to rotate the output $OUTPUT"
}

help () {
  local FRM=" %-45s\t%s\n"

  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf "$FRM" \
    "help" "Show this help message." \
    "show status" "Show a report of the xorg server and screens." \
    "show output [<output>]" "Show the data of the given output." \
    "" "" \
    "list outputs [<status>]" "List all outputs or by the given status," \
    "" "connected, disconnected or active." \
    "" "" \
    "set layout" "Set the layout of active outputs." \
    "set mode [<output> [<res> [<rate>]]]" "Set the mode of the given output." \
    "set primary [<output>]" "Set the primary output." \
    "set on|off [<output>]" "Set active or inactive the given output." \
    "" "" \
    "rotate [<output> normal|right|left|inverted]" "Set output rotation to normal, right, left or inverted." \
    "reflect [<output> normal|x|y|xy]" "Set output reflection to normal, x, y or xy axes." \
    "restore [<output>]" "Restore the given output to auto mode."

  echo -e "\nOBJECTS"
  printf "$FRM" \
    "status" "The status of xorg server and screen layouts." \
    "output" "An output display device." \
    "layout" "The layout of multiple outputs setup." \
    "mode" "The resolution and rate of an output." \
    "primary" "The main output in a multihead layout."
}

loop () {
  clear

  while true; do
    prompt && history -s "$REPLY"

    set -f
    local OLD_IFS=$IFS && IFS=$'\n'
    local CMD=($(xargs -n1 <<< "$REPLY"))
    IFS=$OLD_IFS && set +f

    if [ "${CMD[0]}" = "help" ]; then
      help
      continue
    elif [ "${CMD[0]}" = "clear" ]; then
      clear
      continue
    elif [ "${CMD[0]}" = "quit" ]; then
      break
    elif [ -z "${CMD[0]}" ]; then
      continue
    fi

    case "${CMD[0]}" in
      "show")
        case "${CMD[1]}" in
          "status") show_status;;
          "output") show_output "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "list")
        case "${CMD[1]}" in
          "outputs") list_outputs "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "set")
        case "${CMD[1]}" in
          "layout") set_layout;;
          "mode") set_mode "${CMD[2]}" "${CMD[3]}" "${CMD[4]}";;
          "primary") set_primary "${CMD[2]}";;
          "on") set_on "${CMD[2]}";;
          "off") set_off "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "rotate") rotate "${CMD[1]}" "${CMD[2]}";;
      "reflect") reflect "${CMD[1]}" "${CMD[2]}";;
      "restore") restore "${CMD[1]}";;
      *) echo "Unknown or invalid command: '$REPLY'";;
    esac
  done

  clear
}

loop
