#!/usr/bin/env bash

set -o pipefail

source /opt/stack/utils

require "xorg-xrandr"

screen () {
  local INDEX=${1:-"0"}

  local SCREEN=$(xrandr --current | sed "/^Screen ${INDEX}:/,/^Screen/!d;//d" || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  echo "$SCREEN"
}

exists () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    return 1
  fi

  local SCREEN=$(screen || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local HEAD=$(echo "$SCREEN" | awk "/^${NAME} /")

  [ -n "$HEAD" ] && return 0 || return 1
}

is_connected () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    return 1
  fi

  local SCREEN=$(screen || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local HEAD=$(echo "$SCREEN" | awk "/^${NAME} /")
  [ -z "$HEAD" ] && return 1

  local STATUS="$(echo "$HEAD" | awk 'match($0, /.* ((dis)?connected) .*/, a) {print a[1]}')"

  [ "$STATUS" = "connected" ] && return 0 || return 1
}

is_active () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    return 1
  fi

  local SCREEN=$(screen || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local HEAD=$(echo "$SCREEN" | awk "/^${NAME} /")
  [ -z "$HEAD" ] && return 1

  local STATUS="$(echo "$HEAD" | awk 'match($0, /.* ((dis)?connected) .*/, a) {print a[1]}')"
  local RESOLUTION="$(echo "$HEAD" | awk 'match($0, /.* ([0-9]+x[0-9]+)\+.*/, a) {print a[1]}')"

  [ "$STATUS" = "connected" ] && [[ "$RESOLUTION" =~ ^[0-9]+x[0-9]+$ ]] &&
    return 0 || return 1
}

is_primary () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    return 1
  fi

  local SCREEN=$(screen || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local HEAD=$(echo "$SCREEN" | awk "/^${NAME} /")
  [ -z "$HEAD" ] && return 1

  local PRIMARY="$(echo "$HEAD" | awk 'match($0, /.* (primary) .*/, a) {print a[1]}')"

  [ -n "$PRIMARY" ] && return 0 || return 1
}

names () {
  local STATUS=$1

  if [[ ! "$STATUS" =~ ^( *|connected|disconnected|active|inactive|primary)$ ]]; then
    return 1
  fi

  local SCREEN=$(screen || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local PATTERN='^[A-Z]+-[0-9]+'
  if [[ "$STATUS" =~ (dis)?connected ]]; then
    PATTERN+="\s${STATUS}"
  elif [ "$STATUS" = "active" ]; then
    PATTERN+='\sconnected.*\s([0-9]+x[0-9]+)\+.*'
  elif [ "$STATUS" = "inactive" ]; then
    PATTERN+='\sconnected\s\(.*'
  elif [ "$STATUS" = "primary" ]; then
    PATTERN+='\s.*\sprimary\s.*'
  fi

  local NAMES=$(echo "$SCREEN" | awk '{ORS="'$AES'";} /'${PATTERN}'/{print $1}')

  if [[ "$NAMES" =~ .*${AES}$ ]]; then
    echo "${NAMES::-${#AES}}"
  else
    echo "$NAMES"
  fi
}

output () {
  local NAME=$1

  if [ -z "$NAME" ]; then
   return 1
  elif [ "$NAME" = "primary" ]; then
    local NAMES=$(names primary || echo "err:$?")
    [[ "$NAMES" =~ ^err: ]] && return 1
    
    NAME=$(element "$NAMES" 0 | value)
  elif ! exists "$NAME"; then
    return 1
  fi

  local SCREEN=$(screen || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local RATE="$(echo "$SCREEN" | sed -n "/$NAME .*/{:a;N;/\*/!ba;/\*/p}" |
    awk 'match($0, /.* ([0-9]{2}.[0-9]{2})\*.*/, a) {print a[1]}')"

  local RESOLUTION="$(echo "$SCREEN" | sed -n "/$NAME .*/{:a;N;/\*/!ba;/\*/p}" |
      awk 'match($0, /.* ([0-9]+x[0-9]+) .*\*.*/, a) {print a[1]}')"

  local PROFILES="$(echo "$SCREEN" | awk /^$NAME/,!// | tail -n +2 |
    awk -v AES="$AES" -v KVS="$KVS" '{
      if ($0 ~ /^\s+[0-9]+x[0-9]+/) {
        rates=""
        for (i=2; i<=NF; i++) rates=rates $i AES
        print "profile" KVS $1 AES rates
      } else exit
    }' | tr -d '+*')"

  local HEAD=$(echo "$SCREEN" | awk "/^${NAME} /")

  local NAME="$(echo "$HEAD" | awk 'match($0, /(.*) ((dis)?connected) .*/, a) {print a[1]}')"
  local STATUS="$(echo "$HEAD" | awk 'match($0, /.* ((dis)?connected) .*/, a) {print a[1]}')"
  local AREA="$(echo "$HEAD" | awk 'match($0, /.* ([0-9]+x[0-9]+)\+.*/, a) {print a[1]}')"
  local POSITION="$(echo "$HEAD" | awk 'match($0, /.* [0-9]+x[0-9]+\+([0-9]+\+[0-9]+) .*/, a) {print a[1]}' | tr '+' ",")"
  local DIMS="$(echo "$HEAD" | awk 'match($0, /.* ([0-9]+mm x [0-9]+mm).*/, a) {print a[1]}' | tr -d ' m')"

  local PRIMARY="$(echo "$HEAD" | awk 'match($0, /.* (primary) .*/, a) {print a[1]}')"
  [ -n "$PRIMARY" ] && PRIMARY="true" || PRIMARY="false"

  local ACTIVE="false"
  [ "$STATUS" = "connected" ] && [[ "$AREA" =~ ^[0-9]+x[0-9]+$ ]] && ACTIVE="true"

  local ROTATE="$(echo "$HEAD" | awk 'match($0, /.* (normal|right|left|inverted) .*\(.*/, a) {print a[1]}')"
  [ -z "$ROTATE" ] && [ "$ACTIVE" = "true" ] && ROTATE="normal"

  local REFLECT="$(echo "$HEAD" | awk 'match($0, /.* (X) .*\(.*/, a) {print tolower(a[1])}')"
  REFLECT+="$(echo "$HEAD" | awk 'match($0, /.* (Y) .*\(.*/, a) {print tolower(a[1])}')"
  [ -z "$REFLECT" ] && [ "$ACTIVE" = "true" ] && REFLECT="normal"

  echo "name${KVS}$NAME"
  echo "status${KVS}$STATUS"
  echo "active${KVS}$ACTIVE"

  if [ "$ACTIVE" = "true" ]; then
    echo "primary${KVS}$PRIMARY"
    echo "resolution${KVS}$RESOLUTION"
    echo "rate${KVS}${RATE}Hz"
    echo "rotate${KVS}$ROTATE"
    echo "reflect${KVS}$REFLECT"
    echo "area${KVS}$AREA"
    echo "position${KVS}$POSITION"
    echo "dims${KVS}$DIMS"
    echo "$PROFILES"
  fi
}

resolutions () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    return 1
  elif ! exists "$NAME"; then
    return 1
  fi

  local SCREEN=$(screen || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local RESOLUTIONS="$(echo "$SCREEN" | awk /^$NAME/,!// | tail -n +2 |
    awk '{ORS="'$AES'";} {if ($0 ~ /^\s+[0-9]+x[0-9]+/) {print $1} else {exit}}')"

  if [[ "$RESOLUTIONS" =~ .*${AES}$ ]]; then
    echo "${RESOLUTIONS::-${#AES}}"
  else
    echo "$RESOLUTIONS"
  fi
}

rates () {
  local NAME=$1
  local RESOLUTION=$2

  if [ -z "$NAME" ]; then
    return 1
  elif ! exists "$NAME"; then
    return 1
  fi

  if [ -z "$RESOLUTION" ]; then
    return 1
  fi

  local SCREEN=$(screen || echo "err:$?")
  [[ "$SCREEN" =~ ^err: ]] && return 1

  local RATES="$(echo "$SCREEN" | awk /^$NAME/,!// | tail -n +2 |
    awk '{if ($0 ~ /\s'$RESOLUTION'\s/) {print $0; exit}}' |
    sed 's/'$RESOLUTION'//' | trim | tr -d '+*' | sed 's/ \{1,\}/\n/g' |
    awk '{ORS="'$AES'";} {print}')"

  if [[ "$RATES" =~ .*${AES}$ ]]; then
    echo "${RATES::-${#AES}}"
  else
    echo "$RATES"
  fi
}

pick_output () {
  local STATUS=$1

  local NAMES=$(names "$STATUS" || echo "err:$?")
  
  if [[ "$NAMES" =~ ^err: ]]; then
    echo "Unable to find ${STATUS:-\b} outputs"
    return 1
  fi

  local LEN=$(count "$NAMES")

  if [ ! $LEN -gt 0 ]; then
    echo "No ${STATUS:-\b} outputs have been found"
    return 1
  fi

  local MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"
  
  pick_one "Select an output:" "$NAMES" "$MODE"
}

pick_resolution () {
  local NAME=$1

  local RESOLUTIONS=$(resolutions "$NAME" || echo "err:$?")
  
  if [[ "$RESOLUTIONS" =~ ^err: ]]; then
    echo "Unable to find resolutions for $NAME output"
    return 1
  fi

  local LEN=$(count "$RESOLUTIONS")

  if [ ! $LEN -gt 0 ]; then
    echo "No resolutions have been found for $NAME output"
    return 1
  fi

  local MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"
  
  pick_one "Select a resolution:" "$RESOLUTIONS" "$MODE"
}

pick_rate () {
  local NAME=$1
  local RESOLUTION=$2

  local RATES=$(rates "$NAME" "$RESOLUTION" || echo "err:$?")
  
  if [[ "$RATES" =~ ^err: ]]; then
    echo "Unable to find rates for $NAME output"
    return 1
  fi

  local LEN=$(count "$RATES")

  if [ ! $LEN -gt 0 ]; then
    echo "No rates have been found for $NAME output"
    return 1
  fi

  local MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"
  
  pick_one "Select a rate:" "$RATES" "$MODE"
}

prompt () {
  local PRIMARY=$(output primary || echo "err:$?")
  
  if [[ "$PRIMARY" =~ ^err: ]]; then
    read -rep "[screens:${RE}none$RS] " REPLY
    return 1
  fi

  local NAME=$(property "$PRIMARY" name | value)
  local RESOLUTION=$(property "$PRIMARY" resolution | value)
  local RATE=$(property "$PRIMARY" rate | value)

  local STATUS="$YE${NAME}$RS"

  if [ -n "$RESOLUTION" ]; then
    STATUS+=" $YE${RESOLUTION}$RS"
    [ -n "$RATE" ] && STATUS+="$GR@${RATE}$RS"
  fi

  read -rep "[screens:$STATUS] " REPLY
}

show_status () {
  if [ -z "$DISPLAY" ]; then
    echo "Unable to resolve the xorg server"
    return 1
  fi

  local PATTERN='/^('
  PATTERN+='name\sof\sdisplay|'
  PATTERN+='version\snumber|'
  PATTERN+='vendor\sstring|'
  PATTERN+='vendor\srelease\snumber|'
  PATTERN+='X.Org\sversion|'
  PATTERN+='motion\sbuffer\ssize|'
  PATTERN+='image\sbyte\sorder|'
  PATTERN+='default\sscreen\snumber|'
  PATTERN+='number\sof\sscreens'
  PATTERN+=')/'

  xdpyinfo -display "$DISPLAY" |
    awk -F': ' $PATTERN'{ \
      gsub(/[ \t]+$/, "", $1); \
      gsub(/^[ \t]+/, "", $2); \
      printf "%-23s %s\n",$1":",$2 \
    }' | sed -r 's/\<./\U&/g'

  local NAMES=$(names connected || echo "err:$?")

  if [[ "$NAMES" =~ ^err ]]; then
    echo "Unable to find connected outputs"
    return 1
  fi

  local LEN=$(count "$NAMES")

  if [ $LEN = 0 ]; then
    echo "Connected Outputs:      none"
    return
  fi

  local CONNECTED="Connected Outputs:      "

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    local NAME=$(element "$NAMES" "$INDEX" | value)
    local OUTPUT=$(output "$NAME")

    local NAME="$(property "$OUTPUT" name | value)"

    local RESOLUTION="$(property "$OUTPUT" resolution | value)"
    [ -z "$RESOLUTION" ] && RESOLUTION="inactive"

    local RATE="$(property "$OUTPUT" rate | value)"

    local PRIMARY="$(property "$OUTPUT" primary | value)"
    [ "$PRIMARY" = "true" ] && PRIMARY="*" || PRIMARY=""

    if [ $INDEX = 0 ]; then
      CONNECTED+="$NAME [${RESOLUTION}@$RATE]$PRIMARY"
    else
      CONNECTED+="\n                        $NAME [${RESOLUTION}@$RATE]$PRIMARY"
    fi
  done

  echo -e "$CONNECTED"
}

show_output () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi

  local OUTPUT=$(output "$NAME" || echo "err:$?")

  if [[ "$OUTPUT" =~ ^err: ]]; then
    echo "Unable to find $NAME output"
    return 1
  fi

  local NAME="$(property "$OUTPUT" name | value)"
  local STATUS="$(property "$OUTPUT" status | value)"
  local ACTIVE="$(property "$OUTPUT" active | value)"
  local PRIMARY="$(property "$OUTPUT" primary | value)"
  local RESOLUTION="$(property "$OUTPUT" resolution | value)"
  local RATE="$(property "$OUTPUT" rate | value)"
  local ROTATE="$(property "$OUTPUT" rotate | value)"
  local REFLECT="$(property "$OUTPUT" reflect | value)"
  local POSITION="$(property "$OUTPUT" position | value)"
  local AREA="$(property "$OUTPUT" area | value)"
  local DIMS="$(property "$OUTPUT" dims | value)"
  local PROFILES="$(property "$OUTPUT" profile | value)"

  printf "%s\n" \
    "Name:       $NAME" \
    "Status:     $STATUS" \
    "Active:     $ACTIVE" \
  
  if [ "$ACTIVE" = "true" ]; then
    printf "%s\n" \
      "Primary:    $PRIMARY" \
      "Resolution: $RESOLUTION" \
      "Rate:       $RATE" \
      "Rotate:     $ROTATE" \
      "Reflect:    $REFLECT" \
      "Position:   $POSITION" \
      "Area:       $AREA" \
      "Dimensions: $DIMS"
  
    echo -n "Profiles:   "
    echo "$PROFILES" | head -n 1 |
      awk -F"$AES" '{
        printf("%-9s ", $1);
        for(i=2; i<=NF; i++) {if (i==NF) {print($i)} else {printf("%-5s ", $i)}}
      }'
    echo "$PROFILES" | tail -n +2 |
      awk -F"$AES" '{
        printf("            %-9s ", $1);
        for(i=2; i<=NF; i++) {if (i==NF) {print($i)} else {printf("%-5s ",$i)}}
      }'
  fi
}

list_outputs () {
  local STATUS=$1

  local NAMES=$(names "$STATUS" || echo "err:$?")

  if [[ "$NAMES" =~ ^err: ]]; then
    echo -e "Unable to retrieve ${STATUS:-\b} outputs"
    return 1
  fi

  local LEN=$(count "$NAMES")

  if [ ! $LEN -gt 0 ]; then
    echo "No ${STATUS:-\b} outputs have been found"
    return
  fi

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    local NAME=$(element "$NAMES" "$INDEX" | value)

    [ $INDEX -gt 0 ] && echo
    show_output "$NAME" | head -n 11
  done
}

set_layout () {
  local NAMES=$(names active || echo "err:$?")

  if [[ "$NAMES" =~ ^err: ]]; then
    echo "Unable to retrieve active outputs"
    return 1
  fi

  local LEN=$(count "$NAMES")

  if [ $LEN = 0 ]; then
    echo "No active outputs have been found"
    return
  elif [ $LEN = 1 ]; then
    echo "No layout can be set for one active output"
    return
  elif [ $LEN -gt 3 ]; then
    echo "No layouts found for more than three outputs"
    return
  fi

  local LAYOUTS=""

  if [ $LEN = 2 ]; then
    LAYOUTS+="Side by Side${KVS}row-2${AES}"
    LAYOUTS+="Top Bottom${KVS}col-2"

    echo "Side by Side | Top Bottom"
    echo "[A][B]         [A]"
    echo "               [B]"
  elif [ $LEN = 3 ]; then
    LAYOUTS+="Side by Side${KVS}row-3${AES}"
    LAYOUTS+="Top Bottom${KVS}col-3${AES}"
    LAYOUTS+="Left Gamma${KVS}gamma-3${AES}"
    LAYOUTS+="Right Gamma${KVS}gamma-rev-3${AES}"
    LAYOUTS+="Left Lambda${KVS}lambda-3${AES}"
    LAYOUTS+="Right Lambda${KVS}lambda-rev-3"

    echo "Side by Side | Top Bottom | Left Gamma | Right Gamma | Left Lambda | Right Lambda"
    echo "[A][B][C]      [A]          [A][B]       [A][B]        [A]              [A]"
    echo "               [B]          [C]             [C]        [B][C]        [B][C]"
    echo "               [C]"
  fi

  local MODE="vertical-6"
  [ $(count "$LAYOUTS") -lt 3 ] && MODE="horizontal"

  pick_one "Select a layout mode:" "$LAYOUTS" "$MODE"
  [ -z "$REPLY" ] && return

  local LAYOUT=$(value "$REPLY")

  MODE="vertical-6"
  [ $LEN -lt 3 ] && MODE="horizontal"

  local SPOTS=$(echo "$LEN" | awk '{for(i=65; i<65+$0; i++) printf "%c,",i}')
  pick_by_order "Pick outputs by order to match ${SPOTS::-1}:" "$NAMES" "$LEN" "$MODE"
  [ -z "$REPLY" ] && return

  local A=$(element "$REPLY" 0 | value)
  local B=$(element "$REPLY" 1 | value)
  if [ $LEN = 3 ]; then
    local C=$(element "$REPLY" 2 | value)
  fi

  case "$LAYOUT" in
    "row-2")
      xrandr --output "$A" --left-of "$B" &&
        echo "Outputs laid out in side by side mode" ||
        echo "Unable to lay out outputs in side by side mode";;
    "col-2")
      xrandr --output "$A" --above "$B" &&
        echo "Outputs laid out in top bottom mode" ||
        echo "Unable to lay out outputs in top bottom mode";;
    "row-3")
      xrandr --output "$A" --left-of "$B" --output "$B" --left-of "$C" &&
        echo "Outputs laid out in side by side mode" ||
        echo "Unable to lay out outputs in side by side mode";;
    "col-3")
      xrandr --output "$A" --above "$B" --output "$B" --above "$C" &&
        echo "Outputs laid out in top bottom mode" ||
        echo "Unable to lay out outputs in top bottom mode";;
    "gamma-3")
      xrandr --output "$A" --left-of "$B" --output "$C" --below "$A" &&
        echo "Outputs laid out in left gamma mode" ||
        echo "Unable to lay out outputs in left gamma mode";;
    "gamma-rev-3")
      xrandr --output "$A" --left-of "$B" --output "$C" --below "$B" &&
        echo "Outputs laid out in right gamma mode" ||
        echo "Unable to lay out outputs in right gamma mode";;
    "lambda-3")
      xrandr --output "$A" --above "$B" --output "$B" --left-of "$C" &&
        echo "Outputs laid out in left lambda mode" ||
        echo "Unable to lay out outputs in left lambda mode";;
    "lambda-rev-3")
      xrandr --output "$A" --left-of "$C" --output "$A" --above "$C" &&
        echo "Outputs laid out in right lambda mode" ||
        echo "Unable to lay out outputs in right lambda mode";;
    *) echo "Unable to set the layout: '$LAYOUT'"; return 1;;
  esac
}

set_mode () {
  local NAME=$1
  local RESOLUTION=$2
  local RATE=$3

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  if ! exists "$NAME"; then
    echo "Unable to find $NAME output"
    return 1
  elif ! is_connected "$NAME"; then
    echo "Cannot set mode of a disconnected output"
    return 1
  elif ! is_active "$NAME"; then
    echo "Cannot set mode of an inactive"
    return 1
  fi

  if [ -z "$RESOLUTION" ]; then
    pick_resolution "$NAME" || return 1
    [ -z "$REPLY" ] && return
    
    RESOLUTION=$(value "$REPLY")
  fi

  if [ -z "$RATE" ]; then
    pick_rate "$NAME" "$RESOLUTION" || return 1
    [ -z "$REPLY" ] && return
    
    RATE=$(value "$REPLY")
  fi

  xrandr --output "$NAME" --mode "$RESOLUTION" --rate "$RATE" &&
    echo "Output $NAME mode set to $RESOLUTION@${RATE}Hz" ||
    echo "Unable to set mode for output $NAME"
}

restore () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  if ! exists "$NAME"; then
    echo "Unable to find $NAME output"
    return 1
  elif ! is_connected "$NAME"; then
    echo "Cannot restore a disconnected output"
    return 1
  elif ! is_active "$NAME"; then
    echo "Cannot restore an inactive output"
    return 1
  fi

  xrandr --output "$NAME" --auto &&
    echo "Output $NAME has been set to auto mode" ||
    echo "Unable to restore the output $NAME"
}

set_primary () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  if ! exists "$NAME"; then
    echo "Unable to find $NAME output"
    return 1
  elif ! is_connected "$NAME"; then
    echo "Cannot set primary a disconnected output"
    return 1
  elif ! is_active "$NAME"; then
    echo "Cannot set primary an inactive output"
    return 1
  elif is_primary "$NAME"; then
    echo "Output $NAME is already the primary"
    return 1
  fi

  xrandr --output "$NAME" --primary &&
    echo "Output $NAME has been set as primary" ||
    echo "Unable to set the primary output $NAME"
}

set_on () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output inactive || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  if ! exists "$NAME"; then
    echo "Unable to find $NAME output"
    return 1
  elif ! is_connected "$NAME"; then
    echo "Cannot activate a disconnected output"
    return 1
  elif is_active "$NAME"; then
    echo "Output $NAME is already active"
    return 1
  fi

  xrandr --output "$NAME" --auto &&
    echo "Output $NAME has been activated" ||
    echo "Unable to activate the output $NAME"
}

set_off () {
  local NAME=$1

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  if ! exists "$NAME"; then
    echo "Unable to find $NAME output"
    return 1
  elif ! is_connected "$NAME"; then
    echo "Cannot deactivate a disconnected output"
    return 1
  elif ! is_active "$NAME"; then
    echo "Output $NAME is already inactive"
    return 1
  elif is_primary "$NAME"; then
    echo "Cannot deactivate the primary output"
    return 1
  fi

  xrandr --output "$NAME" --off &&
    echo "Output $NAME has been deactivated" ||
    echo "Unable to deactivate the output $NAME"
}

reflect () {
  local NAME=$1
  local MODE=$2

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  if ! exists "$NAME"; then
    echo "Unable to find $NAME output"
    return 1
  elif ! is_connected "$NAME"; then
    echo "Cannot reflect a disconnected output"
    return 1
  elif ! is_active "$NAME"; then
    echo "Cannot reflect an inactive output"
    return 1
  fi

  if [ -z "$MODE" ]; then
    local MODES=""
    MODES+="Normal${KVS}normal${AES}"
    MODES+="X Axis${KVS}x${AES}"
    MODES+="Y Axis${KVS}y${AES}"
    MODES+="XY Axes${KVS}xy"

    pick_one "Select a reflection mode:" "$MODES" "vertical-4"
    [ -z "$REPLY" ] && return
    
    MODE=$(value "$REPLY")
  fi
  
  if [[ ! "$MODE" =~ ^(normal|x|y|xy)$ ]]; then
    echo "Invalid reflection mode argument: '$MODE'"
    return 1
  fi

  xrandr --output "$NAME" --reflect "$MODE" &&
    echo "Output $NAME has been reflected to $MODE mode" ||
    echo "Unable to reflect the output $NAME"
}

rotate () {
  local NAME=$1
  local MODE=$2

  if [ -z "$NAME" ]; then
    pick_output active || return 1
    [ -z "$REPLY" ] && return
    
    NAME=$(value "$REPLY")
  fi
  
  if ! exists "$NAME"; then
    echo "Unable to find $NAME output"
    return 1
  elif ! is_connected "$NAME"; then
    echo "Cannot reflect a disconnected output"
    return 1
  elif ! is_active "$NAME"; then
    echo "Cannot reflect an inactive output"
    return 1
  fi

  if [ -z "$MODE" ]; then
    local MODES=""
    MODES+="Normal${KVS}normal${AES}"
    MODES+="Right 90°${KVS}right${AES}"
    MODES+="Left 90°${KVS}left${AES}"
    MODES+="Inverted 180°${KVS}inverted"

    pick_one "Select a rotation mode:" "$MODES" "vertical-6"
    [ -z "$REPLY" ] && return
    
    MODE=$(value "$REPLY")
  fi
  
  if [[ ! "$MODE" =~ ^(normal|right|left|inverted)$ ]]; then
    echo "Invalid rotation mode argument: '$MODE'"
    return 1
  fi

  xrandr --output "$NAME" --rotate "$MODE" &&
    echo "Output $NAME has been rotated to $MODE mode" ||
    echo "Unable to rotate the output $NAME"
}

save_layout () {
  local NAMES=$(names || echo "err:$?")
  
  if [[ "$NAMES" =~ ^err: ]]; then
   echo "Unable to retrieve outputs"
   return 1
  fi

  local LEN=$(count "$NAMES")
  
  if [ $LEN = 0 ]; then
    echo "No outputs have found"
    return 1
  fi

  local LAYOUT=""

  local INDEX=0
  for ((INDEX = 0; INDEX < $LEN; INDEX++)); do
    [ $INDEX -gt 0 ] && LAYOUT+=$'\n'

    local NAME=$(element "$NAMES" "$INDEX" | value)
    local OUTPUT=$(output "$NAME")

    local ACTIVE=$(property "$OUTPUT" active | value)
  
    if [ "$ACTIVE" = "false" ]; then
      LAYOUT+="$NAME off"
      continue
    fi

    local PRIMARY=$(property "$OUTPUT" primary | value)

    if [ "$PRIMARY" = "true" ]; then
      LAYOUT+="$NAME primary"
    else
      LAYOUT+="$NAME secondary"
    fi

    local RESOLUTION=$(property "$OUTPUT" resolution | value)
    local RATE=$(property "$OUTPUT" rate | value)
    local POSITION=$(property "$OUTPUT" position | value | tr ',' 'x')
    local ROTATE=$(property "$OUTPUT" rotate | value)
    local REFLECT=$(property "$OUTPUT" reflect | value)

    LAYOUT+=" $RESOLUTION $RATE $POSITION $ROTATE $REFLECT"
  done

  echo -e "$LAYOUT" > ~/.config/stack/layout
}

load_layout () {
  if [ ! -f ~/.config/stack/layout ]; then
    echo "No layout config file found, fallback to auto"
    return
  fi

  local ARGS=$(awk '{
    if ($2 == "off") {
      print "--output "$1" --off"
    } else {
      args="--output "$1" --mode "$3" --rate "$4" --pos "$5" --rotate "$6" --reflect "$7
      if ($2 == "primary") args=args" --primary"
      print args
    }
  }' ~/.config/stack/layout | tr $'\n' ' ')

  xrandr $ARGS &&
    echo "Layout configuration has been loaded" ||
    echo "Unable to load layout configuration"
}

help () {
  local FRM=" %-45s\t%s\n"

  if [ "$1" = "once" ]; then
    echo "Usage: screens COMMAND"

    echo -e "\nCOMMANDS"
    printf "$FRM" \
      "help" "Show this message" \
      "load layout" "Load screens output layout"

    return
  fi

  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf "$FRM" \
    "help" "Show this help message." \
    "show status" "Show a report of the xorg server and screens." \
    "show output [<name>]" "Show the data of the given output." \
    "" "" \
    "list outputs [<status>]" "List all outputs or by the given status," \
    "" "connected, disconnected, active or primary." \
    "" "" \
    "set layout" "Set the layout of active outputs." \
    "set mode [<name> [<res> [<rate>]]]" "Set the mode of the given output." \
    "set primary [<name>]" "Set the primary output." \
    "set on|off [<name>]" "Set active or inactive the given output." \
    "save layout" "Persist the current screen layout to be applied in next boot." \
    "" "" \
    "rotate [<name> normal|right|left|inverted]" "Set output rotation to normal, right, left or inverted." \
    "reflect [<name> normal|x|y|xy]" "Set output reflection to normal, x, y or xy axes." \
    "restore [<name>]" "Restore the given output to auto mode."

  echo -e "\nOBJECTS"
  printf "$FRM" \
    "status" "The status of xorg server and screen layouts." \
    "output" "An output display device." \
    "layout" "The layout of multiple outputs setup." \
    "mode" "The resolution and rate of an output." \
    "primary" "The main output in a multihead layout."
}

loop () {
  clear

  while true; do
    prompt && history -s "$REPLY"

    set -f
    set_separator "line"
    local CMD=($(xargs -n1 <<< "$REPLY"))
    restore_separator && set +f

    if [ "${CMD[0]}" = "help" ]; then
      help
      continue
    elif [ "${CMD[0]}" = "clear" ]; then
      clear
      continue
    elif [ "${CMD[0]}" = "quit" ]; then
      break
    elif [ -z "${CMD[0]}" ]; then
      continue
    fi

    case "${CMD[0]}" in
      "show")
        case "${CMD[1]}" in
          "status") show_status;;
          "output") show_output "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "list")
        case "${CMD[1]}" in
          "outputs") list_outputs "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "set")
        case "${CMD[1]}" in
          "layout") set_layout;;
          "mode") set_mode "${CMD[2]}" "${CMD[3]}" "${CMD[4]}";;
          "primary") set_primary "${CMD[2]}";;
          "on") set_on "${CMD[2]}";;
          "off") set_off "${CMD[2]}";;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "save")
        case "${CMD[1]}" in
          "layout") save_layout;;
          *) echo "Unknown or invalid command: '$REPLY'";;
        esac;;
      "rotate") rotate "${CMD[1]}" "${CMD[2]}";;
      "reflect") reflect "${CMD[1]}" "${CMD[2]}";;
      "restore") restore "${CMD[1]}";;
      *) echo "Unknown or invalid command: '$REPLY'";;
    esac
  done

  clear
}

once () {
  case "$1" in
    "help") help "once";;
    "load")
      case "$2" in
        "layout") load_layout;;
        *) abort "Unknown or invalid command: '$1'";; 
      esac;;
    *) abort "Unknown or invalid command: '$1'";; 
  esac
}

if [ $# = 0 ]; then
  loop
else
  once "$@"
fi
