#!/bin/bash

set -o pipefail
source /opt/stack/utils

# Returns the remote services having the given status.
# If status is not given all remotes will be returned.
# Arguments:
#  status: mounted or unmounted
# Outputs:
#  A json array of remote objects.
find_remotes () {
  local status="${1}"

  local mounts="$(< /proc/mounts)"

  local remote=''
  local remotes=''

  remotes="$(rclone listremotes --long |
    while read -r remote; do
      if [[ -z "${remote}" ]]; then
        continue
      fi

      local name="$(echo "${remote}" | cut -d ':' -f 1)"
      local service="$(echo "${remote}" | cut -d ':' -f 2 | trim)"

      # Check if there remote name exists in the mounts
      local mount="$(grep "^${name}:.* fuse.rclone" <<< "${mounts}")"

      local is_mounted='false'
      local mount_point=''
      if [[ -n "${mount}" ]]; then
        is_mounted='true'
        mount_point="$(echo "${mount}" | awk '{print $2}')"
      fi

      remote=''
      remote+="\"name\": \"${name}\","
      remote+="\"service\": \"${service}\","
      remote+="\"is_mounted\": ${is_mounted}"

      if [[ "${is_mounted}" == "true" ]]; then
        remote+=",\"mount_point\": \"${mount_point}\""
      fi

      remote="{${remote}}"

      case "${status}" in
        "mounted")
          if [[ "${is_mounted}" == "true" ]]; then
            echo -n "${remote},"
          fi;;
        "unmounted")
          if [[ "${is_mounted}" == "false" ]]; then
            echo -n "${remote},"
          fi;;
        *) echo -n "${remote},";;
      esac
    done;)" || return 1
  
  # Remove extra comma after the last array element
  if [[ -n "${remotes}" ]]; then
    remotes="${remotes::-1}"
  fi

  echo "[${remotes}]"
}

# Returns the remote with the given name.
# Arguments:
#  name: the name of a remote
# Outputs:
#  A json object of remote.
find_remote () {
  local name="${1}"

  local query=".[]|select(.name == \"${name}\")"

  find_remotes | jq -cer "${query}" || return 1
}

# Checks if the service with the given name exists.
# Arguments:
#  name: the name of a service
# Returns:
#  0 if exists otherwise 1
exists () {
  local name="${1}"

  local query=".[]|select(.name == \"${name}\")"

  find_remotes | jq -cer "${query}" &>/dev/null || return 1
}

# Checks if the remote with the given name is mounted
# by greping the name in the /proc/mounts file.
# Arguments:
#  name: the name of a service
# Returns:
#  0 if is mounted otherwise 1
is_mounted () {
  local name="${1}"

  grep -Eq "^${name}:.* fuse.rclone" /proc/mounts
}

# Shows a menu asking the user to select one remote, where the
# answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  status: mounted or unmounted
# Outputs:
#  A menu of remote names.
pick_remote () {
  local status="${1}"

  local query=''
  query='{"key": .name, "value": "\(.name) [\(.service)]"}'
  query="[.[]|${query}]"

  local remotes=''
  remotes="$(find_remotes "${status}" | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${remotes}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo -e "No ${status:-\b} remotes have found"
    return 2
  fi

  pick_one "Select a remote:" "${remotes}" "vertical" || return $?
}

# Shows a prompt status and asks user to enter the
# next command, which is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A minimal prompt status line.
prompt () {
  local remotes=''
  remotes="$(find_remotes "mounted")"

  if [[ $? -eq 0 ]]; then
    local len=0
    len="$(count "${remotes}")"

    local status="offline"
    if [[ ${len} -gt 0 ]]; then
      status="synced"
    fi
  else
    status='none'
  fi

  read -rep "[cloud:${status}] " REPLY
}

# Shows the list of remotes matching the given service.
# Arguments:
#  service: a service name (drive, dropbox e.g.)
# Outputs:
#  A list of remotes.
list_remotes () {
  local service="${1}"

  local query=''
  query="[.[]|select(.service|test(\"${service}\"; \"i\"))]"

  local remotes=''
  remotes="$(find_remotes | jq -cer "${query}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read remotes"
    return 2
  fi

  local len=0
  len="$(count "${remotes}")" || return 1
    
  if [[ ${len} -eq 0 ]]; then
    echo -e "No ${service:-\b} remotes have been found"
    return 0
  fi

  local query=''
  query+='Name:     \(.name)\n'
  query+='Service:  \(.service)\n'
  query+='Mounted:  \(.is_mounted)'
  query+='\(if .is_mounted then "\nMount:    \(.mount_point)" else "" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${remotes}" | jq -cer "${query}" || return 1
}

# Creates a new google drive remote with the given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of the remote
sync_drive () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    echo "Missing the remote name"
    return 2
  elif exists "${name}"; then
    echo "Remote ${name} already exists"
    return 2
  fi

  ask "Enter the client ID:" ".+" || return $?
  local client_id="${REPLY}"

  ask "Enter the client secret:" ".+" || return $?
  local client_secret="${REPLY}"

  ask "Enter the root folder ID (blank to skip):" || return $?
  local root_folder="${REPLY}"

  echo "Go to browser and accept access permssions..."

  rclone config create "${name}" drive scope=drive client_id="${client_id}" \
    client_secret="${client_secret}" root_folder_id="${root_folder}" &>/dev/null

  if [[ $? -ne 0 ]]; then
    echo "Failed to sync drive remote"
    rclone config delete "${name}"
    return 2
  fi

  echo "Drive remote ${name} has been synced"
}

# Creates a new dropbox remote with the given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of the remote
sync_dropbox () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    echo "Missing the remote name"
    return 2
  elif exists "${name}"; then
    echo "Remote ${name} already exists"
    return 2
  fi

  ask "Enter the app key:" ".+" || return $?
  local app_key="${REPLY}"

  ask "Enter the app secret:" ".+" || return $?
  local app_secret="${REPLY}"

  echo "Go to browser and accept access permssions..."

  rclone config create "${name}" dropbox \
    client_id="${app_key}" client_secret="${app_secret}" &>/dev/null

  if [[ $? -ne 0 ]]; then
    echo "Failed to sync dropbox remote"
    rclone config delete "${name}"
    return 2
  fi

  echo "Dropbox remote ${name} has been synced"
}

# Deletes the remote with the given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of a remote
delete_remote () {
  local name="${1}"
  
  if [[ -z "${name}" ]]; then
    pick_remote || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi
  
  if ! exists "${name}"; then
    echo "No remote ${name} has been found"
    return 2
  fi

  if is_mounted "${name}"; then
    unmount_remote "${name}"
  fi

  rclone config delete "${name}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to delete remote"
    return 2
  fi
  
  echo "Remote ${name} has been deleted"
}

# Mounts the remote with the given name to the disk.
# Globals:
#  REPLY, HOME
# Arguments:
#  name: the name of the remote
mount_remote () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_remote "unmounted" || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi
  
  if ! exists "${name}"; then
    echo "No remote ${name} has been found"
    return 2
  elif is_mounted "${name}"; then
    echo "Remote ${name} is already mounted"
    return 2
  fi

  echo "Mounting remote ${name}..."

  local mount_folder="${HOME}/mount/cloud/${name}"

  mkdir -p "${mount_folder}" &&
  rclone mount "${name}:" "${mount_folder}" \
    --umask=002 --gid=$(id -g) --uid=$(id -u) --timeout=1h \
    --poll-interval=15s --dir-cache-time=1000h --vfs-cache-mode=full \
    --vfs-cache-max-size=150G --vfs-cache-max-age=12h --daemon
  
  if [[ $? -ne 0 ]]; then
    echo "Failed to mount remote"
    find "${mount_folder}" -maxdepth 0 -empty -exec rm -rf {} \;
    return 2
  fi

  echo "Remote ${name} mounted to ${mount_folder}"
}

# Unmounts the remote with the given name from the disk.
# Globals:
#  REPLY
# Arguments:
#  name: the name of the remote
unmount_remote () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_remote "mounted" || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi
  
  if ! exists "${name}"; then
    echo "No remote ${name} has been found"
    return 2
  elif ! is_mounted "${name}"; then
    echo "Remote ${name} is not mounted"
    return 2
  fi

  echo "Unmounting remote ${name}..."

  local remote=''
  remote="$(find_remote "${name}")" || return 1

  local mount_point=''
  mount_point="$(get "${remote}" ".mount_point")" || return 1

  fusermount -uz "${mount_point}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to unmount remote"
    return 2
  fi

  find "${mount_point}" -maxdepth 0 -empty -exec rm -rf {} \;

  echo "Remote ${name} has been unmounted"
}

# Mounts all the synced remotes.
# Arguments:
#  None
mount_all () {
  local remotes=''
  remotes="$(find_remotes)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read remotes"
    return 2
  fi

  local len=0
  len="$(count "${remotes}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No remotes have been found"
    return 2
  fi

  # Iterate over remote names and mount remotes one by one
  remotes="$(echo "${remotes}" | jq -cr '.[]|.name')" || return 1

  local failed='false'
  local remote=''

  while read -r remote; do
    mount_remote "${remote}"

    if [[ $? -ne 0 ]]; then
      echo "Failed to mount remote ${remote}"
      failed='true'
    else
      echo "Remote ${remote} has been mounted"
    fi
  done <<< "${remotes}"

  if [[ "${failed}" == "true" ]]; then
    echo "Failed to mount all remotes"
    return 2
  fi

  echo "All remotes have been mounted"
}

# Shows the help message.
# Arguments:
#  mode: once or none
# Outputs:
#  A long help message.
show_help () {
  if [[ "${1}" == "once" ]]; then
    echo "Usage: cloud COMMAND [OBJECT] [ARGUMENTS]..."

    echo -e "\nCOMMANDS"
    printf " %-15s %s\n" \
      "help" "Show this help message." \
      "" "" \
      "mount remotes" "Mount all synced cloud remotes."

    return 0
  fi

  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."
  
  echo -e "\nCOMMANDS"
  printf " %-30s %s\n" \
    "help" "Show this help message." \
    "" "" \
    "list remotes [service]" "List all synced remotes by service." \
    "sync remote <service> <name>" "Sync a remote service, where service" \
    "" "could be drive or dropbox." \
    "delete remote [<name>]" "Delete a synced remote service." \
    "" "" \
    "mount remote [<name>]" "Mount an already synced remote." \
    "unmount remote [<name>]" "Unmount an already mounted remote."
}

loop () {
  clear

  while true; do
    prompt && history -s "${REPLY}"

    set -f
    set_separator "line"
    local cmd=($(xargs -n1 <<< "${REPLY}"))
    restore_separator && set +f

    if [[ "${cmd[0]}" == "help" ]]; then
      show_help
      continue
    elif [[ "${cmd[0]}" == "clear" ]]; then
      clear
      continue
    elif [[ "${cmd[0]}" == "quit" ]]; then
      break
    elif [[ -z "${cmd[0]}" ]]; then
      continue
    fi

    case "${cmd[0]}" in
      "list")
        case "${cmd[1]}" in
          "remotes") list_remotes "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "sync")
        case "${cmd[1]}" in
          "remote")
            case "${cmd[2]}" in
              "drive") sync_drive "${cmd[3]}";;
              "dropbox") sync_dropbox "${cmd[3]}";;
              *) echo "Invalid or unknown service";;
            esac;;
          *) echo "Invalid or unknown command";;
        esac;;
      "delete")
        case "${cmd[1]}" in
          "remote") delete_remote "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "mount")
        case "${cmd[1]}" in
          "remote") mount_remote "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "unmount")
        case "${cmd[1]}" in
          "remote") unmount_remote "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      *) echo "Unknown or invalid command";; 
    esac

    if [[ $? -eq 1 ]]; then
      echo "An unknown error has occurred"
    fi
  done

  clear
}

once () {
  case "${1}" in
    "help") show_help "once";;
    "mount")
      case "${2}" in
        "remotes") mount_all || abort;;
        *) abort "Invalid or unknown command";;
      esac;;
    *) abort "Invalid or unknown command";;
  esac

  if [[ $? -ne 0 ]]; then
    abort
  fi
}

if [[ $# -eq 0 ]]; then
  loop
else
  once "$@"
fi