#!/usr/bin/env bash

source /opt/stack/utils

require "trash-cli"

prompt () {
  local YELLOW=$'\e[0;33m'
  local MAGENTA=$'\e[0;35m'
  local RS=$'\e[m'

  local FG=$YELLOW
  if [[ "$(id -u)" == "0" ]]; then
    FG=$MAGENTA
  fi

  local CURRENT_PATH="../${PWD/*\//}"
  local COUNTER=$(count_files)

  read -rep "[trash:$FG${COUNTER}$RS $FG${CURRENT_PATH}$RS] " REPLY
}

count_files () {
  trash-list |
    awk '/[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2} \/.*/{print}' |
    wc -l
}

list_files () {
  local FILTER=$1
  local COUNTER=$(count_files)

  if [ $COUNTER -eq 0 ]; then
    echo "Trash is empty, no files to list."
    return
  fi

  if [ -z "$FILTER" ]; then
    trash-list
    return
  fi

  if [[ "$FILTER" =~ ^[0-9]+$ ]]; then
    trash-list | awk -v days=$FILTER -v today=$(date +%s) \
      '{cmd="date -d" $1 " +%s"; cmd | getline trashed_day; close(cmd); \
        if (((today-trashed_day) / 86400) < days + 1) {print}}'
  elif [[ "$FILTER" =~ ^\+[0-9]+$ ]]; then
    trash-list | awk -v days=$FILTER -v today=$(date +%s) \
      '{cmd="date -d" $1 " +%s"; cmd | getline trashed_day; close(cmd); \
        if (((today-trashed_day) / 86400) > days + 1) {print}}'
  elif [[ "$FILTER" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] && date -d "$FILTER" &> /dev/null; then
    trash-list | awk -v day="$(date -d $FILTER +%s)" \
      '{cmd="date -d" $1 " +%s"; cmd | getline trashed_day; close(cmd); \
        if (day-trashed_day == 0) {print}}'
  else
    echo "Invalid days or date argument: '$FILTER'"
    return 1
  fi
}

restore_files () {
  local RESTORE_PATH=$1
  local COUNTER=$(count_files)

  if [ $COUNTER -eq 0 ]; then
    echo "Trash is empty, no files to restore."
    return
  fi

  trash-restore "$RESTORE_PATH"

  local NEW_COUNTER=$(count_files)
  local RESTORED=$((COUNTER - NEW_COUNTER))

  echo "$RESTORED files have been restored."
}

remove_files () {
  local FILE_PATTERN=$1
  local COUNTER=$(count_files)

  if [ $COUNTER -eq 0 ]; then
    echo "Trash is empty, no files to remove."
    return
  fi

  if [ -z "$FILE_PATTERN" ]; then
    echo "Missing pattern argument"
    return 1
  fi
  
  echo "CAUTION: Any trashed files or directories matched"
  echo "by the given pattern will be removed forever."
  askme "Do you want to proceed?" "yes" "no"

  if [ "$REPLY" = "yes" ]; then
    trash-rm "$FILE_PATTERN"
  fi

  local NEW_COUNTER=$(count_files)
  local GONE=$((COUNTER - NEW_COUNTER))

  echo "$GONE files have been removed."
}

empty_files () {
  local DAYS=$1
  local COUNTER=$(count_files)

  if [[ $COUNTER -eq 0 ]]; then
    echo "Trash is empty, no files to remove."
    return
  fi
  
  if [ -n "$DAYS" ] && [[ "$DAYS" =~ ^[0-9]+$ ]]; then
    echo "CAUTION: Any files or directories trashed more"
    echo "than $DAYS day(s) ago will be removed forever."
    askme "Do you want to proceed?" "yes" "no"

    [ "$REPLY" = "yes" ] && trash-empty -f "$DAYS"
  elif [ -z "$DAYS" ]; then
    echo "CAUTION: ALL files and directories trashed"
    echo "until this day will be removed forever."
    askme "Do you want to proceed?" "yes" "no"

    [ "$REPLY" = "yes" ] && trash-empty -f
  else
      echo "Invalid days argument: '$DAYS'"
  fi

  local NEW_COUNTER=$(count_files)
  local GONE=$((COUNTER - NEW_COUNTER))

  echo "$GONE files have been removed."
}

trash_files () {
  local FILES=("$@")
  local LEN=${#FILES[@]}

  if [ $LEN -eq 0 ]; then
    abort "Unable to trash, no files are given."
  fi

  local COUNTER=$(count_files)

  local INDEX=0
  while [ $INDEX -lt $LEN ]; do
    local FILE=${FILES[$INDEX]}

    trash-put "$FILE" &> /dev/null ||
      echo "Cannot trash the file: '$FILE'"

    INDEX=$((INDEX + 1))
  done

  local NEW_COUNTER=$(count_files)
  local TRASHED=$((NEW_COUNTER - COUNTER))

  echo "$TRASHED files have been trashed."
}

wipe_files () {
  local FILES=("$@")
  local LEN=${#FILES[@]}

  if [ $LEN -eq 0 ]; then
    abort "Unable to remove, no files are given."
  fi

  echo "CAUTION: Any given file or directory passed"
  echo "as argument will be removed forever."
  askme "Do you want to proceed?" "yes" "no"

  if [ "$REPLY" = "no" ]; then
    return
  fi

  local INDEX=0
  local REMOVED=0
  while [ $INDEX -lt $LEN ]; do
    local FILE=${FILES[$INDEX]}

    rm -r --interactive=never "$FILE" &> /dev/null &&
      REMOVED=$((REMOVED + 1)) ||
      echo "Cannot remove the file: '$FILE'"

    INDEX=$((INDEX + 1))
  done

  echo "$REMOVED files have been removed."
}

help () {
  local FRM=" %-20s\t%s\n"

  if [ "$1" = "args" ]; then
    echo "Usage: trash [OPTIONS] FILE..."

    echo -e "\nOPTIONS"
    printf "$FRM" \
      "r, --remove" "Remove given files permanently." \
      "h, --help" "Show this help message."
    
    return
  fi

  echo "Usage: COMMAND [ARGUMENTS]..."
  
  echo -e "\nCOMMANDS"
  printf "$FRM" \
    "help" "Show this help message." \
    "" "" \
    "list" "List all trashed files." \
    "list <days>" "List files trashed within the given days." \
    "list +<days>" "List files trashed more than the given days ago." \
    "list <date>" "List files trashed at a specific date, given as YYYY-mm-dd." \
    "" "" \
    "restore [<path>]" "Restore files from the current directory or given path." \
    "remove <pattern>" "Remove files matched by the given pattern." \
    "empty" "Remove all trashed files." \
    "empty <days>" "Remove files trashed more than the given days ago."
}

loop () {
  clear

  while true; do
    prompt && history -s "$REPLY"

    set -f
    local OLD_IFS=$IFS && IFS=$'\n'
    local CMD=($(xargs -n1 <<< "$REPLY"))
    IFS=$OLD_IFS && set +f

    if [ "${CMD[0]}" = "help" ]; then
      help
      continue
    elif [ "${CMD[0]}" = "clear" ]; then
      clear
      continue
    elif [ "${CMD[0]}" = "quit" ]; then
      break
    elif [ -z "${CMD[0]}" ]; then
      continue
    fi

    case "${CMD[0]}" in
      "list") list_files "${CMD[1]}";;
      "restore") restore_files "${CMD[1]}";;
      "remove") remove_files "${CMD[1]}";;
      "empty") empty_files "${CMD[1]}";;
      *) echo "Unknown or invalid command: '$REPLY'";; 
    esac
  done

  clear
}

once () {
  local OPTS=""
  local FILES=()

  while true; do
    if [ "$1" = "-r" ] || [ "$1" = "--remove" ]; then
      OPTS="$OPTS remove"
    elif [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
      OPTS="$OPTS help"
    elif [[ "$1" =~ ^(-|--) ]]; then
      abort "Unknown or invalid option: '$1'"
    elif [ -n "$1" ]; then
      FILES+=("$1")
    else
      break
    fi

    shift
  done

  if [[ "$OPTS" =~ "help" ]]; then
    help "args"
  elif [[ "$OPTS" =~ "remove" ]]; then
    wipe_files "${FILES[@]}"
  else
    trash_files "${FILES[@]}"
  fi
}

if [ $# = 0 ]; then
  loop
else
  once "$@"
fi