#!/usr/bin/env bash

source /opt/stack/utils

require "trash-cli"

prompt () {
  local Y=$'\e[0;33m'
  local M=$'\e[0;35m'
  local R=$'\e[m'

  local C=$Y
  if [[ "$(id -u)" == "0" ]]; then
    C=$M
  fi

  local CURRENT_PATH="../${PWD/*\//}"
  local COUNTER=$(count_files)

  read -rep "[trash:$C$COUNTER$R $C$CURRENT_PATH$R] " REPLY
}

count_files () {
  trash-list |
    awk '/[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2} \/.*/{print}' |
    wc -l
}

list_files () {
  local FILTER=$1
  local COUNTER=$(count_files)

  if [ $COUNTER -eq 0 ]; then
    echo "Trash is empty, no files to list."
    return
  fi

  if [ -n "$FILTER" ]; then
    if [[ "$FILTER" =~ ^[0-9]+$ ]]; then
      trash-list | awk -v days=$FILTER -v today=$(date +%s) \
        '{cmd="date -d" $1 " +%s"; cmd | getline day; close(cmd); \
          if (((today-day) / 86400) < days + 1) {print}}'
    elif [[ "$FILTER" =~ ^\+[0-9]+$ ]]; then
      trash-list | awk -v days=$FILTER -v today=$(date +%s) \
        '{cmd="date -d" $1 " +%s"; cmd | getline day; close(cmd); \
          if (((today-day) / 86400) > days + 1) {print}}'
    elif [[ "$FILTER" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] && date -d "$FILTER" >/dev/null 2>&1; then
      trash-list | awk -v day="$(date -d $FILTER +%s)" \
        '{cmd="date -d" $1 " +%s"; cmd | getline trashed_day; close(cmd); \
          if (day-trashed_day == 0) {print}}'
    else
      echo "Invalid days or date filter argument: '$FILTER'"
    fi
  else
    trash-list
  fi
}

restore_files () {
  local RESTORE_PATH=$1
  local COUNTER=$(count_files)

  if [ $COUNTER -eq 0 ]; then
    echo "Trash is empty, no files to restore."
    return
  fi

  trash-restore "$RESTORE_PATH"

  local NEW_COUNTER=$(count_files)
  local RESTORED=$((COUNTER - NEW_COUNTER))

  if [ $RESTORED -gt 1 ]; then
    echo "$RESTORED files have been restored."
  elif [ $RESTORED -eq 1 ]; then
    echo "$RESTORED file has been restored."
  else
    echo "No file has been restored."
  fi
}

remove_files () {
  local FILE_PATTERN=$1
  local COUNTER=$(count_files)

  if [ $COUNTER -eq 0 ]; then
    echo "Trash is empty, no files to remove."
    return
  fi
  
  askme "Any files matched by the pattern will be removed, proceed?" "yes" "no"

  if [ "$REPLY" = "yes" ]; then
    if [ -n "$FILE_PATTERN" ]; then
      trash-rm "$FILE_PATTERN"
    else
      echo "Invalid pattern argument: '$FILE_PATTERN'"
    fi
  fi

  local NEW_COUNTER=$(count_files)
  local GONE=$((COUNTER - NEW_COUNTER))

  if [ $GONE -gt 1 ]; then
    echo "$GONE files have been removed."
  elif [ $GONE -eq 1 ]; then
    echo "$GONE file has been removed."
  else
    echo "No file has been removed."
  fi
}

empty_files () {
  local DAYS=$1
  local COUNTER=$(count_files)

  if [[ $COUNTER -eq 0 ]]; then
    echo "Trash is empty, no files to remove."
    return
  fi
  
  if [ -n "$DAYS" ]; then
    if [[ "$DAYS" =~ ^[0-9]+$ ]]; then
      askme "Files trashed more than $DAYS day(s) ago will be removed, proceed?" "yes" "no"

      if [ "$REPLY" = "yes" ]; then
        trash-empty -f "$DAYS"
      fi
    else
      echo "Invalid days argument: '$DAYS'"
    fi
  else
    askme "All trashed files will be removed, proceed?" "yes" "no"

    if [ "$REPLY" = "yes" ]; then
      trash-empty -f
    fi
  fi

  local NEW_COUNTER=$(count_files)
  local GONE=$((COUNTER - NEW_COUNTER))

  if [ $GONE -gt 1 ]; then
    echo "$GONE files have been removed."
  elif [ $GONE -eq 1 ]; then
    echo "$GONE file has been removed."
  else
    echo "No file has been removed."
  fi
}

trash_files () {
  local FILES=("$@")
  local LEN=${#FILES[@]}

  if [ $LEN -eq 0 ]; then
    abort "Unable to trash, no files are given."
  fi

  local COUNTER=$(count_files)

  local INDEX=0
  while [ $INDEX -lt $LEN ]; do
    local FILE=${FILES[$INDEX]}

    trash-put "$FILE" &> /dev/null ||
      echo "Cannot trash the file: '$FILE'"

    INDEX=$((INDEX + 1))
  done

  local NEW_COUNTER=$(count_files)
  local TRASHED=$((NEW_COUNTER - COUNTER))

  if [ $TRASHED -gt 1 ]; then
    echo "$TRASHED files have been trashed."
  elif [ $TRASHED -eq 1 ]; then
    echo "$TRASHED file has been trashed."
  else
    echo "No file has been trashed."
  fi
}

wipe_files () {
  local FILES=("$@")
  local LEN=${#FILES[@]}

  if [ $LEN -eq 0 ]; then
    abort "Unable to remove, no files are given."
  fi

  askme "Files will be removed forever, proceed?" "yes" "no"

  if [ "$REPLY" = "yes" ]; then
    local INDEX=0
    while [ $INDEX -lt $LEN ]; do
      local FILE=${FILES[$INDEX]}

      rm -rf "$FILE" &> /dev/null ||
        echo "Cannot remove file: '$FILE'"

      INDEX=$((INDEX + 1))
    done
  fi
}

help () {
  local MODE=$1

  if [ "$MODE" = "noargs" ]; then
    echo "Usage: COMMAND [ARGUMENTS]..."
  
    echo -e "\nCOMMANDS"
    printf " %-20s\t%s\n" \
      "list [<days>]" "List files trashed within the given days, default" \
      "" "is all files." \
      "list [+<days>]" "List files trashed more than the given days ago." \
      "list [<date>]" "List files trashed at a specific date (YYYY-mm-dd)." \
      "restore [<path>]" "Restore files from the given path, default is the" \
      "" "current directory." \
      "remove <pattern>" "Remove files matched by the given pattern." \
      "empty [<days>]" "Remove files trashed more than the given days ago," \
      "" "default is all files." \
      "help" "Show this help message."
  else
    echo "Usage: trash [OPTIONS] FILE..."

    echo -e "\nOPTIONS"
    printf " %-20s\t%s\n" \
      "r, --remove" "Remove given files permanently." \
      "h, --help" "Show this help message."
  fi
}

main () {
  if [ $# = 0 ]; then
    clear

    while true; do
      prompt

      history -s "$REPLY"
      local CMD=($(echo "$REPLY" | tr ':' '\n'))

      if [ "${CMD[0]}" = "help" ]; then
        help "noargs"
        continue
      elif [ "${CMD[0]}" = "clear" ]; then
        clear
        continue
      elif [ "${CMD[0]}" = "quit" ]; then
        break
      elif [ -z "${CMD[0]}" ]; then
        continue
      fi

      case "${CMD[0]}" in
        "list") list_files "${CMD[@]:1}";;
        "restore") restore_files "${CMD[@]:1}";;
        "remove") remove_files "${CMD[@]:1}";;
        "empty") empty_files "${CMD[@]:1}";;
        *) echo "Unknown or invalid command: '$REPLY'";; 
      esac
    done
  else
    local OPTS=""
    local FILES=()

    while true; do
      if [ "$1" = "-r" ] || [ "$1" = "--remove" ]; then
        OPTS="$OPTS remove"
      elif [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
        OPTS="$OPTS help"
      elif [[ "$1" =~ ^(-|--) ]]; then
        abort "Unknown or invalid option: '$1'"
      elif [ -n "$1" ]; then
        FILES+=("$1")
      else
        break
      fi

      shift
    done

    if [[ "$OPTS" =~ "help" ]]; then
      help
    elif [[ "$OPTS" =~ "remove" ]]; then
      wipe_files "${FILES[@]}"
    else
      trash_files "${FILES[@]}"
    fi
  fi
}

main "$@"
