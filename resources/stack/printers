#!/bin/bash

set -o pipefail
source /opt/stack/utils

# Returns the list of all printing destinations,
# which have been installed into the system.
# Arguments:
#  None
# Outputs:
#  A json array of print destination objects.
find_destinations () {
  local destinations=''
  destinations="$(lpstat -v 2>&1)"

  local error_code=$?

  if [[ "${destinations}" =~ "No destinations added" ]]; then
    echo '[]'
    return 0
  elif [[ ${error_code} -ne 0 ]]; then
    return 1
  fi
  
  destinations="$(echo "${destinations}" | awk '/device for.*/{
    match($0, /device for (.*): (.*):(.*)/, a)

    schema="\"name\": \"%s\","
    schema=schema"\"protocol\": \"%s\","
    schema=schema"\"uri\": \"%s\""
    schema="{"schema"},"

    printf schema, a[1], a[2], a[2]":"a[3]
  }')"

  # Remove the extra comma after the last element
  if [[ -n "${destinations}" ]]; then
    destinations="${destinations::-1}"
  fi

  echo "[${destinations}]"
}

# Returns the print destination with the given name.
# Arguments:
#  None
# Outputs:
#  A json object of print destination.
find_destination () {
  local name="${1}"

  local query=".[]|select(.name == \"${name}\")"

  local destination=''
  destination="$(find_destinations | jq -cer "${query}")" || return 1

  local options=''
  options="$(lpoptions -p "${name}" -l | awk '{
    match($0, /(.*)\/(.*):.*\*([^ ]*).*/, a)

    schema="\"%s\": \"%s\","
    printf schema, a[1], a[3]
  }')" || return 1

  # Remove the extra comma after the last pair
  if [[ -n "${options}" ]]; then
    options="${options::-1}"
  fi

  options="{${options}}"

  echo "${destination}" | jq -cer --argjson o "${options}" '. + $o' || return 1
}

# Checks if a destination with the given name exists.
# Arguments:
#  name: the name of a print destination
# Returns:
#  0 if exists otherwise 1.
exists_destination () {
  local name="${1}"

  local query=".[]|select(.name == \"${name}\")"

  local destination=''
  destination="$(find_destinations | jq -cer "${query}")" || return 1

  if [[ -n "${destination}" ]]; then
    return 0
  else
    return 1
  fi
}

# Discovers any direct or network print destinations.
# Arguments:
#  None
# Outputs:
#  A json array of print destination objects.
discover_destinations () {
  local destinations=''

  # Search in local network for snmp destinations
  local hosts=''
  hosts="$(find_hosts | jq -cer '.[]|.ip')" || return 1

  if [[ -n "${hosts}" ]]; then
    local host=''
    while read -r host; do
      destinations+="$(/usr/lib/cups/backend/snmp "${host}" 2>&1 |
        awk '/^network\s.*:\/\//{
          match($0, /^network\s.*:\/\/.*\s"(.*)"\s".*"\s".*".*/, a)

          schema="\"type\": \"%s\","
          schema=schema"\"uri\": \"%s\","
          schema=schema"\"name\": \"%s\""
          schema="{"schema"},"

          printf schema, $1, $2, a[1]
        }')" || continue
    done <<< "${hosts}"
  fi

  # Search for extra direct and network destinations
  destinations+="$(lpinfo -v 2>&1 | awk '/^(direct|network)\s.*:\/\//{
    match($0, /^(direct|network)\s.*:\/\/.*\s"(.*)"\s".*"\s".*".*/, a)

    schema="\"type\": \"%s\","
    schema=schema"\"uri\": \"%s\","
    schema=schema"\"name\": \"%s\""
    schema="{"schema"},"

    printf schema, $1, $2, a[1]
  }')" || return 1

  # Remove the extra comma after the last element
  if [[ -n "${destinations}" ]]; then
    destinations="${destinations::-1}"
  fi

  echo "[${destinations}]"
}

# Returns all the active queued print jobs.
# Arguments:
#  None
# Outputs:
#  A json array list of print job objects.
find_jobs () {
  local jobs=''
  jobs="$(lpq -a | awk '{
    if (NR==1) next

    match($0, /.*\s+([0-9]{1,3})\s+(.*)\s+([0-9]+)\sbytes$/, a)

    schema="\"id\": \"%s\","
    schema=schema"\"rank\": \"%s\","
    schema=schema"\"file\": \"%s\","
    schema=schema"\"size\": \"%s\""
    schema="{"schema"},"

    printf schema, a[1], $1, a[2], a[3]
  }')" || return 1

  # Remove the extra comma after the last element
  if [[ -n "${jobs}" ]]; then
    jobs="${jobs::-1}"
  fi

  echo "[${jobs}]"
}

# Checks if a print job with the given id exists.
# Arguments:
#  id: the id of a print job
# Returns:
#  0 if exists otherwise 1.
exists_job () {
  local id="${1}"

  local query=".[]|select(.id == \"${id}\")"

  local job=''
  job="$(find_jobs | jq -cer "${query}")" || return 1

  if [[ -n "${id}" ]]; then
    return 0
  else
    return 1
  fi
}

# Shows a menu asking the user to select one printer,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of printers.
pick_printer () {
  local query='{key: .name, value: "\(.name) [\(.uri)]"}'
  query="[.[]|${query}]"

  local destinations=''
  destinations="$(find_destinations | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${destinations}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No printer have found"
    return 2
  fi

  pick_one "Select a printer:" "${destinations}" "vertical" || return $?
}

# Shows a menu asking the user to select one driver,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of printer drivers.
pick_driver () {
  local drivers=''
  drivers="$(lpinfo -m 2>&1 | awk '{
    desc=""
    for(i=2; i<=NF; i++) {
      if (i>2) desc=desc" " 
      desc=desc$i
    }

    schema="\"key\": \"%s\","
    schema=schema"\"value\": \"%s\""
    schema="{"schema"},"

    printf schema, $1, desc
  }')" || return 1

  # Remove the extra comma after the last element
  if [[ -n "${drivers}" ]]; then
    drivers="${drivers::-1}"
  fi

  drivers="[${drivers}]"
  
  local len=0
  len="$(count "${drivers}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No drivers have found"
    return 2
  fi

  pick_one "Select a driver:" "${drivers}" "vertical" || return $?
}

# Shows a menu asking the user to select one print job,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of print jobs.
pick_job () {
  local query='{key: .id, value: "\(.id) [\(.file)]"}'
  query="[.[]|${query}]"

  local jobs=''
  jobs="$(find_jobs | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${jobs}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No print jobs have found"
    return 2
  fi

  pick_one "Select a print job:" "${jobs}" "vertical" || return $?
}

# Shows a menu asking the user to select a quality option,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of quality options.
pick_quality () {
  local values=''
  values+='{"key": "600dpi", "value": "Standard [600dpi]"},'
  values+='{"key": "1200dpi", "value": "High Resolution [1200dpi]"}'
  values="[${values}]"

  pick_one "Select a quality:" "${values}" "vertical" || return $?
}

# Shows a menu asking the user to select a page size option,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of page size options.
pick_page_size () {
  local values=''
  values+='{"key": "Letter", "value": "Letter [Letter]"},'
  values+='{"key": "Legal", "value": "Legal [Legal]"},'
  values+='{"key": "A4", "value": "A4 [A4]"},'
  values+='{"key": "A5", "value": "A5 [A5]"},'
  values+='{"key": "Executive", "value": "Executive [Executive]"},'
  values+='{"key": "Folio", "value": "US Folio [Folio]"},'
  values+='{"key": "JB5", "value": "JIS B5 [JB5]"},'
  values+='{"key": "B5-ISO", "value": "ISO B5 [B5-ISO]"},'
  values+='{"key": "COM10", "value": "No.10 Env. [COM10]"},'
  values+='{"key": "Monarch", "value": "Monarch Env. [Monarch]"},'
  values+='{"key": "DL", "value": "DL Env. [DL]"},'
  values+='{"key": "C5", "value": "C5 Env. [C5]"},'
  values+='{"key": "Oficio_S", "value": "Oficio [Oficio_S]"},'
  values+='{"key": "PCard4x6", "value": "Post Card 4x6 [PCard4x6]"}'
  values="[${values}]"

  pick_one "Select a page size:" "${values}" "vertical" || return $?
}

# Shows a menu asking the user to select a paper type option,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of paper type options.
pick_paper_type () {
  local values=''
  values+='{"key": "None", "value": "Printer Default [None]"},'
  values+='{"key": "Plain", "value": "Plain [Plain]"},'
  values+='{"key": "Thick", "value": "Thick [Thick]"},'
  values+='{"key": "Thin", "value": "Thin [Thin]"},'
  values+='{"key": "Bond", "value": "Bond [Bond]"},'
  values+='{"key": "Color", "value": "Color [Color]"},'
  values+='{"key": "Card", "value": "CardStock [Card]"},'
  values+='{"key": "Labels", "value": "Labels [Labels]"},'
  values+='{"key": "Preprinted", "value": "Preprinted [Preprinted]"},'
  values+='{"key": "Cotton", "value": "Cotton [Cotton]"},'
  values+='{"key": "Archive", "value": "Archive [Archive]"},'
  values+='{"key": "Recycled", "value": "Recycled [Recycled]"},'
  values+='{"key": "Envelope", "value": "Envelope [Envelope]"}'
  values="[${values}]"

  pick_one "Select a paper type:" "${values}" "vertical" || return $?
}

# Shows a menu asking the user to select a toner mode option,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of toner mode options.
pick_toner_mode () {
  local values=''
  values+='{"key": "Save", "value": "Save"},'
  values+='{"key": "Standard", "value": "Standard"}'
  values="[${values}]"

  pick_one "Select a toner mode:" "${values}" "vertical" || return $?
}

# Shows a menu asking the user to select a error policy option,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of error policy options.
pick_error_policy () {
  local values=''
  values+='{"key": "abort-job", "value": "Abort Job [abort-job]"},'
  values+='{"key": "retry-current-job", "value": "Retry Current Job [retry-current-job]"},'
  values+='{"key": "retry-job", "value": "Retry Job [retry-job]"},'
  values+='{"key": "stop-printer", "value": "Stop Printer [stop-printer]"}'
  values="[${values}]"

  pick_one "Select an error policy:" "${values}" "vertical" || return $?
}

# Shows a prompt status and asks user to enter the
# next command, which is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A minimal prompt status line.
prompt () {
  local status=''
  status="$(lpstat -d | awk -F':' '{print $2}' | trim)"

  if [[ $? -ne 0 ]] || [[ -z "${status}" ]]; then
    status="none"
  fi

  read -rep "[printers:${status}] " REPLY
}

# Shows a short status of cups service and printers.
# Arguments:
#  None
# Outputs:
#  A list of cups and printer data.
show_status () {
  systemctl status --lines 0 --no-pager cups.service | awk '{
    if ($0 ~ / *Active/) {
      l = "Service"
      v = $2" "$3
    } else l = ""

    if (l) printf "%-9s %s\n",l":",v
  }' || return 1

  echo "Cups:     $(cups-config --version)"
  echo "API:      $(cups-config --api-version)"
  echo "Dir:      $(cups-config --datadir)"

  find_jobs | jq -cer "\"Jobs:     \(length)\"" || return 1

  local destinations=''
  destinations="$(find_destinations)" || return 1

  local len=0
  len="$(count "${destinations}")" || return 1

  if [[ ${len} -gt 0 ]]; then
    echo ""
    local query=''
    query+='Printer:  \(.name)\n'
    query+='URI:      \(.uri)'
    query="[.[]|\"${query}\"]|join(\"\n\n\")"

    echo "${destinations}" | jq -cer "${query}" || return 1
  fi
}

# Shows the list of all printers.
# Arguments:
#  None
# Outputs:
#  A list of printers.
list_printers () {
  local destinations=''
  destinations="$(find_destinations)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read print destinations"
    return 2
  fi

  local len=0
  len="$(count "${destinations}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No printers have found"
    return 0
  fi

  local query=''
  query+='Name:  \(.name)\n'
  query+='URI:   \(.uri)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${destinations}" | jq -cer "${query}" || return 1
}

# Shows the data of the printer with the given
# print destination name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of a print destination
# Outputs:
#  A long list of printer data.
show_printer () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_printer || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! exists_destination "${name}"; then
    echo "Cannot find printer ${name}"
    return 2
  fi

  local query=''
  query+='Name:        \(.name)\n'
  query+='URI:         \(.uri)\n'
  query+='Protocol:    \(.protocol)\n'
  query+='Color:       \(.ColorModel)\n'
  query+='Quality:     \(.Quality)\n'
  query+='Brightness:  \(.secBrightness)\n'
  query+='Contrast:    \(.secContrast)\n'
  query+='Input:       \(.InputSlot)\n'
  query+='Toner:       \(.TonerSaveMode)\n'
  query+='Page:        \(.PageSize)\n'
  query+='Paper:       \(.MediaType)\n'
  query+='Blank:       \(.JCLSkipBlankPages)\n'
  query+='Enhance:     \(.JCLEdgeEnhance)'
  query="\"${query}\""

  find_destination "${name}" | jq -cer "${query}" || return 1
}

# Adds the printer with the given uri.
# Globals:
#  REPLY
# Arguments:
#  name: the name of print destination
#  uri:  the uri of a print destination
add_printer () {
  local name="${1}"
  local uri="${2}"

  if [[ -z "${name}" ]]; then
    echo "Missing the name value"
    return 2
  elif exists_destination "${name}"; then
    echo "Printer with name ${name} already exists"
    return 2
  fi

  if [[ -z "${uri}" ]]; then
    echo "Discovering print destinations..."

    local query=''
    query+='{key: .uri, value: "\(.uri)\(.name|if (. and . != "") then " [\(.)]" else "" end)"}'
    query="[.[]|${query}]"

    local destinations=''
    destinations="$(discover_destinations | jq -cer "${query}")" || return 1

    local len=0
    len="$(count "${destinations}")" || return 1

    if [[ ${len} -eq 0 ]]; then
      echo "No printers have been discovered"
      return 0
    fi

    pick_one "Select a printer:" "${destinations}" "vertical" || return $?
    [[ -n "${REPLY}" ]] && uri="${REPLY}" || return 0
  fi

  ask "Enter a description:" ".+" || return $?
  local desc="${REPLY}"

  ask "Enter a location name:" ".+" || return $?
  local loc="${REPLY}"

  local driver=''
  pick_driver || return $?
  [[ -n "${REPLY}" ]] && driver="${REPLY}" || return 0

  lpadmin -p "${name}" -E \
    -o printer-is-shared=false \
    -D "${desc}" -L "${loc}" -v "${uri}" -m "${driver}" &> /dev/null

  if [[ $? -ne 0 ]]; then
    echo "Failed to add printer ${uri}"
    return 2
  fi

  local is_default=''
  confirm "Want to set this printer as default?" || return $?
  [[ -n "${REPLY}" ]] && is_default="${REPLY}" || return 0

  if [[ "${is_default}" == "yes" ]]; then
    lpoptions -d "${name}" &> /dev/null ||
      echo "Failed to set printer as default"
  fi

  echo "Printer ${uri} has been added"
}

# Removes the printer destination with the
# given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of a print destination
remove_printer () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_printer || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! exists_destination "${name}"; then
    echo "Cannot find printer ${name}"
    return 2
  fi

  lpadmin -x "${name}" &> /dev/null

  if [[ $? -ne 0 ]]; then
    echo "Failed to remove printer ${name}"
    return 2
  fi

  echo "Printer ${name} has been removed"
}

# Shares the printer with the given name
# to the local network.
# Globals:
#  REPLY
# Arguments:
#  name: the name of a print destination
share_printer () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_printer || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! exists_destination "${name}"; then
    echo "Cannot find printer ${name}"
    return 2
  fi

  lpadmin -p "${name}" -o printer-is-shared=true &> /dev/null

  if [[ $? -ne 0 ]]; then
    echo "Failed to share printer ${name}"
    return 2
  fi

  echo "Printer ${name} has been shared"
}

# Unshares the printer with the given name
# of the local network.
# Globals:
#  REPLY
# Arguments:
#  name: the name of a print destination
unshare_printer () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_printer || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! exists_destination "${name}"; then
    echo "Cannot find printer ${name}"
    return 2
  fi

  lpadmin -p "${name}" -o printer-is-shared=false &> /dev/null

  if [[ $? -ne 0 ]]; then
    echo "Failed to unshare printer ${name}"
    return 2
  fi

  echo "Printer ${name} has been unshared"
}

# Sets the given option to the printer with
# the given name.
# Arguments:
#  name:  the name of a print destination
#  key:   the key name of the option
#  value: the value of the option
set_option () {
  local name="${1}"
  local key="${2}"
  local value="${3}"

  if [[ -z "${name}" ]]; then
    pick_printer || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! exists_destination "${name}"; then
    echo "Cannot find printer ${name}"
    return 2
  fi

  if [[ -z "${key}" ]]; then
    echo "Missing the option key value"
    return 2
  elif [[ ! "${key}" =~ ^(Quality|PageSize|MediaType|TonerSaveMode|printer-error-policy)$ ]]; then
    echo "Option ${key} is not supported"
    return 2
  fi

  if [[ -z "${value}" ]]; then
    case "${key}" in
      "Quality") pick_quality || return $?;;
      "PageSize") pick_page_size || return $?;;
      "MediaType") pick_paper_type || return $?;;
      "TonerSaveMode") pick_toner_mode || return $?;;
      "printer-error-policy") pick_error_policy || return $?;;
      *) echo "Unknown or invalid printer option" && return 2;;
    esac

    [[ -n "${REPLY}" ]] && value="${REPLY}" || return 0
  fi

  local re=''
  re+='600dpi|1200dpi|'
  re+='Letter|Legal|A4|A5|Executive|Folio|JB5|B5-ISO|COM10|Monarch|DL|C5|Oficio_S|PCard4x6|'
  re+='Save|Standard|'
  re+='None|Plain|Thick|Thin|Bond|Color|Card|Labels|Preprinted|Cotton|Archive|Recycled|Envelope|'
  re+='abort-job|retry-current-job|retry-job|stop-printer'

  if [[ ! "${value,,}" =~ ^(${re,,})$ ]]; then
    echo "Invalid option value"
    return 2
  fi

  lpadmin -p "${name}" -o "${key}"="${value}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to set printer option ${key}"
    return 2
  fi

  echo "Printer ${key} set to ${value}"
}

# Sets the printer with the given name as default
# print destination.
# Arguments:
#  name: the name of a print destination
set_default () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_printer || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! exists_destination "${name}"; then
    echo "Cannot find printer ${name}"
    return 2
  fi

  lpoptions -d "${name}" &> /dev/null

  if [[ $? -ne 0 ]]; then
    echo "Failed to set ${name} as default printer"
    return 2
  fi

  echo "Printer ${name} set as default"
}

# Shows the list of all queued print jobs.
# Arguments:
#  None
# Outputs:
#  A list of print jobs.
list_jobs () {
  local jobs=''
  jobs="$(find_jobs)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read print jobs"
    return 2
  fi

  local len=0
  len="$(count "${jobs}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No active print jobs have found"
    return 0
  fi

  local query=''
  query+='ID:    \(.id)\n'
  query+='Rank:  \(.rank)\n'
  query+='File:  \(.file)\n'
  query+='Size:  \(.size)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${jobs}" | jq -cer "${query}" || return 1
}

# Cancels the queued job with the given id.
# Globals:
#  REPLY
# Arguments:
#  id: the id of a print job
cancel_job () {
  local id="${1}"

  if [[ -z "${id}" ]]; then
    pick_job || return $?
    [[ -n "${REPLY}" ]] && id="${REPLY}" || return 0
  fi

  if ! exists_job "${id}"; then
    echo "Cannot find print job ${id}"
    return 2
  fi

  cancel -x "${id}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to cancel print job ${id}"
    return 2
  fi

  echo "Print job ${id} has been canceled"
}

# Restarts the cup service.
# Arguments:
#  None
restart () {
  sudo echo "Restarting the cups service..."

  sudo systemctl restart cups.service

  if [[ $? -ne 0 ]]; then
    echo "Failed to restart cups service"
    return 2
  fi

  echo "Cups service has been restarted"
}

# Shows the help message.
# Arguments:
#  None
# Outputs:
#  A long help message.
show_help () {
  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf " %-40s %s\n" \
    "help" "Show this help message." \
    "" "" \
    "show status" "Show a report of cups service and printers." \
    "show printer [<name>]" "Show the data of a printer." \
    "" "" \
    "list printers" "List all printers." \
    "add printer <name> [<uri>]" "Add a new printer." \
    "remove printer [<name>]" "Remove a printer." \
    "" "" \
    "set quality [<name> [600dpi|1200dpi]]" "Set the print quality of a printer." \
    "set size [<name> [<size>]]" "Set the default page size of a printer." \
    "set paper [<name> [<type>]]" "Set the paper type of a printer." \
    "set toner [<name> [standard|save]]" "Set the toner mode of a printer." \
    "set onerror [<name> [<policy>]]" "Set the on error policy of a printer." \
    "set default [<name>]" "Set a printer as default print destination." \
    "" "" \
    "share printer [<name>]" "Share a printer to the local network." \
    "unshare printer [<name>]" "Unshare a printer of the local network." \
    "" "" \
    "list jobs" "List all queued print jobs." \
    "cancel job [<id>]" "Cancel a queued print job." \
    "" "" \
    "restart" "Restart the cups service."
}

loop () {
  clear

  while true; do
    prompt && history -s "${REPLY}"

    set -f
    set_separator "line"
    local cmd=($(xargs -n1 <<< "${REPLY}"))
    restore_separator && set +f

    if [[ "${cmd[0]}" == "help" ]]; then
      show_help
      continue
    elif [[ "${cmd[0]}" == "clear" ]]; then
      clear
      continue
    elif [[ "${cmd[0]}" == "quit" ]]; then
      break
    elif [[ -z "${cmd[0]}" ]]; then
      continue
    fi

    case "${cmd[0]}" in
      "show")
        case "${cmd[1]}" in
          "status") show_status;;
          "printer") show_printer "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "list")
        case "${cmd[1]}" in
          "printers") list_printers;;
          "jobs") list_jobs;;
          *) echo "Invalid or unknown command";;
        esac;;
      "add")
        case "${cmd[1]}" in
          "printer") add_printer "${cmd[2]}" "${cmd[3]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "remove")
        case "${cmd[1]}" in
          "printer") remove_printer "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "share")
        case "${cmd[1]}" in
          "printer") share_printer "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "unshare")
        case "${cmd[1]}" in
          "printer") unshare_printer "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "set")
        case "${cmd[1]}" in
          "quality") set_option "${cmd[2]}" "Quality" "${cmd[3]}";;
          "size") set_option "${cmd[2]}" "PageSize" "${cmd[3]}";;
          "paper") set_option "${cmd[2]}" "MediaType" "${cmd[3]}";;
          "toner") set_option "${cmd[2]}" "TonerSaveMode" "${cmd[3]}";;
          "onerror") set_option "${cmd[2]}" "printer-error-policy" "${cmd[3]}";;
          "default") set_default "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "cancel")
        case "${cmd[1]}" in
          "job") cancel_job "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "restart") restart;;
      *) echo "Invalid or unknown command";; 
    esac

    if [[ $? -eq 1 ]]; then
      echo "An unknown error has occurred"
    fi
  done

  clear
}

loop