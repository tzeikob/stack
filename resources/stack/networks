#!/bin/bash

set -o pipefail
source /opt/stack/utils

require "networkmanager"
require "wpa_supplicant"
require "wireless_tools"

# Returns the general status of the networking.
# Arguments:
#  None
# Outputs:
#  A json object of status.
find_status () {
  nmcli general | jc --nmcli | jq -cer '.[0]' || return 1
}

# Returns the list of network devices of the
# given type.
# Arguments:
#  type: ethernet, wifi or bridge
# Outputs:
#  A json array of device objects.
find_devices () {
  local type="${1}"

  local query='.'
  if [[ -n "${type}" ]]; then
    query="[.[]|select(.type == \"${type}\")]"
  fi

  nmcli device | jc --nmcli | jq -cer "${query}" || return 1
}

# Returns the device with the given name.
# Arguments:
#  name: the name of a device
# Outputs:
#  A josn object of a device.
find_device () {
  local name="${1}"

  nmcli device show "${name}" | jc --nmcli | jq -cer '.[0]' || return 1
}

# Returns the list of network connections.
# Arguments:
#  None
# Outputs:
#  A json array of connection objects.
find_connections () {
  nmcli connection | jc --nmcli || return 1
}

# Returns the connection with the given name.
# Arguments:
#  name: the name of a connection
# Outputs:
#  A json object of connection.
find_connection () {
  local name="${1}"

  nmcli connection show "${name}" | jc --nmcli | jq -cer '.[0]' || return 1
}

# Returns any detected wifi networks broadcasting in
# your local area having a singal strength equal to
# the given value.
# Arguments:
#  signal: a signal limitation value
# Outputs:
#  A json array list of wifi networks.
find_wifis () {
  local signal="${1:-"0"}"

  local networks=''
  networks="$(nmcli -f SSID,SIGNAL,CHAN,SECURITY -t device wifi list |
    awk -v limit="${signal}" -F: '{
      if ($2 >= limit) {
        schema="\"ssid\":\"%s\","
        schema=schema"\"signal\":%s,"
        schema=schema"\"channel\":\"%s\","
        schema=schema"\"security\":\"%s\""
        schema="{"schema"},"
        printf schema, $1,$2,$3,$4,$5
      }
    }'
  )" || return 1

  # Remove the last comma after the last element
  if [[ -n "${networks}" ]]; then
    networks="${networks::-1}"
  fi

  echo "[${networks}]"
}

# Validates if the network object with the given name
# exists and is a valid networking entity.
# Arguments:
#  object: device or connection
#  name:   the name of the object
# Returns:
#  0 if object is valid otherwise 1.
validate () {
  local object="${1}"
  local name="${2}"

  if [[ ! "${object}" =~ ^(device|connection)$ ]]; then
    return 1
  fi

  local result=''

  if [[ "${object}" == "device" ]]; then
    result="$(find_devices | jq -cer ".[]|select(.device == \"${name}\")")"
  elif [[ "${object}" == "connection" ]]; then
    result="$(find_connections | jq -cer ".[]|select(.name == \"${name}\")")"
  fi

  if [[ $? -ne 0 ]] || [[ -z "${result}" ]]; then
    return 1
  fi
}

# Shows a menu asking the user to select one device, where the
# answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  type: ethernet, wifi or bridge
# Outputs:
#  A menu of device names.
pick_device () {
  local type="${1}"

  local query='{key: .device, value: .device}'
  query="[.[]|${query}]"

  local devices=''
  devices="$(find_devices "${type}" | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${devices}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No devices have found"
    return 2
  fi

  pick_one "Select a device:" "${devices}" "vertical" || return 1
}

# Shows a menu asking the user to select one connection,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of connection names.
pick_connection () {
  local query='{key: .name, value: .name}'
  query="[.[]|${query}]"

  local connections=''
  connections="$(find_connections | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${connections}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No connections have found"
    return 2
  fi

  pick_one "Select a connection:" "${connections}" "vertical" || return 1
}

# Shows a prompt status and asks user to enter the
# next command, which is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A minimal prompt status line.
prompt () {
  local query=''
  query+='[.[]|select((.type == "wifi" or .type == "ethernet") and .state == "connected")]'
  query+=' |if .|length > 0 then .[0].device else "local" end'

  local status=''
  status="$(find_devices | jq -cer "${query}")"

  if [[ $? -ne 0 ]]; then
    status='none'
  fi

  read -rep "[networks:${status}] " REPLY
}

# Shows the current status of the system networking.
# Arguments:
#  None
# Outputs:
#  A long list of networking data.
show_status () {
  local devices=''
  devices="$(find_devices)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read network devices"
    return 2
  fi

  local query=''
  query+='\([$d[]|select((.type == "wifi" or .type == "ethernet") and .state == "connected")]'
  query+=' |if .|length == 0 then "local" else .[0]|.device end|'
  query+='"Network:     \(.)\n")'
  query+='State:       \(.state)\n'
  query+='Connection:  \(.connectivity)\n'
  query+='WiFi:        \(.wifi)\(if .wifi_hw then " [HW]" else "" end)\n'
  query+='WWAN:        \(.wwan)\(if .wwan_hw then " [HW]" else "" end)'
  query="\"${query}\""

  find_status | jq -cer --argjson d "${devices}" "${query}" || return 1

  query=''
  query+='.[]|select(.state == "connected")|.connection'

  local connections=''
  connections="$(echo "${devices}" | jq -cr "${query}")" || return 1

  if [[ -z "${connections}" ]]; then
    return 0
  fi

  query=''
  query+='Connection:  \(.connection_id)'
  query+='\(if .default == "yes" then " [default]" else "" end)\n'
  query+='\(."802_11_wireless_ssid"|if . then "SSID:        \(.)\n" else "" end)'
  query+='Device:      \(.connection_interface_name)\n'
  query+='State:       \(.state)\n'
  query+='Type:        \(.connection_type)\n'
  query+='\(."802_11_wireless_security_key_mgmt"|'
  query+=' if . then "Security:    \(.|ascii_upcase)\n" else "" end)'
  query+='Proxy:       \(.proxy_method)\n'
  query+='VPN:         \(.vpn)\n'
  query+='IPv4:        \(.ip4_address_1)\n'
  query+='IPv6:        \(.ip6_address_1)'
  query="\"${query}\""

  local connection=''
  while read -r connection; do
    echo
    find_connection "${connection}" | jq -cer "${query}" || return 1
  done <<< "${connections}"
}

# Shows the data of the network device with the given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of a device
# Outputs:
#  A long list of device data.
show_device () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_device || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "device" "${name}"; then
    echo "Invalid or unknown device"
    return 2
  fi

  local query=''
  query+='Name:        \(.device)\n'
  query+='Type:        \(.type)\n'
  query+='MAC:         \(.hwaddr)\n'
  query+='\(.state_text|if . then "State:       \(.)\n" else "" end)'
  query+='MTU:         \(.mtu)'
  query+='\(.ip4_address_1|if . then "\nIPv4:        \(.)" else "" end)'
  query+='\(.ip4_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip4_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query+='\(.ip4_dns_1|if . then "\nDNS:         \(.)" else "" end)'
  query+='\(.ip4_dns_2|if . then ", \(.)" else "" end)'
  query+='\(.ip6_address_1|if . then "\nIPv6:        \(.)" else "" end)'
  query+='\(.ip6_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip6_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query+='\(.connection|if . then "\nConnection:  \(.)" else "" end)'
  query="\"${query}\""

  find_device "${name}" | jq -cer "${query}" || return 1
}

# Shows the data of the network connection with the
# given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of a connection
# Outputs:
#  A long list of connection data.
show_connection () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_connection || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "connection" "${name}"; then
    echo "Invalid or unknown connection"
    return 2
  fi

  local query=''
  query+='Connection:  \(.connection_id)'
  query+='\(if .default == "yes" then " [default]" else "" end)\n'
  query+='\(."802_11_wireless_ssid"|if . then "SSID:        \(.)\n" else "" end)'
  query+='\(.connection_uuid|if . then "UUID:        \(.)\n" else "" end)'
  query+='Device:      \(.connection_interface_name)\n'
  query+='\(.state|if . then "State:       \(.)\n" else "" end)'
  query+='Auto:        \(.connection_autoconnect)\n'
  query+='Type:        \(.connection_type)\n'
  query+='\(."802_11_wireless_security_key_mgmt"|'
  query+=' if . then "Security:    \(.|ascii_upcase)\n" else "" end)'
  query+='Proxy:       \(.proxy_method)'
  query+='\(.vpn|if . then "\nVPN:         \(.)" else "" end)'
  query+='\(.ip4_address_1|if . then "\nIPv4:        \(.)" else "" end)'
  query+='\(.ip4_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip4_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query+='\(.ip4_dns_1|if . then "\nDNS:         \(.)" else "" end)'
  query+='\(.ip4_dns_2|if . then ", \(.)" else "" end)'
  query+='\(.ip6_address_1|if . then "\nIPv6:        \(.)" else "" end)'
  query+='\(.ip6_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip6_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query="\"${query}\""

  find_connection "${name}" | jq -cer "${query}" || return 1
}

# Shows the list of networking devices.
# Arguments:
#  None
# Outputs:
#  A list of network devices.
list_devices () {
  local devices=''
  devices="$(find_devices)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read network devices"
    return 2
  fi

  local len=0
  len="$(count "${devices}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No network devices have found"
    return 0
  fi

  local query=''
  query+='Name:        \(.device)\n'
  query+='Type:        \(.type)\n'
  query+='State:       \(.state|if . then . else "none" end)\n'
  query+='Connection:  \(.connection|if . then . else "none" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${devices}" | jq -cer "${query}" || return 1
}

# Shows the list of networking connections.
# Arguments:
#  None
# Outputs:
#  A list of network connections.
list_connections () {
  local connections=''
  connections="$(find_connections)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read network connections"
    return 2
  fi

  local len=0
  len="$(count "${connections}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No network connections have found"
    return 0
  fi

  local query=''
  query+='Name:    \(.name)\n'
  query+='Type:    \(.type)\n'
  query+='Device:  \(.device|if . then . else "none" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${connections}" | jq -cer "${query}" || return 1
}

# Detects the available wifi networks in the local area
# with signal strength at least the given limit.
# Arguments:
#  limit: a signal limitation value
# Outputs:
#  The list of wifi networks.
scan () {
  local signal="${1:-"0"}"

  if [[ ! "${signal}" =~ ^[0-9][0-9]{,2}$ ]]; then
    echo "Invalid signal limit value"
    return 2
  elif (( ${signal} < 0 || ${signal} > 100 )); then
    echo "Signal limit value out of range"
    return 2
  fi

  echo "Detecting available wifi networks..."

  local networks=''
  networks="$(find_wifis "${signal}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to detect wifi networks"
    return 2
  fi

  local len=0
  len="$(count "${networks}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No wifi networks have been detected"
    return 0
  fi

  local query=''
  query+='Name:      \(.ssid)\n'
  query+='Signal:    \(.signal) [\(.channel)]\n'
  query+='Security:  \(.security|'
  query+='if . and . != "" then .|ascii_upcase else "none" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${networks}" | jq -cer "${query}" || return 1
}

# Connect to the wifi network with the given id
# and secret key.
# Globals:
#  REPLY
# Arguments:
#  ssid: the ssid of the wifi network
connect () {
  local ssid="${1}"

  if [[ -z "${ssid}" ]]; then
    echo "Detecting available wifi networks..."

    local networks=''
    networks="$(find_wifis)" || return 1

    local len=0
    len="$(count "${networks}")" || return 1

    if [[ ${len} -eq 0 ]]; then
      echo "No wifi networks have been detected"
      return 0
    fi

    local query='{key: .ssid, value: "[\(.signal)] \(.ssid)"}'
    query="[.[]|${query}]"

    networks="$(echo "${networks}" | jq -cer "${query}")" || return 1
    pick_one "Select a wifi network:" "${networks}" "vertical" || return $?
    [[ -n "${REPLY}" ]] && ssid="${REPLY}" || return 0
  fi

  ask_password "Enter the private key:"
  local key="${REPLY}"

  echo "Connecting to ${ssid}..."

  nmcli device wifi connect "${ssid}" password "${key}" hidden yes
  
  if [[ $? -ne 0 ]]; then
    echo "Failed to connect to ${ssid}"
    return 2
  fi

  sleep 3
  echo "Connection to ${ssid} has been established"
}

# Enables the device or connection with the given name.
# Globals:
#  REPLY
# Arguments:
#  object: device or connection
#  name:   the name of a device or connection
up () {
  local object="${1}"
  local name="${2}"

  if [[ -z "${name}" ]]; then
    if [[ "${object}" == "device" ]]; then
      pick_device || return $?
    elif [[ "${object}" == "connection" ]]; then
      pick_connection || return $?
    else
      echo "Invalid or unknown network object"
      return 2
    fi

    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "${object}" "${name}"; then
    echo "Invalid or unknown network object"
    return 2
  fi

  echo "Enabling ${object} ${name}..."

  if [[ "${object}" == "device" ]]; then
    nmcli device connect "${name}" &>/dev/null
  elif [[ "${object}" == "connection" ]]; then
    nmcli connection up "${name}" &>/dev/null
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to enable ${object}"
    return 2
  fi

  sleep 3
  echo "${object^} ${name} has been enabled"
}

# Disables the device or connection with the given name.
# Globals:
#  REPLY
# Arguments:
#  object: device or connection
#  name:   the name of a device or connection
down () {
  local object="${1}"
  local name="${2}"

  if [[ -z "${name}" ]]; then
    if [[ "${object}" == "device" ]]; then
      pick_device || return $?
    elif [[ "${object}" == "connection" ]]; then
      pick_connection || return $?
    else
      echo "Invalid or unknown network object"
      return 2
    fi

    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "${object}" "${name}"; then
    echo "Invalid or unknown network object"
    return 2
  fi

  echo "Disabling ${object} ${name}..."

  if [[ "${object}" == "device" ]]; then
    nmcli device disconnect "${name}" &>/dev/null
  elif [[ "${object}" == "connection" ]]; then
    nmcli connection down "${name}" &>/dev/null
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to disable ${object}"
    return 2
  fi

  sleep 3
  echo "${object^} ${name} has been disabled"
}

# Removes the device or connection with the given name.
# Globals:
#  REPLY
# Arguments:
#  object: device or connection
#  name:   the name of a device or connection
remove () {
  local object="${1}"
  local name="${2}"

  if [[ -z "${name}" ]]; then
    if [[ "${object}" == "device" ]]; then
      pick_device || return $?
    elif [[ "${object}" == "connection" ]]; then
      pick_connection || return $?
    else
      echo "Invalid or unknown network object"
      return 2
    fi

    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "${object}" "${name}"; then
    echo "Invalid or unknown network object"
    return 2
  fi

  echo "Removing ${object} ${name}..."

  if [[ "${object}" == "device" ]]; then
    nmcli device delete "${name}" &>/dev/null
  elif [[ "${object}" == "connection" ]]; then
    nmcli connection delete "${name}" &>/dev/null
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to remove ${object}"
    return 2
  fi

  sleep 3
  echo "${object^} ${name} has been removed"
}

# Adds a new ethernet connection with the given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of the connection
add () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    echo "Connection name is missing"
    return 2
  fi

  if find_connection "${name}" &>/dev/null; then
    echo "Connection ${name} already exists"
    return 2
  fi

  local device=''
  pick_device "ethernet" || return $?
  [[ -n "${REPLY}" ]] && device="${REPLY}" || return 0

  local dhcp=''
  confirm "Want to enable DHCP mode?" || return $?
  [[ -n "${REPLY}" ]] && dhcp="${REPLY}" || return 0

  echo "Creating connection ${name}..."

  if [[ "${dhcp}" == "yes" ]]; then
    nmcli connection add type "ethernet" \
      con-name "${name}" ifname "${device}" ipv4.method "auto"
  else
    local re='^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$'

    ask "Enter the static ip:" "${re}" || return $?
    local ip="${REPLY}"

    ask "Enter the gateway:" "${re}" || return $?
    local gateway="${REPLY}"

    ask "Enter the primary DNS:" "${re}" || return $?
    local dns="${REPLY}"

    ask "Enter the secondary DNS:" "${re}" || return $?
    dns="${dns} ${REPLY}"

    nmcli connection add type "ethernet" \
      con-name "${name}" ifname "${device}" ipv4.method "manual" \
      ipv4.addresses "${ip}/24" ipv4.gateway "${gateway}" ipv4.dns "${dns}"
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to create connection"
    return 2
  fi

  sleep 3
  echo "Connection ${name} has been created"
}

# Sets the system networking to on or off.
# Arguments:
#  mode: on or off
power_network () {
  local mode="${1}"

  if [[ -z "${mode}" ]]; then
    echo "Missing mode value"
    return 2
  elif [[ ! "${mode}" =~ ^(on|off)$ ]]; then
    echo "Invalid mode value"
    return 2
  fi

  echo "Powering network ${mode}..."

  nmcli networking "${mode}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to power network ${mode}"
    return 2
  fi

  sleep 3
  echo "Network power set to ${mode}"
}

# Sets the wifi to on or off.
# Arguments:
#  mode: on or off
power_wifi () {
  local mode="${1}"

  if [[ -z "${mode}" ]]; then
    echo "Missing mode value"
    return 2
  elif [[ ! "${mode}" =~ ^(on|off)$ ]]; then
    echo "Invalid mode value"
    return 2
  fi

  echo "Powering wifi ${mode}..."

  nmcli radio wifi "${mode}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to power wifi ${mode}"
    return 2
  fi

  sleep 3
  echo "Wifi power set to ${mode}"
}

# Shows the help message.
# Arguments:
#  None
# Outputs:
#  A long help message.
show_help () {
  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf " %-35s %s\n" \
    "help" "Show this help message." \
    "" "" \
    "show status" "Show the current status of networking." \
    "show device [<name>]" "Show the data of a device." \
    "show connection [<name>]" "Show the data of a connection." \
    "" "" \
    "list devices" "List the network devices." \
    "list connections" "List the network connections." \
    "" "" \
    "scan [<signal>]" "Detect wifi networks with min signal." \
    "connect [<ssid>]" "Connect to a wifi network." \
    "" "" \
    "up device [<name>]" "Enable a network device." \
    "down device [<name>]" "Disable a network device." \
    "remove device [<name>]" "Remove a software network device." \
    "" "" \
    "up connection [<name>]" "Enable a connection." \
    "down connection [<name>]" "Disable a connection." \
    "add connection <name>" "Add a new connection." \
    "remove connection [<name>]" "Remove a connection." \
    "" "" \
    "power network on|off" "Set the system network to on or off." \
    "power wifi on|off" "Set the wifi device to on or off."
}

loop () {
  clear

  while true; do
    prompt && history -s "${REPLY}"

    set -f
    set_separator "line"
    local cmd=($(xargs -n1 <<< "${REPLY}"))
    restore_separator && set +f

    if [[ "${cmd[0]}" == "help" ]]; then
      show_help
      continue
    elif [[ "${cmd[0]}" == "clear" ]]; then
      clear
      continue
    elif [[ "${cmd[0]}" == "quit" ]]; then
      break
    elif [[ -z "${cmd[0]}" ]]; then
      continue
    fi

    case "${cmd[0]}" in
      "show")
        case "${cmd[1]}" in
          "status") show_status;;
          "device") show_device "${cmd[2]}";;
          "connection") show_connection "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "list")
        case "${cmd[1]}" in
          "devices") list_devices;;
          "connections") list_connections;;
          *) echo "Invalid or unknown command";;
        esac;;
      "scan") scan "${cmd[1]}";;
      "power")
        case "${cmd[1]}" in
          "network") power_network "${cmd[2]}";;
          "wifi") power_wifi "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "connect") connect "${cmd[1]}";; 
      "up") up "${cmd[1]}" "${cmd[2]}";;
      "down") down "${cmd[1]}" "${cmd[2]}";;
      "add")
        case "${cmd[1]}" in
          "connection") add "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "remove") remove "${cmd[1]}" "${cmd[2]}";;
      *) echo "Invalid or unknown command";; 
    esac

    if [[ $? -eq 1 ]]; then
      echo "An unknown error has occurred"
    fi
  done

  clear
}

loop