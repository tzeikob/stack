#!/bin/bash

set -o pipefail
source /opt/stack/utils

SETTINGS_FILE="${CONFIG_HOME}/networks.json"
SHELLRC_FILE="${HOME}/.bashrc"
PROXY_ENV_FILE="${HOME}/.config/environment.d/proxy.conf"
DOCKER_PROXY_FILE='/etc/systemd/system/docker.service.d/http-proxy.conf'

# Returns the general status of the networking.
# Arguments:
#  None
# Outputs:
#  A json object of status.
find_status () {
  nmcli general | jc --nmcli | jq -cer '.[0]' || return 1
}

# Returns the list of network devices of the
# given type.
# Arguments:
#  type: ethernet, wifi or bridge
# Outputs:
#  A json array of device objects.
find_devices () {
  local type="${1}"

  local query='.'
  if [[ -n "${type}" ]]; then
    query="[.[]|select(.type == \"${type}\")]"
  fi

  nmcli device | jc --nmcli | jq -cer "${query}" || return 1
}

# Returns the device with the given name.
# Arguments:
#  name: the name of a device
# Outputs:
#  A josn object of a device.
find_device () {
  local name="${1}"

  local device=''
  device="$(nmcli device show "${name}" | jc --nmcli | jq -cer '.[0]')" || return 1

  local type=''
  type="$(get "${device}" ".type")" || return 1

  if [[ "${type}" == "wifi" ]]; then
    local query=''
    query+='freq: .frequency,'
    query+='rate: .bit_rate,'
    query+='quality: .link_quality,'
    query+='signal: .signal_level'
    query="if (.|length>0 and .[0].frequency) then .[0]|{${query}} else {} end"

    device="$(iwconfig "${name}" 2> /dev/null | jc --iwconfig |
      jq -cer --argjson d "${device}" "${query} + \$d")" || return 1
  fi

  echo "${device}"
}

# Returns the list of network connections.
# Arguments:
#  None
# Outputs:
#  A json array of connection objects.
find_connections () {
  nmcli connection | jc --nmcli || return 1
}

# Returns the connection with the given name.
# Arguments:
#  name: the name of a connection
# Outputs:
#  A json object of connection.
find_connection () {
  local name="${1}"

  local connection=''
  connection="$(nmcli connection show "${name}" | jc --nmcli | jq -cer '.[0]')" || return 1

  local type=''
  type="$(get "${connection}" ".connection_type")" || return 1

  if [[ "${type}" =~ "wireless" ]]; then
    local device=''
    device="$(get "${connection}" ".connection_interface_name")" || return 1

    local query=''
    query+='freq: .frequency,'
    query+='rate: .bit_rate,'
    query+='quality: .link_quality,'
    query+='signal: .signal_level'
    query="if (.|length>0 and .[0].frequency) then .[0]|{${query}} else {} end"

    if validate "device" "${device}" ; then
      connection="$(iwconfig "${device}" 2> /dev/null | jc --iwconfig |
        jq -cer --argjson c "${connection}" "${query} + \$c")" || return 1
    fi
  fi
  
  echo "${connection}"
}

# Returns any detected wifi networks broadcasting in
# your local area having a singal strength equal or
# greater to the given value.
# Arguments:
#  device: the name of a wifi device
#  signal: a signal limitation value
# Outputs:
#  A json array list of wifi networks.
find_wifis () {
  local device="${1}"
  local signal="${2:-"0"}"

  local networks=''
  networks="$(nmcli -f SSID,SIGNAL,CHAN,SECURITY -t device wifi list ifname "${device}" |
    awk -v limit="${signal}" -F: '{
      if ($2 >= limit) {
        schema="\"ssid\":\"%s\","
        schema=schema"\"signal\":%s,"
        schema=schema"\"channel\":\"%s\","
        schema=schema"\"security\":\"%s\""
        schema="{"schema"},"
        printf schema, $1,$2,$3,$4,$5
      }
    }'
  )" || return 1

  # Remove the last comma after the last element
  if [[ -n "${networks}" ]]; then
    networks="${networks::-1}"
  fi

  echo "[${networks}]"
}

# Validates if the network object with the given name
# exists and is a valid networking entity.
# Arguments:
#  object: device or connection
#  name:   the name of the object
# Returns:
#  0 if object is valid otherwise 1.
validate () {
  local object="${1}"
  local name="${2}"

  if [[ ! "${object}" =~ ^(device|connection)$ ]]; then
    return 1
  fi

  local result=''

  if [[ "${object}" == "device" ]]; then
    result="$(find_devices | jq -cer ".[]|select(.device == \"${name}\")")"
  elif [[ "${object}" == "connection" ]]; then
    result="$(find_connections | jq -cer ".[]|select(.name == \"${name}\")")"
  fi

  if [[ $? -ne 0 ]] || [[ -z "${result}" ]]; then
    return 1
  fi
}

# Shows a menu asking the user to select one device, where the
# answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  type: ethernet, wifi or bridge
# Outputs:
#  A menu of device names.
pick_device () {
  local type="${1}"

  local query='{key: .device, value: .device}'
  query="[.[]|${query}]"

  local devices=''
  devices="$(find_devices "${type}" | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${devices}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No devices have found"
    return 2
  fi

  pick_one "Select a device:" "${devices}" "vertical" || return $?
}

# Shows a menu asking the user to select one connection,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of connection names.
pick_connection () {
  local query='{key: .name, value: .name}'
  query="[.[]|${query}]"

  local connections=''
  connections="$(find_connections | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${connections}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No connections have found"
    return 2
  fi

  pick_one "Select a connection:" "${connections}" "vertical" || return $?
}

# Shows a menu asking the user to select one proxy profile,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of proxy profiles.
pick_proxy () {
  local query=''
  query+='{key: .name, value: "\(.name) [\(.host)]"}'
  query=".proxies|if .|length>0 then [.[]|${query}] else [] end"

  local proxies=''
  proxies="$(jq -cer "${query}" "${SETTINGS_FILE}")" || return 1
  
  local len=0
  len="$(count "${proxies}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No proxy profiles have found"
    return 2
  fi

  pick_one "Select a proxy profile:" "${proxies}" "vertical" || return $?
}

# Shows a prompt status and asks user to enter the
# next command, which is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A minimal prompt status line.
prompt () {
  local query=''
  query+='[.[]|select((.type == "wifi" or .type == "ethernet") and .state == "connected")]'
  query+=' |if .|length > 0 then .[0].device else "local" end'

  local status=''
  status="$(find_devices | jq -cer "${query}")"

  if [[ $? -ne 0 ]]; then
    status='none'
  fi

  read -rep "[networks:${status}] " REPLY
}

# Shows the current status of the system networking.
# Arguments:
#  None
# Outputs:
#  A long list of networking data.
show_status () {
  systemctl status --lines 0 --no-pager NetworkManager.service |
    awk '{
      if ($0 ~ / *Active/) {
        l = "Service"
        v = $2" "$3
      } else l = ""

      if (l) printf "%-12s %s\n",l":",v
    }' || return 1

  local devices=''
  devices="$(find_devices)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read network devices"
    return 2
  fi

  local query=''
  query+='\([$d[]|select((.type == "wifi" or .type == "ethernet") and .state == "connected")]'
  query+=' |if .|length == 0 then "local" else .[0]|.device end|'
  query+='"Network:     \(.)\n")'
  query+='State:       \(.state) [\(.connectivity)]\n'
  query+='WiFi:        \(.wifi)\(if .wifi_hw then " [HW]" else "" end)'
  query="\"${query}\""

  find_status | jq -cer --argjson d "${devices}" "${query}" || return 1

  local query=''
  query+='ISP:         \(.as|split(" ")|"\(.[1]) \(.[2])") [\(.isp)]\n'
  query+='Public IP:   \(.query)\n'
  query+='Country:     \(.city|if . then "\(.), " else "" end)\(.country)'

  curl -s 'http://ip-api.com/json' | jq -cer "\"${query}\""

  if [[ $? -ne 0 ]]; then
    echo "ISP:         Unavailable"
  fi

  local proxy=''
  if [[ -f "${PROXY_ENV_FILE}" ]]; then
    proxy="$(cat "${PROXY_ENV_FILE}" | awk -F'=' '/export http_proxy=/ {
      split($2,a,"http://")
      if (a[2] ~ /@/) {
        split(a[2],b,"@")
        print b[2]
      } else print a[2]
    }' | tr -d '"/')" || return 1
  fi

  if [[ -n "${proxy}" ]]; then
    echo "Proxy:       ${proxy}"
  fi

  query=''
  query+='.[]|select(.type|test("(^ethernet|wifi|vpn)$"))|.name'

  local connections=''
  connections="$(nmcli connection show --active | jc --nmcli | jq -cr "${query}")" || return 1

  if [[ -z "${connections}" ]]; then
    return 0
  fi

  query=''
  query+='Connection:  \(.connection_id)\(if .default == "yes" then " [default]" else "" end)'
  query+='\(."802_11_wireless_ssid"|if . then "\nSSID:        \(.)" else "" end)'
  query+='\nDevice:      \(if .connection_type == "vpn" then .ip_iface else .connection_interface_name end)'
  query+='\(if .freq then "\nFreq:        \(.freq)GHz [\(.rate)Mb/s]" else "" end)'
  query+='\(if .quality then "\nSignal:      \(.quality) [\(.signal)dBm]" else "" end)'
  query+='\nType:        \(.connection_type)\(.vpn_type|if . then " [\(.)]" else "" end)'
  query+='\(if .connection_type == "vpn" then "\nHost:        \(.vpn_gateway)" else "" end)'
  query+='\(if .vpn_username then "\nUser:        \(.vpn_username)" else "" end)'
  query+='\(."802_11_wireless_security_key_mgmt"|if . then "\nSecurity:    \(.|ascii_upcase)" else "" end)'
  query+='\(if .ip4_address_1 then "\nIPv4:        \(.ip4_address_1)" else "" end)'
  query="\"${query}\""

  local connection=''
  while read -r connection; do
    echo
    find_connection "${connection}" | jq -cer "${query}" || return 1
  done <<< "${connections}"
}

# Shows the data of the network device with the given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of a device
# Outputs:
#  A long list of device data.
show_device () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_device || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "device" "${name}"; then
    echo "Invalid or unknown device"
    return 2
  fi

  local query=''
  query+='Name:        \(.device)\n'
  query+='Type:        \(.type)\n'
  query+='MAC:         \(.hwaddr)\n'
  query+='\(if .freq then "Freq:        \(.freq)GHz [\(.rate)Mb/s]\n" else "" end)'
  query+='\(if .quality then "Signal:      \(.quality) [\(.signal)dBm]\n" else "" end)'
  query+='\(.state_text|if . then "State:       \(.)\n" else "" end)'
  query+='MTU:         \(.mtu)'
  query+='\(.ip4_address_1|if . then "\nIPv4:        \(.)" else "" end)'
  query+='\(.ip4_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip4_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query+='\(.ip4_dns_1|if . then "\nDNS:         \(.)" else "" end)'
  query+='\(.ip4_dns_2|if . then ", \(.)" else "" end)'
  query+='\(.ip6_address_1|if . then "\nIPv6:        \(.)" else "" end)'
  query+='\(.ip6_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip6_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query+='\(.connection|if . then "\nConnection:  \(.)" else "" end)'
  query="\"${query}\""

  find_device "${name}" | jq -cer "${query}" || return 1
}

# Shows the data of the network connection with the
# given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of a connection
# Outputs:
#  A long list of connection data.
show_connection () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_connection || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "connection" "${name}"; then
    echo "Invalid or unknown connection"
    return 2
  fi

  local query=''
  query+='Connection:  \(.connection_id)\(if .default == "yes" then " [default]" else "" end)'
  query+='\(."802_11_wireless_ssid"|if . then "\nSSID:        \(.)" else "" end)'
  query+='\(.connection_uuid|if . then "\nUUID:        \(.)" else "" end)'
  query+='\nDevice:      \(if .connection_type == "vpn"'
  query+=' then "\(.ip_iface|if . then . else "none" end)" else .connection_interface_name end)'
  query+='\(if .freq then "\nFreq:        \(.freq)GHz [\(.rate)Mb/s]" else "" end)'
  query+='\(if .quality then "\nSignal:      \(.quality) [\(.signal)dBm]" else "" end)'
  query+='\(.state|if . then "\nState:       \(.)" else "" end)'
  query+='\nAuto:        \(.connection_autoconnect)'
  query+='\nType:        \(.connection_type)\(.vpn_type|if . then " [\(.)]" else "" end)'
  query+='\(if .connection_type == "vpn" and .vpn_gateway then "\nHost:        \(.vpn_gateway)" else "" end)'
  query+='\(if .vpn_username then "\nUser:        \(.vpn_username)" else "" end)'
  query+='\(."802_11_wireless_security_key_mgmt"|if . then "\nSecurity:    \(.|ascii_upcase)" else "" end)'
  query+='\(.ip4_address_1|if . then "\nIPv4:        \(.)" else "" end)'
  query+='\(.ip4_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip4_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query+='\(.ip4_dns_1|if . then "\nDNS:         \(.)" else "" end)'
  query+='\(.ip4_dns_2|if . then ", \(.)" else "" end)'
  query+='\(.ip6_address_1|if . then "\nIPv6:        \(.)" else "" end)'
  query+='\(.ip6_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip6_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query="\"${query}\""

  find_connection "${name}" | jq -cer "${query}" || return 1
}

# Shows the list of networking devices.
# Arguments:
#  None
# Outputs:
#  A list of network devices.
list_devices () {
  local devices=''
  devices="$(find_devices)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read network devices"
    return 2
  fi

  local len=0
  len="$(count "${devices}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No network devices have found"
    return 0
  fi

  local query=''
  query+='Name:        \(.device)\n'
  query+='Type:        \(.type)\n'
  query+='State:       \(.state|if . then . else "none" end)\n'
  query+='Connection:  \(.connection|if . then . else "none" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${devices}" | jq -cer "${query}" || return 1
}

# Shows the list of networking connections.
# Arguments:
#  None
# Outputs:
#  A list of network connections.
list_connections () {
  local connections=''
  connections="$(find_connections)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read network connections"
    return 2
  fi

  local len=0
  len="$(count "${connections}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No network connections have found"
    return 0
  fi

  local query=''
  query+='Name:    \(.name)\n'
  query+='Type:    \(.type)\n'
  query+='Device:  \(.device|if . then . else "none" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${connections}" | jq -cer "${query}" || return 1
}

# Detects the available wifi networks in the local area
# with signal strength at least the given limit.
# Arguments:
#  device: the name of a wifi device
#  singal: a signal limitation value
# Outputs:
#  The list of wifi networks.
list_wifis () {
  local device="${1}"
  local signal="${2:-"0"}"

  if [[ -z "${device}" ]]; then
    pick_device "wifi" || return $?
    [[ -n "${REPLY}" ]] && device="${REPLY}" || return 0
  fi

  if ! validate "device" "${device}"; then
    echo "Invalid or unknown device"
    return 2
  fi

  if [[ ! "${signal}" =~ ^[0-9][0-9]{,2}$ ]]; then
    echo "Invalid signal limit value"
    return 2
  elif (( ${signal} < 0 || ${signal} > 100 )); then
    echo "Signal limit value out of range"
    return 2
  fi

  echo "Detecting available wifi networks..."

  local networks=''
  networks="$(find_wifis "${device}" "${signal}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to detect wifi networks"
    return 2
  fi

  local len=0
  len="$(count "${networks}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No wifi networks have been detected"
    return 0
  fi

  local query=''
  query+='Name:      \(.ssid)\n'
  query+='Signal:    \(.signal) [\(.channel)]\n'
  query+='Security:  \(.security|'
  query+='if . and . != "" then .|ascii_upcase else "none" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${networks}" | jq -cer "${query}" || return 1
}

# Enables the device or connection with the given name.
# Globals:
#  REPLY
# Arguments:
#  object: device or connection
#  name:   the name of a device or connection
up () {
  local object="${1}"
  local name="${2}"

  if [[ -z "${name}" ]]; then
    if [[ "${object}" == "device" ]]; then
      pick_device || return $?
    elif [[ "${object}" == "connection" ]]; then
      pick_connection || return $?
    else
      echo "Invalid or unknown network object"
      return 2
    fi

    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "${object}" "${name}"; then
    echo "Invalid or unknown network object"
    return 2
  fi

  echo "Enabling ${object} ${name}..."

  if [[ "${object}" == "device" ]]; then
    nmcli device connect "${name}" &> /dev/null
  elif [[ "${object}" == "connection" ]]; then
    nmcli connection up "${name}" --ask
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to enable ${object}"
    return 2
  fi

  sleep 3
  echo "${object^} ${name} has been enabled"
}

# Disables the device or connection with the given name.
# Globals:
#  REPLY
# Arguments:
#  object: device or connection
#  name:   the name of a device or connection
down () {
  local object="${1}"
  local name="${2}"

  if [[ -z "${name}" ]]; then
    if [[ "${object}" == "device" ]]; then
      pick_device || return $?
    elif [[ "${object}" == "connection" ]]; then
      pick_connection || return $?
    else
      echo "Invalid or unknown network object"
      return 2
    fi

    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "${object}" "${name}"; then
    echo "Invalid or unknown network object"
    return 2
  fi

  echo "Disabling ${object} ${name}..."

  if [[ "${object}" == "device" ]]; then
    nmcli device disconnect "${name}" &> /dev/null
  elif [[ "${object}" == "connection" ]]; then
    nmcli connection down "${name}" &> /dev/null
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to disable ${object}"
    return 2
  fi

  sleep 3
  echo "${object^} ${name} has been disabled"
}

# Removes the software device with the given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of a device
remove_device () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_device || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "device" "${name}"; then
    echo "Invalid or unknown device"
    return 2
  fi

  echo "Removing device ${name}..."

  nmcli device delete "${name}" &> /dev/null

  if [[ $? -ne 0 ]]; then
    echo "Failed to remove device"
    return 2
  fi

  sleep 3
  echo "Device ${name} has been removed"
}

# Removes the connection with the given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of a connection
remove_connection () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_connection || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "connection" "${name}"; then
    echo "Invalid or unknown connection"
    return 2
  fi

  echo "Removing connection ${name}..."

  nmcli connection delete "${name}" &> /dev/null

  if [[ $? -ne 0 ]]; then
    echo "Failed to remove connection"
    return 2
  fi

  sleep 3
  echo "Connection ${name} has been removed"
}

# Adds a new ethernet connection.
# Globals:
#  REPLY
# Arguments:
#  None
add_ethernet_connection () {
  ask "Enter the connection name:" ".+" || return $?
  local name="${REPLY}"

  if find_connection "${name}" &> /dev/null; then
    echo "Connection ${name} already exists"
    return 2
  fi

  local device=''
  pick_device "ethernet" || return $?
  [[ -n "${REPLY}" ]] && device="${REPLY}" || return 0

  local dhcp=''
  confirm "Want to enable DHCP mode?" || return $?
  [[ -n "${REPLY}" ]] && dhcp="${REPLY}" || return 0

  echo "Creating ethernet connection ${name}..."

  if [[ "${dhcp}" == "yes" ]]; then
    nmcli connection add type "ethernet" \
      con-name "${name}" ifname "${device}" ipv4.method "auto"
  else
    local re='^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$'

    ask "Enter the static ip:" "${re}" || return $?
    local ip="${REPLY}"

    ask "Enter the gateway:" "${re}" || return $?
    local gateway="${REPLY}"

    ask "Enter the primary DNS:" "${re}" || return $?
    local dns="${REPLY}"

    ask "Enter the secondary DNS:" "${re}" || return $?
    dns="${dns} ${REPLY}"

    nmcli connection add type "ethernet" \
      con-name "${name}" ifname "${device}" ipv4.method "manual" \
      ipv4.addresses "${ip}/24" ipv4.gateway "${gateway}" ipv4.dns "${dns}"
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to create ethernet connection"
    return 2
  fi

  sleep 3
  echo "Ethernet connection ${name} has been created"
}

# Adds a wifi connection to wireless network.
# Globals:
#  REPLY
# Arguments:
#  None
add_wifi_connection () {
  local device=''
  pick_device "wifi" || return $?
  [[ -n "${REPLY}" ]] && device="${REPLY}" || return 0

  echo "Detecting available wifi networks..."

  local networks=''
  networks="$(find_wifis "${device}")" || return 1

  local len=0
  len="$(count "${networks}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No wifi networks have been detected"
    return 0
  fi

  local query='{key: .ssid, value: "[\(.signal)] \(.ssid)"}'
  query="[.[]|${query}]"

  networks="$(echo "${networks}" | jq -cer "${query}")" || return 1

  local ssid=''
  pick_one "Select a wifi network:" "${networks}" "vertical" || return $?
  [[ -n "${REPLY}" ]] && ssid="${REPLY}" || return 0

  ask_secret "Enter the private key:" || return $?
  local key="${REPLY}"

  echo "Connecting to network ${ssid}..."

  local result=''
  result="$(nmcli device wifi connect "${ssid}" password "${key}" \
    ifname "${device}" hidden yes 2> /dev/null)"
  
  if [[ $? -ne 0 ]] || [[ "${result}" =~ (E|e)rror ]]; then
    echo "Failed to connect to ${ssid}"
    return 2
  fi

  sleep 3
  echo "Connection to ${ssid} has been established"
}

# Adds a new vpn connection.
# Globals:
#  REPLY
# Arguments:
#  None
add_vpn_connection () {
  ask "Enter the path to ovpn file:" "^/.+" || return $?
  local file_path="${REPLY}"

  if [[ ! -f "${file_path}" ]]; then
    echo "Invalid or unknown ${file_path} file"
    return 2
  fi

  local name=$(basename -- "${file_path}")
  local extension="${name##*.}"
  name="${name%.*}"

  if [[ "${extension}" != "ovpn" ]]; then
    echo "Invalid ovpn file type"
    return 2
  fi

  ask "Enter the username:" ".+" || return $?
  local username="${REPLY}"

  ask_secret "Enter the password:" ".+" || return $?
  local password="${REPLY}"

  echo "Creating VPN connection ${name}..."

  nmcli connection import type openvpn file "${file_path}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to create VPN connection"
    return 2
  fi

  nmcli connection modify "${name}" +vpn.data username="${username}" || return 1
  nmcli connection modify "${name}" +vpn.secrets password="${password}" || return 1

  sleep 3
  echo "VPN connection ${name} has been created"
}

# Adds a new proxy profile with the given host,
# port and authentication info.
# Globals:
#  REPLY, SETTINGS_FILE, CONFIG_HOME
# Arguments:
#  name: the name of the proxy profile
add_proxy () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    echo "Missing the proxy profile name"
    return 2
  fi

  if [[ -f "${SETTINGS_FILE}" ]]; then
    local query=''
    query+=".proxies|if . then .[]|select(.name == \"${name}\") else empty end"
  
    local exists=''
    exists="$(jq -cr "${query}" "${SETTINGS_FILE}")" || return 1

    if [[ -n "${exists}" ]]; then
      echo "Proxy profile ${name} already exists"
      return 2
    fi
  fi

  ask "Enter the host:" ".+" || return $?
  local host="${REPLY}"

  ask "Enter the port:" "^[0-9]+$" || return $?
  local port="${REPLY}"

  confirm "Is this an authenticated proxy?" || return $?
  [[ -z "${REPLY}" ]] && return 0

  if [[ "${REPLY}" == "yes" ]]; then
    ask "Enter the username:" ".+" || return $?
    local username="${REPLY}"

    ask_secret "Enter the password:" ".+" || return $?
    local password="${REPLY}"
  fi

  local no_proxy='[]'
  confirm "Want to set no proxy hosts?" || return $?
  [[ -z "${REPLY}" ]] && return 0

  if [[ "${REPLY}" == "yes" ]]; then
    ask "Enter no proxy hosts:" ".*" || return $?

    local query='[split(" ")|.[]|if . and .!="" then . else empty end]'
    no_proxy="$(echo "\"${REPLY}\"" | jq -cer "${query}")" || return 1
  fi

  local proxy=''
  proxy+="\"name\": \"${name}\","
  proxy+="\"host\": \"${host}\","
  proxy+="\"port\": \"${port}\","
  proxy+="\"no_proxy\": ${no_proxy}"

  if [[ -n "${username}" ]]; then
    proxy+=",\"username\": \"${username}\""
    proxy+=",\"password\": \"${password}\""
  fi

  proxy="{${proxy}}"

  local settings='{}'
  if [[ -f "${SETTINGS_FILE}" ]]; then
    settings="$(jq -e ".proxies += [${proxy}]" "${SETTINGS_FILE}")" || return 1
  else
    settings="$(echo "{\"proxies\": [${proxy}]}" | jq -e '.')" || return 1
  fi

  mkdir -p "${CONFIG_HOME}"
  echo "${settings}" > "${SETTINGS_FILE}"
  
  echo "Proxy profile ${name} has been added"
}

# Removes the proxy profile with the given name.
# Globals:
#  REPLY, SETTINGS_FILE
# Arguments:
#  name: the name of the proxy profile
remove_proxy () {
  local name="${1}"

  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No proxy profiles have found"
    return 0
  fi

  if [[ -z "${name}" ]]; then
    pick_proxy || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local exists=''
  exists="$(jq ".proxies|if . then .[]|select(.name == \"${name}\") else empty end" "${SETTINGS_FILE}")"

  if [[ -z "${exists}" ]]; then
    echo "Cannot find proxy profile ${name}"
    return 2
  fi

  local settings=''
  settings="$(jq -e "del(.proxies[]|select(.name == \"${name}\"))" "${SETTINGS_FILE}")"

  if [[ $? -ne 0 ]]; then
    echo "Failed to delete proxy profile ${name}"
    return 2
  fi

  echo "${settings}" > "${SETTINGS_FILE}"
  
  echo "Proxy profile ${name} has been deleted"
}

# Shows the list of all proxy profiles stored in the
# settings file.
# Globals:
#  SETTINGS_FILE
# Arguments:
#  None
# Outputs:
#  A list of proxy profiles.
list_proxies () {
  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No proxy profiles have found"
    return 0
  fi

  local proxies=''
  proxies="$(jq -cer '.proxies|if length>0 then . else [] end' "${SETTINGS_FILE}")" || return 1
  
  local len=0
  len="$(count "${proxies}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No proxy profiles have found"
    return 0
  fi

  local query=''
  query+='Name:    \(.name)\n'
  query+='Host:    \(.host)\n'
  query+='Port:    \(.port)'
  query+='\(.username|if . and .!="" then "\nAuth:    \(.)" else "" end)'
  query+='\(.no_proxy|if .|length>0 then "\nIgnore:  \([.[]]|join(", "))" else "" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${proxies}" | jq -cer "${query}" || return 1
}

# Sets system-wise proxy server to settings with the
# given profile name.
# Globals:
#  REPLY, SETTINGS_FILE, HOME, PROXY_ENV_FILE, SHELLRC_FILE
# Arguments:
#  name: the name of a proxy profile
set_proxy () {
  local name="${1}"

  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No proxy profiles have found"
    return 2
  fi

  if [[ -z "${name}" ]]; then
    pick_proxy || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local proxy=''
  proxy="$(jq ".proxies|if . then .[]|select(.name == \"${name}\") else empty end" "${SETTINGS_FILE}")"

  if [[ -z "${proxy}" ]]; then
    echo "Cannot find proxy profile ${name}"
    return 2
  fi

  local query=''
  query+='\(if .username then "\(.username):\(.password)@" else "" end)'
  query+='\(.host):\(.port)'
  query="\"${query}\""

  local uri=''
  uri="$(echo "${proxy}" | jq -cer "${query}")" || return 1

  local no_proxy=''
  no_proxy="$(echo "${proxy}" | jq -cer '[.no_proxy][]|join(",")')" || return 1

  mkdir -p "${HOME}/.config/environment.d"

  echo "export http_proxy=\"http://${uri}/\"" > "${PROXY_ENV_FILE}" &&
  echo "export HTTP_PROXY=\"http://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export https_proxy=\"https://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export HTTPS_PROXY=\"https://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export ftp_proxy=\"ftp://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export FTP_PROXY=\"ftp://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export rsync_proxy=\"rsync://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export RSYNC_PROXY=\"rsync://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export all_proxy=\"https://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export ALL_PROXY=\"https://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export no_proxy=\"${no_proxy}\"" >> "${PROXY_ENV_FILE}" &&
  echo "export NO_PROXY=\"${no_proxy}\"" >> "${PROXY_ENV_FILE}" &&
  sed -i "\|source \"${PROXY_ENV_FILE}\"|d" "${SHELLRC_FILE}" &&
  echo "source \"${PROXY_ENV_FILE}\"" >> "${SHELLRC_FILE}" ||
    echo "Failed to set environment proxy variables"

  if which git &> /dev/null; then
    git config --global http.proxy "http://${uri}/" &&
    git config --global https.proxy "https://${uri}/" ||
      echo "Failed to set git proxy settings"
  fi

  if which npm &> /dev/null; then
    npm config set proxy "http://${uri}/" &&
    npm config set https-proxy "https://${uri}/" ||
      echo "Failed to set npm proxy settings"
  fi
  
  if which yarn &> /dev/null; then
    yarn config set proxy "http://${uri}/" &&
    yarn config set https-proxy "https://${uri}/" ||
      echo "Failed to set yarn proxy settings"
  fi

  if which docker &> /dev/null; then
    sudo mkdir -p "/etc/systemd/system/docker.service.d"

    printf '%s\n%s%s%s%s' \
      "[Service]" \
      "Environment=" \
      "\"HTTP_PROXY=http://${uri}/\" " \
      "\"HTTPS_PROXY=https://${uri}/\" " \
      "\"NO_PROXY=${no_proxy}\"" | sudo tee "${DOCKER_PROXY_FILE}" > /dev/null &&
    sudo systemctl daemon-reload ||
      echo "Failed to set docker proxy settings"
  fi

  local host=''
  host="$(get "${proxy}" ".host")" || return 1

  local port=''
  port="$(get "${proxy}" ".port")" || return 1

  gsettings set org.gnome.system.proxy mode "manual"
  gsettings set org.gnome.system.proxy.http host "${host}"
  gsettings set org.gnome.system.proxy.http port "${port}"
  gsettings set org.gnome.system.proxy.https host "${host}"
  gsettings set org.gnome.system.proxy.https port "${port}"
  gsettings set org.gnome.system.proxy.ftp host "${host}"
  gsettings set org.gnome.system.proxy.ftp port "${port}"
  gsettings set org.gnome.system.proxy.socks host "${host}"
  gsettings set org.gnome.system.proxy.socks port "${port}"

  local username=''
  username="$(get "${proxy}" ".username")" || return 1

  local password=''
  password="$(get "${proxy}" ".password")" || return 1

  if [[ -n "${username}" ]]; then
    gsettings set org.gnome.system.proxy.http use-authentication true
    gsettings set org.gnome.system.proxy.http authentication-user "${username}"
    gsettings set org.gnome.system.proxy.http authentication-password "${password}"
  else
    gsettings set org.gnome.system.proxy.http use-authentication false
    gsettings set org.gnome.system.proxy.http authentication-user ""
    gsettings set org.gnome.system.proxy.http authentication-password ""
  fi

  local query=".no_proxy|if .|length > 0"
  query+=" then \"[\([.[]|\"'\(.)'\"]|join(\",\"))]\" else [] end"

  local no_proxy=''
  no_proxy="$(echo "${proxy}" | jq -cer "${query}")" || return 1

  gsettings set org.gnome.system.proxy ignore-hosts "${no_proxy}"
  
  echo "Proxy settings have been applied"
}

# Reverts any proxy settings have been applied to
# the system.
# Globals:
#  PROXY_ENV_FILE, SHELLRC_FILE
# Arguments:
#  None
unset_proxy () {
  rm -f "${PROXY_ENV_FILE}" &&
  sed -i "\|source \"${PROXY_ENV_FILE}\"|d" "${SHELLRC_FILE}" ||
    echo "Failed to unset environment proxy variables"

  if which git &> /dev/null &&
    git config --global --get http.proxy &> /dev/null; then
    git config --global --unset http.proxy &&
    git config --global --unset https.proxy ||
      echo "Failed to unset git proxy settings"
  fi

  if which npm &> /dev/null; then
    npm config delete proxy &&
    npm config delete https-proxy ||
      echo "Failed to set npm proxy settings"
  fi
  
  if which yarn &> /dev/null; then
    yarn config delete proxy &&
    yarn config delete https-proxy ||
      echo "Failed to unset yarn proxy settings"
  fi

  if which docker &> /dev/null; then
    sudo rm -f "${DOCKER_PROXY_FILE}" &&
    sudo systemctl daemon-reload ||
      echo "Failed to unset docker proxy settings"
  fi

  gsettings set org.gnome.system.proxy mode "none"
  gsettings set org.gnome.system.proxy.http host ""
  gsettings set org.gnome.system.proxy.http port "0"
  gsettings set org.gnome.system.proxy.https host ""
  gsettings set org.gnome.system.proxy.https port "0"
  gsettings set org.gnome.system.proxy.ftp host ""
  gsettings set org.gnome.system.proxy.ftp port "0"
  gsettings set org.gnome.system.proxy.socks host ""
  gsettings set org.gnome.system.proxy.socks port "0"
  gsettings set org.gnome.system.proxy.http use-authentication false
  gsettings set org.gnome.system.proxy.http authentication-user ""
  gsettings set org.gnome.system.proxy.http authentication-password ""
  gsettings set org.gnome.system.proxy ignore-hosts "[]"

  echo "Proxy settings have been unset"
}

# Sets the system networking to on or off.
# Arguments:
#  mode: on or off
power_network () {
  local mode="${1}"

  if [[ -z "${mode}" ]]; then
    echo "Missing mode value"
    return 2
  elif [[ ! "${mode}" =~ ^(on|off)$ ]]; then
    echo "Invalid mode value"
    return 2
  fi

  echo "Powering network ${mode}..."

  nmcli networking "${mode}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to power network ${mode}"
    return 2
  fi

  sleep 3
  echo "Network power set to ${mode}"
}

# Sets the wifi to on or off.
# Arguments:
#  mode: on or off
power_wifi () {
  local mode="${1}"

  if [[ -z "${mode}" ]]; then
    echo "Missing mode value"
    return 2
  elif [[ ! "${mode}" =~ ^(on|off)$ ]]; then
    echo "Invalid mode value"
    return 2
  fi

  echo "Powering wifi ${mode}..."

  nmcli radio wifi "${mode}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to power wifi ${mode}"
    return 2
  fi

  sleep 3
  echo "Wifi power set to ${mode}"
}

# Shows the help message.
# Arguments:
#  None
# Outputs:
#  A long help message.
show_help () {
  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf " %-35s %s\n" \
    "help" "Show this help message." \
    "" "" \
    "show status" "Show the current status of networking." \
    "show device [<name>]" "Show the data of a device." \
    "show connection [<name>]" "Show the data of a connection." \
    "" "" \
    "list devices" "List the network devices." \
    "list connections" "List the network connections." \
    "list wifis [<device>] [<signal>]" "Detect wifi networks with a min signal." \
    "" "" \
    "up device [<name>]" "Enable a network device." \
    "down device [<name>]" "Disable a network device." \
    "remove device [<name>]" "Remove a software network device." \
    "" "" \
    "up connection [<name>]" "Enable a connection." \
    "down connection [<name>]" "Disable a connection." \
    "add connection <eth|wifi|vpn>" "Add an ethernet, wifi or vpn connection." \
    "remove connection [<name>]" "Remove a connection." \
    "" "" \
    "add proxy <name>" "Add a new proxy server profile." \
    "remove proxy [<name>]" "Remove a proxy server profile." \
    "list proxies" "List all proxy server profiles." \
    "set proxy [<name>]" "Applies proxy server settings." \
    "unset proxy" "Disables proxy server settings." \
    "" "" \
    "power network on|off" "Set the system network to on or off." \
    "power wifi on|off" "Set the wifi device to on or off."
}

loop () {
  clear

  while true; do
    prompt && history -s "${REPLY}"

    set -f
    set_separator "line"
    local cmd=($(xargs -n1 <<< "${REPLY}"))
    restore_separator && set +f

    if [[ "${cmd[0]}" == "help" ]]; then
      show_help
      continue
    elif [[ "${cmd[0]}" == "clear" ]]; then
      clear
      continue
    elif [[ "${cmd[0]}" == "quit" ]]; then
      break
    elif [[ -z "${cmd[0]}" ]]; then
      continue
    fi

    case "${cmd[0]}" in
      "show")
        case "${cmd[1]}" in
          "status") show_status;;
          "device") show_device "${cmd[2]}";;
          "connection") show_connection "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "list")
        case "${cmd[1]}" in
          "devices") list_devices;;
          "connections") list_connections;;
          "wifis") list_wifis "${cmd[2]}" "${cmd[3]}";;
          "proxies") list_proxies;;
          *) echo "Invalid or unknown command";;
        esac;;
      "power")
        case "${cmd[1]}" in
          "network") power_network "${cmd[2]}";;
          "wifi") power_wifi "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "up") up "${cmd[1]}" "${cmd[2]}";;
      "down") down "${cmd[1]}" "${cmd[2]}";;
      "add")
        case "${cmd[1]}" in
          "connection")
            case "${cmd[2]}" in
              "eth") add_ethernet_connection;;
              "wifi") add_wifi_connection;;
              "vpn") add_vpn_connection;;
              *) echo "Invalid or unknown command";;
            esac;;
          "proxy") add_proxy "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "remove")
        case "${cmd[1]}" in
          "device") remove_device "${cmd[2]}";;
          "connection") remove_connection "${cmd[2]}";;
          "proxy") remove_proxy "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "set")
        case "${cmd[1]}" in
          "proxy") set_proxy "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "unset")
        case "${cmd[1]}" in
          "proxy") unset_proxy;;
          *) echo "Invalid or unknown command";;
        esac;;
      *) echo "Invalid or unknown command";; 
    esac

    if [[ $? -eq 1 ]]; then
      echo "An unknown error has occurred"
    fi
  done

  clear
}

loop