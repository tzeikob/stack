#!/bin/bash

set -o pipefail
source /opt/stack/utils

SETTINGS_FILE="${CONFIG_HOME}/networks.json"
SHELLRC_FILE="${HOME}/.bashrc"
PROXY_ENV_FILE="${HOME}/.config/environment.d/proxy.conf"
DOCKER_PROXY_FILE='/etc/systemd/system/docker.service.d/http-proxy.conf'

# Returns the general status of the networking.
# Arguments:
#  None
# Outputs:
#  A json object of status.
find_status () {
  nmcli general | jc --nmcli | jq -cer '.[0]' || return 1
}

# Returns the list of network devices of the
# given type.
# Arguments:
#  type: ethernet, wifi or bridge
# Outputs:
#  A json array of device objects.
find_devices () {
  local type="${1}"

  local query='.'
  if [[ -n "${type}" ]]; then
    query="[.[]|select(.type == \"${type}\")]"
  fi

  nmcli device | jc --nmcli | jq -cer "${query}" || return 1
}

# Returns the device with the given name.
# Arguments:
#  name: the name of a device
# Outputs:
#  A josn object of a device.
find_device () {
  local name="${1}"

  nmcli device show "${name}" | jc --nmcli | jq -cer '.[0]' || return 1
}

# Returns the list of network connections.
# Arguments:
#  None
# Outputs:
#  A json array of connection objects.
find_connections () {
  nmcli connection | jc --nmcli || return 1
}

# Returns the connection with the given name.
# Arguments:
#  name: the name of a connection
# Outputs:
#  A json object of connection.
find_connection () {
  local name="${1}"

  nmcli connection show "${name}" | jc --nmcli | jq -cer '.[0]' || return 1
}

# Returns any detected wifi networks broadcasting in
# your local area having a singal strength equal to
# the given value.
# Arguments:
#  signal: a signal limitation value
# Outputs:
#  A json array list of wifi networks.
find_wifis () {
  local signal="${1:-"0"}"

  local networks=''
  networks="$(nmcli -f SSID,SIGNAL,CHAN,SECURITY -t device wifi list |
    awk -v limit="${signal}" -F: '{
      if ($2 >= limit) {
        schema="\"ssid\":\"%s\","
        schema=schema"\"signal\":%s,"
        schema=schema"\"channel\":\"%s\","
        schema=schema"\"security\":\"%s\""
        schema="{"schema"},"
        printf schema, $1,$2,$3,$4,$5
      }
    }'
  )" || return 1

  # Remove the last comma after the last element
  if [[ -n "${networks}" ]]; then
    networks="${networks::-1}"
  fi

  echo "[${networks}]"
}

# Validates if the network object with the given name
# exists and is a valid networking entity.
# Arguments:
#  object: device or connection
#  name:   the name of the object
# Returns:
#  0 if object is valid otherwise 1.
validate () {
  local object="${1}"
  local name="${2}"

  if [[ ! "${object}" =~ ^(device|connection)$ ]]; then
    return 1
  fi

  local result=''

  if [[ "${object}" == "device" ]]; then
    result="$(find_devices | jq -cer ".[]|select(.device == \"${name}\")")"
  elif [[ "${object}" == "connection" ]]; then
    result="$(find_connections | jq -cer ".[]|select(.name == \"${name}\")")"
  fi

  if [[ $? -ne 0 ]] || [[ -z "${result}" ]]; then
    return 1
  fi
}

# Shows a menu asking the user to select one device, where the
# answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  type: ethernet, wifi or bridge
# Outputs:
#  A menu of device names.
pick_device () {
  local type="${1}"

  local query='{key: .device, value: .device}'
  query="[.[]|${query}]"

  local devices=''
  devices="$(find_devices "${type}" | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${devices}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No devices have found"
    return 2
  fi

  pick_one "Select a device:" "${devices}" "vertical" || return $?
}

# Shows a menu asking the user to select one connection,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of connection names.
pick_connection () {
  local query='{key: .name, value: .name}'
  query="[.[]|${query}]"

  local connections=''
  connections="$(find_connections | jq -cer "${query}")" || return 1

  local len=0
  len="$(count "${connections}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No connections have found"
    return 2
  fi

  pick_one "Select a connection:" "${connections}" "vertical" || return $?
}

# Shows a menu asking the user to select one proxy profile,
# where the answer is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A menu of proxy profiles.
pick_proxy () {
  local query=''
  query+='{key: .name, value: "\(.name) [\(.host)]"}'
  query=".proxies|if .|length>0 then [.[]|${query}] else [] end"

  local proxies=''
  proxies="$(jq -cer "${query}" "${SETTINGS_FILE}")" || return 1
  
  local len=0
  len="$(count "${proxies}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No proxy profiles have found"
    return 2
  fi

  pick_one "Select a proxy profile:" "${proxies}" "vertical" || return $?
}

# Shows a prompt status and asks user to enter the
# next command, which is kept in the global var REPLY.
# Globals:
#  REPLY
# Arguments:
#  None
# Outputs:
#  A minimal prompt status line.
prompt () {
  local query=''
  query+='[.[]|select((.type == "wifi" or .type == "ethernet") and .state == "connected")]'
  query+=' |if .|length > 0 then .[0].device else "local" end'

  local status=''
  status="$(find_devices | jq -cer "${query}")"

  if [[ $? -ne 0 ]]; then
    status='none'
  fi

  read -rep "[networks:${status}] " REPLY
}

# Shows the current status of the system networking.
# Arguments:
#  None
# Outputs:
#  A long list of networking data.
show_status () {
  local devices=''
  devices="$(find_devices)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read network devices"
    return 2
  fi

  local query=''
  query+='\([$d[]|select((.type == "wifi" or .type == "ethernet") and .state == "connected")]'
  query+=' |if .|length == 0 then "local" else .[0]|.device end|'
  query+='"Network:     \(.)\n")'
  query+='State:       \(.state)\n'
  query+='Connection:  \(.connectivity)\n'
  query+='WiFi:        \(.wifi)\(if .wifi_hw then " [HW]" else "" end)\n'
  query+='WWAN:        \(.wwan)\(if .wwan_hw then " [HW]" else "" end)'
  query="\"${query}\""

  find_status | jq -cer --argjson d "${devices}" "${query}" || return 1

  local proxy='off'
  if [[ -f "${PROXY_ENV_FILE}" ]]; then
    proxy="$(cat "${PROXY_ENV_FILE}" | awk -F'=' '/export http_proxy=/ {
      split($2,a,"http://")
      if (a[2] ~ /@/) {
        split(a[2],b,"@")
        print b[2]
      } else print a[2]
    }' | tr -d '"/')" || return 1
  fi

  echo "Proxy:       ${proxy}"

  query=''
  query+='.[]|select(.state == "connected")|.connection'

  local connections=''
  connections="$(echo "${devices}" | jq -cr "${query}")" || return 1

  if [[ -z "${connections}" ]]; then
    return 0
  fi

  query=''
  query+='Connection:  \(.connection_id)'
  query+='\(if .default == "yes" then " [default]" else "" end)\n'
  query+='\(."802_11_wireless_ssid"|if . then "SSID:        \(.)\n" else "" end)'
  query+='Device:      \(.connection_interface_name)\n'
  query+='State:       \(.state)\n'
  query+='Type:        \(.connection_type)\n'
  query+='\(."802_11_wireless_security_key_mgmt"|'
  query+=' if . then "Security:    \(.|ascii_upcase)\n" else "" end)'
  query+='VPN:         \(.vpn)\n'
  query+='IPv4:        \(.ip4_address_1)\n'
  query+='IPv6:        \(.ip6_address_1)'
  query="\"${query}\""

  local connection=''
  while read -r connection; do
    echo
    find_connection "${connection}" | jq -cer "${query}" || return 1
  done <<< "${connections}"
}

# Shows the data of the network device with the given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of a device
# Outputs:
#  A long list of device data.
show_device () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_device || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "device" "${name}"; then
    echo "Invalid or unknown device"
    return 2
  fi

  local query=''
  query+='Name:        \(.device)\n'
  query+='Type:        \(.type)\n'
  query+='MAC:         \(.hwaddr)\n'
  query+='\(.state_text|if . then "State:       \(.)\n" else "" end)'
  query+='MTU:         \(.mtu)'
  query+='\(.ip4_address_1|if . then "\nIPv4:        \(.)" else "" end)'
  query+='\(.ip4_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip4_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query+='\(.ip4_dns_1|if . then "\nDNS:         \(.)" else "" end)'
  query+='\(.ip4_dns_2|if . then ", \(.)" else "" end)'
  query+='\(.ip6_address_1|if . then "\nIPv6:        \(.)" else "" end)'
  query+='\(.ip6_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip6_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query+='\(.connection|if . then "\nConnection:  \(.)" else "" end)'
  query="\"${query}\""

  find_device "${name}" | jq -cer "${query}" || return 1
}

# Shows the data of the network connection with the
# given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of a connection
# Outputs:
#  A long list of connection data.
show_connection () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_connection || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "connection" "${name}"; then
    echo "Invalid or unknown connection"
    return 2
  fi

  local query=''
  query+='Connection:  \(.connection_id)'
  query+='\(if .default == "yes" then " [default]" else "" end)\n'
  query+='\(."802_11_wireless_ssid"|if . then "SSID:        \(.)\n" else "" end)'
  query+='\(.connection_uuid|if . then "UUID:        \(.)\n" else "" end)'
  query+='Device:      \(.connection_interface_name)\n'
  query+='\(.state|if . then "State:       \(.)\n" else "" end)'
  query+='Auto:        \(.connection_autoconnect)\n'
  query+='Type:        \(.connection_type)'
  query+='\(."802_11_wireless_security_key_mgmt"|'
  query+=' if . then "\nSecurity:    \(.|ascii_upcase)" else "" end)'
  query+='\(.vpn|if . then "\nVPN:         \(.)" else "" end)'
  query+='\(.ip4_address_1|if . then "\nIPv4:        \(.)" else "" end)'
  query+='\(.ip4_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip4_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query+='\(.ip4_dns_1|if . then "\nDNS:         \(.)" else "" end)'
  query+='\(.ip4_dns_2|if . then ", \(.)" else "" end)'
  query+='\(.ip6_address_1|if . then "\nIPv6:        \(.)" else "" end)'
  query+='\(.ip6_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip6_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query="\"${query}\""

  find_connection "${name}" | jq -cer "${query}" || return 1
}

# Shows the list of networking devices.
# Arguments:
#  None
# Outputs:
#  A list of network devices.
list_devices () {
  local devices=''
  devices="$(find_devices)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read network devices"
    return 2
  fi

  local len=0
  len="$(count "${devices}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No network devices have found"
    return 0
  fi

  local query=''
  query+='Name:        \(.device)\n'
  query+='Type:        \(.type)\n'
  query+='State:       \(.state|if . then . else "none" end)\n'
  query+='Connection:  \(.connection|if . then . else "none" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${devices}" | jq -cer "${query}" || return 1
}

# Shows the list of networking connections.
# Arguments:
#  None
# Outputs:
#  A list of network connections.
list_connections () {
  local connections=''
  connections="$(find_connections)"

  if [[ $? -ne 0 ]]; then
    echo "Unable to read network connections"
    return 2
  fi

  local len=0
  len="$(count "${connections}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No network connections have found"
    return 0
  fi

  local query=''
  query+='Name:    \(.name)\n'
  query+='Type:    \(.type)\n'
  query+='Device:  \(.device|if . then . else "none" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${connections}" | jq -cer "${query}" || return 1
}

# Detects the available wifi networks in the local area
# with signal strength at least the given limit.
# Arguments:
#  limit: a signal limitation value
# Outputs:
#  The list of wifi networks.
scan () {
  local signal="${1:-"0"}"

  if [[ ! "${signal}" =~ ^[0-9][0-9]{,2}$ ]]; then
    echo "Invalid signal limit value"
    return 2
  elif (( ${signal} < 0 || ${signal} > 100 )); then
    echo "Signal limit value out of range"
    return 2
  fi

  echo "Detecting available wifi networks..."

  local networks=''
  networks="$(find_wifis "${signal}")"

  if [[ $? -ne 0 ]]; then
    echo "Unable to detect wifi networks"
    return 2
  fi

  local len=0
  len="$(count "${networks}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No wifi networks have been detected"
    return 0
  fi

  local query=''
  query+='Name:      \(.ssid)\n'
  query+='Signal:    \(.signal) [\(.channel)]\n'
  query+='Security:  \(.security|'
  query+='if . and . != "" then .|ascii_upcase else "none" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${networks}" | jq -cer "${query}" || return 1
}

# Connect to the wifi network with the given id
# and secret key.
# Globals:
#  REPLY
# Arguments:
#  ssid: the ssid of the wifi network
connect () {
  local ssid="${1}"

  if [[ -z "${ssid}" ]]; then
    echo "Detecting available wifi networks..."

    local networks=''
    networks="$(find_wifis)" || return 1

    local len=0
    len="$(count "${networks}")" || return 1

    if [[ ${len} -eq 0 ]]; then
      echo "No wifi networks have been detected"
      return 0
    fi

    local query='{key: .ssid, value: "[\(.signal)] \(.ssid)"}'
    query="[.[]|${query}]"

    networks="$(echo "${networks}" | jq -cer "${query}")" || return 1
    pick_one "Select a wifi network:" "${networks}" "vertical" || return $?
    [[ -n "${REPLY}" ]] && ssid="${REPLY}" || return 0
  fi

  ask_password "Enter the private key:" || return $?
  local key="${REPLY}"

  echo "Connecting to ${ssid}..."

  nmcli device wifi connect "${ssid}" password "${key}" hidden yes
  
  if [[ $? -ne 0 ]]; then
    echo "Failed to connect to ${ssid}"
    return 2
  fi

  sleep 3
  echo "Connection to ${ssid} has been established"
}

# Enables the device or connection with the given name.
# Globals:
#  REPLY
# Arguments:
#  object: device or connection
#  name:   the name of a device or connection
up () {
  local object="${1}"
  local name="${2}"

  if [[ -z "${name}" ]]; then
    if [[ "${object}" == "device" ]]; then
      pick_device || return $?
    elif [[ "${object}" == "connection" ]]; then
      pick_connection || return $?
    else
      echo "Invalid or unknown network object"
      return 2
    fi

    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "${object}" "${name}"; then
    echo "Invalid or unknown network object"
    return 2
  fi

  echo "Enabling ${object} ${name}..."

  if [[ "${object}" == "device" ]]; then
    nmcli device connect "${name}" &>/dev/null
  elif [[ "${object}" == "connection" ]]; then
    nmcli connection up "${name}" &>/dev/null
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to enable ${object}"
    return 2
  fi

  sleep 3
  echo "${object^} ${name} has been enabled"
}

# Disables the device or connection with the given name.
# Globals:
#  REPLY
# Arguments:
#  object: device or connection
#  name:   the name of a device or connection
down () {
  local object="${1}"
  local name="${2}"

  if [[ -z "${name}" ]]; then
    if [[ "${object}" == "device" ]]; then
      pick_device || return $?
    elif [[ "${object}" == "connection" ]]; then
      pick_connection || return $?
    else
      echo "Invalid or unknown network object"
      return 2
    fi

    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "${object}" "${name}"; then
    echo "Invalid or unknown network object"
    return 2
  fi

  echo "Disabling ${object} ${name}..."

  if [[ "${object}" == "device" ]]; then
    nmcli device disconnect "${name}" &>/dev/null
  elif [[ "${object}" == "connection" ]]; then
    nmcli connection down "${name}" &>/dev/null
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to disable ${object}"
    return 2
  fi

  sleep 3
  echo "${object^} ${name} has been disabled"
}

# Removes the device or connection with the given name.
# Globals:
#  REPLY
# Arguments:
#  object: device or connection
#  name:   the name of a device or connection
remove () {
  local object="${1}"
  local name="${2}"

  if [[ -z "${name}" ]]; then
    if [[ "${object}" == "device" ]]; then
      pick_device || return $?
    elif [[ "${object}" == "connection" ]]; then
      pick_connection || return $?
    else
      echo "Invalid or unknown network object"
      return 2
    fi

    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "${object}" "${name}"; then
    echo "Invalid or unknown network object"
    return 2
  fi

  echo "Removing ${object} ${name}..."

  if [[ "${object}" == "device" ]]; then
    nmcli device delete "${name}" &>/dev/null
  elif [[ "${object}" == "connection" ]]; then
    nmcli connection delete "${name}" &>/dev/null
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to remove ${object}"
    return 2
  fi

  sleep 3
  echo "${object^} ${name} has been removed"
}

# Adds a new ethernet connection with the given name.
# Globals:
#  REPLY
# Arguments:
#  name: the name of the connection
add () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    echo "Connection name is missing"
    return 2
  fi

  if find_connection "${name}" &>/dev/null; then
    echo "Connection ${name} already exists"
    return 2
  fi

  local device=''
  pick_device "ethernet" || return $?
  [[ -n "${REPLY}" ]] && device="${REPLY}" || return 0

  local dhcp=''
  confirm "Want to enable DHCP mode?" || return $?
  [[ -n "${REPLY}" ]] && dhcp="${REPLY}" || return 0

  echo "Creating connection ${name}..."

  if [[ "${dhcp}" == "yes" ]]; then
    nmcli connection add type "ethernet" \
      con-name "${name}" ifname "${device}" ipv4.method "auto"
  else
    local re='^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$'

    ask "Enter the static ip:" "${re}" || return $?
    local ip="${REPLY}"

    ask "Enter the gateway:" "${re}" || return $?
    local gateway="${REPLY}"

    ask "Enter the primary DNS:" "${re}" || return $?
    local dns="${REPLY}"

    ask "Enter the secondary DNS:" "${re}" || return $?
    dns="${dns} ${REPLY}"

    nmcli connection add type "ethernet" \
      con-name "${name}" ifname "${device}" ipv4.method "manual" \
      ipv4.addresses "${ip}/24" ipv4.gateway "${gateway}" ipv4.dns "${dns}"
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to create connection"
    return 2
  fi

  sleep 3
  echo "Connection ${name} has been created"
}

# Adds a new proxy profile with the given host,
# port and authentication info.
# Globals:
#  REPLY, SETTINGS_FILE, CONFIG_HOME
# Arguments:
#  name: the name of the proxy profile
add_proxy () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    echo "Missing the proxy profile name"
    return 2
  fi

  if [[ -f "${SETTINGS_FILE}" ]]; then
    local query=''
    query+=".proxies|if . then .[]|select(.name == \"${name}\") else empty end"
  
    local exists=''
    exists="$(jq -cr "${query}" "${SETTINGS_FILE}")" || return 1

    if [[ -n "${exists}" ]]; then
      echo "Proxy profile ${name} already exists"
      return 2
    fi
  fi

  ask "Enter the host:" ".+" || return $?
  local host="${REPLY}"

  ask "Enter the port:" ".+" || return $?
  local port="${REPLY}"

  confirm "Is this an authenticated proxy?" || return $?
  [[ -z "${REPLY}" ]] && return 0

  if [[ "${REPLY}" == "yes" ]]; then
    ask "Enter the username:" ".+" || return $?
    local username="${REPLY}"

    ask_password "Enter the password:" ".+" || return $?
    local password="${REPLY}"
  fi

  local no_proxy='[]'
  confirm "Want to set no proxy hosts?" || return $?
  [[ -z "${REPLY}" ]] && return 0

  if [[ "${REPLY}" == "yes" ]]; then
    ask "Enter no proxy hosts:" ".*" || return $?

    local query='[split(" ")|.[]|if . and .!="" then . else empty end]'
    no_proxy="$(echo "\"${REPLY}\"" | jq -cer "${query}")" || return 1
  fi

  local proxy=''
  proxy+="\"name\": \"${name}\","
  proxy+="\"host\": \"${host}\","
  proxy+="\"port\": \"${port}\","
  proxy+="\"no_proxy\": ${no_proxy}"

  if [[ -n "${username}" ]]; then
    proxy+=",\"username\": \"${username}\""
    proxy+=",\"password\": \"${password}\""
  fi

  proxy="{${proxy}}"

  if [[ -f "${SETTINGS_FILE}" ]]; then
    settings="$(jq -e ".proxies += [${proxy}]" "${SETTINGS_FILE}")" || return 1
  else
    settings="$(echo "{\"proxies\": [${proxy}]}" | jq -e '.')" || return 1
  fi

  mkdir -p "${CONFIG_HOME}"
  echo "${settings}" > "${SETTINGS_FILE}"
  
  echo "Proxy profile ${name} has been added"
}

# Removes the proxy profile with the given name.
# Globals:
#  REPLY, SETTINGS_FILE
# Arguments:
#  name: the name of the proxy profile
remove_proxy () {
  local name="${1}"

  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No proxy profiles have found"
    return 0
  fi

  if [[ -z "${name}" ]]; then
    pick_proxy || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local exists=''
  exists="$(jq ".proxies|if . then .[]|select(.name == \"${name}\") else empty end" "${SETTINGS_FILE}")"

  if [[ -z "${exists}" ]]; then
    echo "Cannot find proxy profile ${name}"
    return 2
  fi

  local settings=''
  settings="$(jq -e "del(.proxies[]|select(.name == \"${name}\"))" "${SETTINGS_FILE}")"

  if [[ $? -ne 0 ]]; then
    echo "Failed to delete proxy profile ${name}"
    return 2
  fi

  echo "${settings}" > "${SETTINGS_FILE}"
  
  echo "Proxy profile ${name} has been deleted"
}

# Shows the list of all proxy profiles stored in the
# settings file.
# Globals:
#  SETTINGS_FILE
# Arguments:
#  None
# Outputs:
#  A list of proxy profiles.
list_proxies () {
  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No proxy profiles have found"
    return 0
  fi

  local proxies=''
  proxies="$(jq -cer '.proxies|if length>0 then . else [] end' "${SETTINGS_FILE}")" || return 1
  
  local len=0
  len="$(count "${proxies}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo "No proxy profiles have found"
    return 0
  fi

  local query=''
  query+='Name:    \(.name)\n'
  query+='Host:    \(.host)\n'
  query+='Port:    \(.port)'
  query+='\(.username|if . and .!="" then "\nAuth:    \(.)" else "" end)'
  query+='\(.no_proxy|if .|length>0 then "\nIgnore:  \([.[]]|join(", "))" else "" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${proxies}" | jq -cer "${query}" || return 1
}

# Sets system-wise proxy server to settings with the
# given profile name.
# Globals:
#  REPLY, SETTINGS_FILE, HOME, PROXY_ENV_FILE, SHELLRC_FILE
# Arguments:
#  name: the name of a proxy profile
set_proxy () {
  local name="${1}"

  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo "No proxy profiles have found"
    return 2
  fi

  if [[ -z "${name}" ]]; then
    pick_proxy || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local proxy=''
  proxy="$(jq ".proxies|if . then .[]|select(.name == \"${name}\") else empty end" "${SETTINGS_FILE}")"

  if [[ -z "${proxy}" ]]; then
    echo "Cannot find proxy profile ${name}"
    return 2
  fi

  local query=''
  query+='\(if .username then "\(.username):\(.password)@" else "" end)'
  query+='\(.host):\(.port)'
  query="\"${query}\""

  local uri=''
  uri="$(echo "${proxy}" | jq -cer "${query}")" || return 1

  local no_proxy=''
  no_proxy="$(echo "${proxy}" | jq -cer '[.no_proxy][]|join(",")')" || return 1

  mkdir -p "${HOME}/.config/environment.d"

  echo "export http_proxy=\"http://${uri}/\"" > "${PROXY_ENV_FILE}" &&
  echo "export HTTP_PROXY=\"http://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export https_proxy=\"https://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export HTTPS_PROXY=\"https://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export ftp_proxy=\"ftp://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export FTP_PROXY=\"ftp://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export rsync_proxy=\"rsync://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export RSYNC_PROXY=\"rsync://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export all_proxy=\"https://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export ALL_PROXY=\"https://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export no_proxy=\"${no_proxy}\"" >> "${PROXY_ENV_FILE}" &&
  echo "export NO_PROXY=\"${no_proxy}\"" >> "${PROXY_ENV_FILE}" &&
  sed -i "\|source \"${PROXY_ENV_FILE}\"|d" "${SHELLRC_FILE}" &&
  echo "source \"${PROXY_ENV_FILE}\"" >> "${SHELLRC_FILE}" ||
    echo "Failed to set environment proxy variables"

  if which git &> /dev/null; then
    git config --global http.proxy "http://${uri}/" &&
    git config --global https.proxy "https://${uri}/" ||
      echo "Failed to set git proxy settings"
  fi

  if which npm &> /dev/null; then
    npm config set proxy "http://${uri}/" &&
    npm config set https-proxy "https://${uri}/" ||
      echo "Failed to set npm proxy settings"
  fi
  
  if which yarn &> /dev/null; then
    yarn config set proxy "http://${uri}/" &&
    yarn config set https-proxy "https://${uri}/" ||
      echo "Failed to set yarn proxy settings"
  fi

  if which docker &> /dev/null; then
    sudo mkdir -p "/etc/systemd/system/docker.service.d"

    printf '%s\n%s%s%s%s' \
      "[Service]" \
      "Environment=" \
      "\"HTTP_PROXY=http://${uri}/\" " \
      "\"HTTPS_PROXY=https://${uri}/\" " \
      "\"NO_PROXY=${no_proxy}\"" | sudo tee "${DOCKER_PROXY_FILE}" > /dev/null &&
    sudo systemctl daemon-reload ||
      echo "Failed to set docker proxy settings"
  fi
  
  echo "Proxy settings have been applied"
}

# Reverts any proxy settings have been applied to
# the system.
# Globals:
#  PROXY_ENV_FILE, SHELLRC_FILE
# Arguments:
#  None
unset_proxy () {
  rm -f "${PROXY_ENV_FILE}" &&
  sed -i "\|source \"${PROXY_ENV_FILE}\"|d" "${SHELLRC_FILE}" ||
    echo "Failed to unset environment proxy variables"

  if which git &> /dev/null &&
    git config --global --get http.proxy &> /dev/null; then
    git config --global --unset http.proxy &&
    git config --global --unset https.proxy ||
      echo "Failed to unset git proxy settings"
  fi

  if which npm &> /dev/null; then
    npm config delete proxy &&
    npm config delete https-proxy ||
      echo "Failed to set npm proxy settings"
  fi
  
  if which yarn &> /dev/null; then
    yarn config delete proxy &&
    yarn config delete https-proxy ||
      echo "Failed to unset yarn proxy settings"
  fi

  if which docker &> /dev/null; then
    sudo rm -f "${DOCKER_PROXY_FILE}" &&
    sudo systemctl daemon-reload ||
      echo "Failed to unset docker proxy settings"
  fi
  
  echo "Proxy settings have been unset"
}

# Sets the system networking to on or off.
# Arguments:
#  mode: on or off
power_network () {
  local mode="${1}"

  if [[ -z "${mode}" ]]; then
    echo "Missing mode value"
    return 2
  elif [[ ! "${mode}" =~ ^(on|off)$ ]]; then
    echo "Invalid mode value"
    return 2
  fi

  echo "Powering network ${mode}..."

  nmcli networking "${mode}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to power network ${mode}"
    return 2
  fi

  sleep 3
  echo "Network power set to ${mode}"
}

# Sets the wifi to on or off.
# Arguments:
#  mode: on or off
power_wifi () {
  local mode="${1}"

  if [[ -z "${mode}" ]]; then
    echo "Missing mode value"
    return 2
  elif [[ ! "${mode}" =~ ^(on|off)$ ]]; then
    echo "Invalid mode value"
    return 2
  fi

  echo "Powering wifi ${mode}..."

  nmcli radio wifi "${mode}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to power wifi ${mode}"
    return 2
  fi

  sleep 3
  echo "Wifi power set to ${mode}"
}

# Shows the help message.
# Arguments:
#  None
# Outputs:
#  A long help message.
show_help () {
  echo "Usage: COMMAND [OBJECT] [ARGUMENTS]..."

  echo -e "\nCOMMANDS"
  printf " %-35s %s\n" \
    "help" "Show this help message." \
    "" "" \
    "show status" "Show the current status of networking." \
    "show device [<name>]" "Show the data of a device." \
    "show connection [<name>]" "Show the data of a connection." \
    "" "" \
    "list devices" "List the network devices." \
    "list connections" "List the network connections." \
    "" "" \
    "scan [<signal>]" "Detect wifi networks with min signal." \
    "connect [<ssid>]" "Connect to a wifi network." \
    "" "" \
    "up device [<name>]" "Enable a network device." \
    "down device [<name>]" "Disable a network device." \
    "remove device [<name>]" "Remove a software network device." \
    "" "" \
    "up connection [<name>]" "Enable a connection." \
    "down connection [<name>]" "Disable a connection." \
    "add connection <name>" "Add a new connection." \
    "remove connection [<name>]" "Remove a connection." \
    "" "" \
    "add proxy <name>" "Add a new proxy server profile." \
    "remove proxy [<name>]" "Remove a proxy server profile." \
    "list proxies" "List all proxy server profiles." \
    "set proxy [<name>]" "Applies proxy server settings." \
    "unset proxy" "Disables proxy server settings." \
    "" "" \
    "power network on|off" "Set the system network to on or off." \
    "power wifi on|off" "Set the wifi device to on or off."
}

loop () {
  clear

  while true; do
    prompt && history -s "${REPLY}"

    set -f
    set_separator "line"
    local cmd=($(xargs -n1 <<< "${REPLY}"))
    restore_separator && set +f

    if [[ "${cmd[0]}" == "help" ]]; then
      show_help
      continue
    elif [[ "${cmd[0]}" == "clear" ]]; then
      clear
      continue
    elif [[ "${cmd[0]}" == "quit" ]]; then
      break
    elif [[ -z "${cmd[0]}" ]]; then
      continue
    fi

    case "${cmd[0]}" in
      "show")
        case "${cmd[1]}" in
          "status") show_status;;
          "device") show_device "${cmd[2]}";;
          "connection") show_connection "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "list")
        case "${cmd[1]}" in
          "devices") list_devices;;
          "connections") list_connections;;
          "proxies") list_proxies;;
          *) echo "Invalid or unknown command";;
        esac;;
      "scan") scan "${cmd[1]}";;
      "power")
        case "${cmd[1]}" in
          "network") power_network "${cmd[2]}";;
          "wifi") power_wifi "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "connect") connect "${cmd[1]}";; 
      "up") up "${cmd[1]}" "${cmd[2]}";;
      "down") down "${cmd[1]}" "${cmd[2]}";;
      "add")
        case "${cmd[1]}" in
          "connection") add "${cmd[2]}";;
          "proxy") add_proxy "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "remove")
        case "${cmd[1]}" in
          "device") remove "device" "${cmd[2]}";;
          "connection") remove "connection" "${cmd[2]}";;
          "proxy") remove_proxy "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "set")
        case "${cmd[1]}" in
          "proxy") set_proxy "${cmd[2]}";;
          *) echo "Invalid or unknown command";;
        esac;;
      "unset")
        case "${cmd[1]}" in
          "proxy") unset_proxy;;
          *) echo "Invalid or unknown command";;
        esac;;
      *) echo "Invalid or unknown command";; 
    esac

    if [[ $? -eq 1 ]]; then
      echo "An unknown error has occurred"
    fi
  done

  clear
}

loop