#!/bin/bash

set -o pipefail

source /opt/stack/utils

# Returns the list of disk block devices.
# Arguments:
#  None
# Outputs:
#  A json array of disk block device objects.
find_disks () {
  local fields='name,path,type,size,rm,ro,tran,hotplug,state,'
  fields+='vendor,model,rev,serial,mountpoint,mountpoints,'
  fields+='label,uuid,fstype,fsver,fsavail,fsused,fsuse%'

  local query='[.blockdevices[]|select(.type == "disk")]'

  lsblk -J -o "${fields}" | jq -cer "${query}" || return 1
}

# Returns the disk block device with the given path.
# Arguments:
#  path: the path of a disk block device
# Outputs:
#  A json object of a disk block device.
find_disk () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local query=".[]|select(.path == \"${path}\")"

  find_disks | jq -cer "${query}" || return 1
}

# Returns the list of partitions of the disk block
# device with the given path.
# Arguments:
#  path:   the path of a disk block device
#  status: mounted or unmounted
# Outputs:
#  A json array of partition block device objects.
find_partitions () {
  local path="${1}"
  local status="${2}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  # Collect any disk partitions reported by lsblk
  local query=''
  query+='.children|if . then .[]|select(.type == "part") else empty end'
  query="[${query}]"

  local parts=''
  parts="$(find_disk "${path}" | jq -cer "${query}")" || return 1

  # Collect any disk encrypted volumes reported by veracrypt
  local volumes=''
  volumes="$(veracrypt -t --list 2>&1)"

  if [[ $? -ne 0 ]] && [[ ! "${volumes}" =~ "No volumes mounted" ]]; then
    return 1
  fi

  local query=''
  query+=".[]|select(.path|test(\"^${path}\"))"
  query+=' |{path: .path, veracrypt: .}'
  query="[${query}]"

  volumes="$(echo "${volumes}" | jc --veracrypt | jq -cer "${query}")" || return 1

  # Merge partitions and volumes data by path into an array
  local query='$p + $v | group_by(.path) | map(add)'

  if [[ "${status}" == "mounted" ]]; then
    query+='|.[]|select(.mountpoint != null or .veracrypt.mountpoint != null)'
  elif [[ "${status}" == "unmounted" ]]; then
    query+='|.[]|select(.mountpoint == null and .veracrypt.mountpoint == null)'
  fi

  query="[${query}]|flatten"

  jq -ncer --argjson p "${parts}" --argjson v "${volumes}" "${query}" || return 1
}

# Returns the partition block device with the given path.
# Arguments:
#  path: the path of a partition block device
# Outputs:
#  A json object of a partition block device.
find_partition () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  # Collect the partition data reported by lsblk
  local fields='name,path,type,size,rm,ro,tran,hotplug,state,'
  fields+='vendor,model,rev,serial,mountpoint,mountpoints,'
  fields+='label,uuid,fstype,fsver,fsavail,fsused,fsuse%'

  local query='.blockdevices[0]|select(.type == "part")'

  local part=''
  part="$(lsblk -J -o "${fields}" "${path}" | jq -cer "${query}")" || return 1

  # Colect the encrypted volume data reported by veracrypt, if any
  local volume=''
  volume="$(veracrypt -t --volume-properties "${path}" 2>&1)"

  if [[ $? -ne 0 ]] && [[ ! "${volume}" =~ "No such volume is mounted" ]]; then
    return 1
  fi

  local query='if .|length>0 then .[0]|{path: .path, veracrypt: .} else {} end'

  volume="$(echo "${volume}" | jc --veracrypt | jq -cer "${query}")" || return 1

  # Merge partition and volume data into an object
  jq -ncer --argjson p "${part}" --argjson v "${volume}" '\$p + \$v' || return 1
}

# Returns the list of rom block devices.
# Arguments:
#  status: mounted or unmounted
# Outputs:
#  A json array of rom block device objects.
find_roms () {
  local status="${1}"

  local fields='name,path,type,size,rm,ro,tran,hotplug,state,'
  fields+='vendor,model,rev,serial,mountpoint,mountpoints,'
  fields+='label,uuid,fstype,fsver,fsavail,fsused,fsuse%'

  local query='.blockdevices[]|select(.type == "rom")'

  if [[ "${status}" == "mounted" ]]; then
    query+='|select(.mountpoint != null)'
  elif [[ "${status}" == "unmounted" ]]; then
    query+='|select(.mountpoint == null)'
  fi

  query="[${query}]"

  lsblk -J -o "${fields}" | jq -cer "${query}" || return 1
}

# Returns the rom block device with the given path.
# Arguments:
#  path: the path of a rom block device
# Outputs:
#  A json object of a rom block device.
find_rom () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local query=".[]|select(.path == \"${path}\")"

  find_roms | jq -cer "${query}" || return 1
}

# Checks if the block device with the given path
# is a disk device.
# Arguments:
#  path: the path of a block device
# Returns:
#  0 if it is disk otherwise 1.
is_disk () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local type=''
  type="$(find_disk "${path}" | jq -cer '.type')" || return 1

  if [[ "${type}" == "disk" ]]; then
    return 0
  else
    return 1
  fi
}

# Checks if the block device with the given path
# is a disk with system partitions on it.
# Arguments:
#  path: the path of a disk block device
# Returns:
#  0 if it is a system disk otherwise 1.
is_system_disk () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local disk=''
  disk="$(find_disk "${path}")" || return 1

  local system_paths='/|/home|/boot|/var|/log|/swap'

  # Check if any partition's mountpoint is a system path
  local is_system_path="if . then .|test(\"^(${system_paths})$\") else false end"

  local query=''
  query+=".children|if . then [.[]|.mountpoint|${is_system_path}]|any else false end"

  local result=''
  result="$(echo "${disk}" | jq -cr "${query}")" || return 1

  if [[ "${result}" == "true" ]]; then
    return 0
  fi

  # Check also deep into the partitions children, if any
  local query=''
  query+=".children|if . then [.[]|.mountpoint|${is_system_path}]|any else false end"
  query=".children|if . then ([.[]|${query}]|any) else false end"

  result="$(echo "${disk}" | jq -cr "${query}")" || return 1

  if [[ "${result}" == "true" ]]; then
    return 0
  else
    return 1
  fi
}

# Checks if the block device with the given path
# is a partition device.
# Arguments:
#  path: the path of a block device
# Returns:
#  0 if it is partition otherwise 1.
is_partition () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local type=''
  type="$(find_partition "${path}" | jq -cer '.type')" || return 1

  if [[ "${type}" == "part" ]]; then
    return 0
  else
    return 1
  fi
}

# Checks if the block device with the given path
# is a partition pointing to a system path.
# Arguments:
#  path: the path of a partition block device
# Returns:
#  0 if it is a system partition otherwise 1.
is_system_partition () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local system_paths='/|/home|/boot|/var|/log|/swap'

  # Check if partition mountpoint is a system path
  local is_system_path="if . then .|test(\"^(${system_paths})$\") else false end"

  local query=''
  query+="if (.mountpoint|${is_system_path}) or (.veracrypt.mountpoint|${is_system_path})"
  query+=' then true else false '
  query+='end'

  local result=''
  result="$(find_partition "${path}" | jq -cer "${query}")" || return 1

  if [[ "${result}" == "true" ]]; then
    return 0
  else
    return 1
  fi
}

# Checks if the block device with the given path
# is a rom device.
# Arguments:
#  path: the path of a block device
# Returns:
#  0 if it is rom otherwise 1.
is_rom () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local type=''
  type="$(find_rom "${path}" | jq -cer '.type')" || return 1

  if [[ "${type}" == "rom" ]]; then
    return 0
  else
    return 1
  fi
}

# Checks if the block device with the given path
# is mounted or not.
# Arguments:
#  path: the path of a mountable block device
# Returns:
#  0 if it is mounted otherwise 1.
is_mounted () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  if grep -qsE "^${path} " /proc/mounts; then
    return 0
  fi

  if veracrypt -t --list 2>&1 | grep -qsE "^[0-9]+: ${path} "; then
    return 0
  fi

  return 1
}

# Mounts the block device with the given path.
# Arguments:
#  path: the path of a mountable block device
mount_device () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  udisksctl mount -b "${path}" &> /dev/null || return 1

  # Create symlink to the local mount folder
  local local_home="${HOME}/mounts/local"

  if [[ -d "/run/media/${USER}" ]] && [[ ! -L "${local_home}" ]]; then
    mkdir -p "${local_home}"
    ln -s "/run/media/${USER}" "${local_home}"
  fi
}

# Mounts the encrypted block device with the given path.
# Arguments:
#  path:     the path of an encrypted block device
#  password: the encryption key pass
mount_encrypted () {
  local path="${1}"
  local password="${2}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  local folder_name="$(echo "${path:1}" | tr '/' '_')"
  local mount_point="${HOME}/mounts/encrypted/${folder_name}"

  mkdir -p "${mount_point}" &&
  sudo veracrypt -t --mount "${path}" "${mount_point}" --password "${password}" \
    --pim 0 --keyfiles '' --protect-hidden no --non-interactive &> /dev/null

  if [[ $? -ne 0 ]]; then
    rm -rf "${mount_point}"
    return 1
  fi
}

# Unmounts the block device with the given path.
# Arguments:
#  path: the path of a mountable block device
unmount_device () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  sync &&
  udisksctl unmount -b "${path}" &> /dev/null || return 1
}

# Unmounts the encrypted block device with the given path.
# Arguments:
#  path: the path of an encrypted block device
unmount_encrypted () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  sync &&
  sudo veracrypt -t --dismount "${path}" &> /dev/null || return 1

  local folder_name="$(echo "${path:1}" | tr '/' '_')"
  rm -rf "${HOME}/mounts/encrypted/${folder_name}"
}

# Unmounts the mounted partitions of a disk block
# device with the given path.
# Arguments:
#  path: the path of a disk block device
unmount_partitions () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  # Collect any disk's mounted partitions
  local parts=''
  parts="$(grep -sE "^${path}p?[0-9]+ " /proc/mounts | awk '{print $1}')"

  # Collect any disk's mounted encrypted volumes, if any
  local volumes=''
  volumes="$(veracrypt -t --list 2>&1)"
  
  if [[ $? -ne 0 ]] && [[ ! "${volumes}" =~ "No volumes mounted" ]]; then
    return 1
  fi
  
  volumes="$(echo "${volumes}" | jc --veracrypt | jq -cr '.[]|.path')" || return 1
  
  if [[ -z "${parts}" ]] && [[ -z "${volumes}" ]]; then
    echo 'No mounted partitions have found'
    return 0
  fi

  if [[ -n "${parts}" ]]; then
    local part=''
    while read -r part; do
      unmount_device "${part}"

      if [[ $? -eq 0 ]]; then
        echo "Partition ${part} has been unmounted"
      else
        echo "Failed to unmount partition ${part}"
        return 2
      fi
    done <<< "${parts}"
  fi

  if [[ -n "${volumes}" ]]; then
    local volume=''
    while read -r volume; do
      unmount_encrypted "${volume}"

      if [[ $? -eq 0 ]]; then
        echo "Partition ${volume} has been unmounted"
      else
        echo "Failed to unmount partition ${volume}"
        return 2
      fi
    done <<< "${volumes}"
  fi
}

# Re-creates the partition table and removes any
# existing partitions on the disk block device with
# the given path.
# Arguments:
#  path: the path of a disk block device
clean_partitions () {
  local path="${1}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  sudo wipefs --all --force --quiet "${path}" &&
  sudo parted --script -a optimal -- "${path}" mklabel msdos || return 1
}

# Creates a primary partition to the disk block
# device with the given path.
# Arguments:
#  path:    the path of a block disk device
#  fs_type: the fs type of the partition
#  start:   the start of the partition
#  end:     the end of the partition
create_partition () {
  local path="${1}"
  local fs_type="${2}"
  local start="${3}"
  local end="${4}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  # Use ntfs as fs type for exfat file systems
  [[ "${fs_type}" == "exfat" ]] && fs_type='ntfs'
  
  sudo parted --script -a optimal -- "${path}" mkpart primary "${fs_type}" "${start}" "${end}" &&
  sudo parted --script -- "${path}" align-check optimal 1 || return 1
}

# Formats the i-th partition of the disk block
# device with the given path.
# Arguments:
#  path:    the path of a disk block device
#  index:   the index of the partition to format
#  fs_type: the fs type of the partition
#  label:   the label of the partition
format_partition () {
  local path="${1}"
  local index="${2}"
  local fs_type="${3}"
  local label="${4}"

  if [[ ! -b "${path}" ]]; then
    return 1
  fi

  # Add path postfix for nvme and mmcblk disks
  if [[ "${path}" =~ ^/dev/(nvme|mmcblk) ]]; then
    path="${path}p"
  fi

  case "${fs_type}" in
    ext2) sudo mkfs.ext2 -L "${label}" "${path}${index}" | awk NF;;
    ext3) sudo mkfs.ext3 -L "${label}" "${path}${index}" | awk NF;;
    ext4) sudo mkfs.ext4 -L "${label}" "${path}${index}" | awk NF;;
    ntfs) sudo mkfs.ntfs -f -L "${label}" "${path}${index}" | awk NF;;
    exfat) sudo mkfs.exfat -L "${label}" "${path}${index}" | awk NF;;
    fat32) sudo mkfs.fat -F 32 -n "${label}" "${path}${index}" | awk NF;;
    *) return 1;;
  esac

  if [[ $? -ne 0 ]]; then
    return 1
  fi
}

# Returns the list of shared folders of the given
# host available in the local network.
# Arguments:
#  host:      the name or ip of a host
#  username:  the name of the user
#  workgroup: the group of the user
#  password:  the password of the user
# Outputs:
#  A json array of shared folder objects.
find_shared_folders () {
  local host="${1}"
  local username="${2}"
  local workgroup="${3}"
  local password="${4}"

  local folders=''
  folders="$(smbclient -L "${host}" -U "${username}" -W "${workgroup}" --password="${password}" |
    awk '/Disk/{print "{\"name\":\""$1"\",\"type\":\""$2"\"},"}')" || return 1

  # Remove the extra comma after the last element
  if [[ -n "${folders}" ]]; then
    folders="${folders::-1}"
  fi

  echo "[${folders}]"
}

# Shows a menu asking the user to select one disk block device,
# where the answer is kept in the global var REPLY.
# Arguments:
#  None
# Outputs:
#  A menu of disk block devices.
pick_disk () {
  local disks=''
  disks="$(find_disks)"

  if [[ $? -ne 0 ]]; then
    echo 'Unable to find disks'
    return 2
  fi

  local len=0
  len="$(count "${disks}")" || return 1
  
  if [[ ${len} -eq 0 ]]; then
    echo 'No disks have found'
    return 2
  fi

  local trim='.|gsub("^\\s+|\\s+$";"")'
  local vendor="\(.vendor|if . then .|${trim} else empty end)"

  local value=''
  value+="[\"${vendor}\", .size]|join(\" \")"
  value="\(${value}|if . != \"\" then \" [\(.|${trim})]\" else empty end)"
  value="\(.path)${value}"

  local query=''
  query="[.[]|{key: .path, value: \"${value}\"}]"

  disks="$(echo "${disks}" | jq -cer "${query}")" || return 1

  pick_one 'Select a disk:' "${disks}" vertical || return $?
}

# Shows a menu asking the user to select one partition
# of the disk with the given path, where the answer is
# kept in the global var REPLY.
# Arguments:
#  path:   the path of a disk block device
#  status: mounted, unmounted
# Outputs:
#  A menu of partition block devices.
pick_partition () {
  local path="${1}"
  local status="${2}"

  local parts=''
  parts="$(find_partitions "${path}" "${status}")"

  if [[ $? -ne 0 ]]; then
    echo -e "Unable to find ${status:-\b} partitions"
    return 2
  fi

  local len=0
  len="$(count "${parts}")" || return 1
  
  if [[ ${len} -eq 0 ]]; then
    echo -e "No ${status:-\b} partitions have found"
    return 2
  fi

  local trim='.|gsub("^\\s+|\\s+$";"")'
  local label="\(.label|if . then .|${trim} else empty end)"

  local value=''
  value+="[\"${label}\", .size]|join(\" \")"
  value="\(${value}|if . != \"\" then \" [\(.|${trim})]\" else empty end)"
  value="\(.path)${value}"

  local query="[.[]|{key: .path, value: \"${value}\"}]"

  parts="$(echo "${parts}" | jq -cer "${query}")" || return 1

  pick_one 'Select a partition:' "${parts}" vertical || return $?
}

# Shows a menu asking the user to select one rom block
# device, where the answer is kept in the global var REPLY.
# Arguments:
#  status: mounted, unmounted
# Outputs:
#  A menu of rom block devices.
pick_rom () {
  local status="${1}"

  local roms=''
  roms="$(find_roms "${status}")"

  if [[ $? -ne 0 ]]; then
    echo -e "Unable to find ${status:-\b} roms"
    return 2
  fi

  local len=0
  len="$(count "${roms}")" || return 1
  
  if [[ ${len} -eq 0 ]]; then
    echo -e "No ${status:-\b} roms have found"
    return 2
  fi

  local trim='.|gsub("^\\s+|\\s+$";"")'
  local vendor="\(.vendor|if . then .|${trim} else empty end)"
  local label="\(.label|if . then .|${trim} else empty end)"

  local value=''
  value+="[\"${vendor}\", \"${label}\", .size]|join(\" \")"
  value="\(${value}|if . != \"\" then \" [\(.|${trim})]\" else empty end)"
  value="\(.path)${value}"

  local query=''
  query="[.[]|{key: .path, value: \"${value}\"}]"

  roms="$(echo "${roms}" | jq -cer "${query}")" || return 1

  pick_one 'Select a rom:' "${roms}" vertical || return $?
}

# Shows a menu asking the user to select one host, where the
# answer is kept in the global var REPLY.
# Arguments:
#  None
# Outputs:
#  A menu of host names.
pick_host () {
  echo 'Searching hosts in local network...'

  local hosts=''
  hosts="$(find_hosts)"

  if [[ $? -ne 0 ]]; then
    echo 'Unable to find hosts'
    return 2
  fi

  local len=0
  len="$(count "${hosts}")" || return 1
  
  if [[ ${len} -eq 0 ]]; then
    echo 'No hosts have found'
    return 2
  fi

  local query=''
  query+='key: .ip,'
  query+='value: "\(.ip)\(.name|if . and . != "" then " [\(.)]" else "" end)"'
  query="[.[]|{${query}}]"

  hosts="$(echo "${hosts}" | jq -cer "${query}")" || return 1

  pick_one 'Select a host:' "${hosts}" vertical || return $?
}

# Shows a menu asking the user to select one file system type,
# where the answer is kept in the global var REPLY.
# Arguments:
#  None
# Outputs:
#  A menu of file system types.
pick_fs_type () {
  local values=''
  values+='{"key": "ext4", "value": "EXT4"},'
  values+='{"key": "ext3", "value": "EXT3"},'
  values+='{"key": "ext2", "value": "EXT2"},'
  values+='{"key": "ntfs", "value": "NTFS"},'
  values+='{"key": "exfat", "value": "exFAT"},'
  values+='{"key": "fat32", "value": "FAT32"}'
  values="[${values}]"

  pick_one 'Select a file system type:' "${values}" vertical || return $?
}

