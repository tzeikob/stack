#!/bin/bash

set -o pipefail

source /opt/stack/utils
source /opt/stack/cloud/helpers

# Shows the list of remotes matching the given service.
# Arguments:
#  service: a service name (drive, dropbox e.g.)
# Outputs:
#  A list of remotes.
list_remotes () {
  local service="${1}"

  local query=''
  query="[.[]|select(.service|test(\"${service}\"; \"i\"))]"

  local remotes=''
  remotes="$(find_remotes | jq -cer "${query}")"

  if [[ $? -ne 0 ]]; then
    echo 'Unable to read remotes'
    return 2
  fi

  local len=0
  len="$(count "${remotes}")" || return 1
    
  if [[ ${len} -eq 0 ]]; then
    echo -e "No ${service:-\b} remotes have been found"
    return 0
  fi

  local query=''
  query+='Name:     \(.name)\n'
  query+='Service:  \(.service)\n'
  query+='Mounted:  \(.is_mounted)'
  query+='\(if .is_mounted then "\nMount:    \(.mount_point)" else "" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${remotes}" | jq -cer "${query}" || return 1
}

# Creates a new google drive remote with the given name.
# Arguments:
#  name: the name of the remote
sync_drive () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    echo 'Missing the remote name'
    return 2
  elif exists "${name}"; then
    echo "Remote ${name} already exists"
    return 2
  fi

  ask "Enter the client ID:" ".+" || return $?
  local client_id="${REPLY}"

  ask "Enter the client secret:" ".+" || return $?
  local client_secret="${REPLY}"

  ask "Enter the root folder ID (blank to skip):" || return $?
  local root_folder="${REPLY}"

  echo 'Go to browser and accept access permssions...'

  rclone config create "${name}" drive scope=drive client_id="${client_id}" \
    client_secret="${client_secret}" root_folder_id="${root_folder}" &> /dev/null

  if [[ $? -ne 0 ]]; then
    echo 'Failed to sync drive remote'
    rclone config delete "${name}"
    return 2
  fi

  echo "Drive remote ${name} has been synced"
}

# Creates a new dropbox remote with the given name.
# Arguments:
#  name: the name of the remote
sync_dropbox () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    echo 'Missing the remote name'
    return 2
  elif exists "${name}"; then
    echo "Remote ${name} already exists"
    return 2
  fi

  ask "Enter the app key:" ".+" || return $?
  local app_key="${REPLY}"

  ask "Enter the app secret:" ".+" || return $?
  local app_secret="${REPLY}"

  echo "Go to browser and accept access permssions..."

  rclone config create "${name}" dropbox \
    client_id="${app_key}" client_secret="${app_secret}" &> /dev/null

  if [[ $? -ne 0 ]]; then
    echo 'Failed to sync dropbox remote'
    rclone config delete "${name}"
    return 2
  fi

  echo "Dropbox remote ${name} has been synced"
}

# Deletes the remote with the given name.
# Arguments:
#  name: the name of a remote
delete_remote () {
  local name="${1}"
  
  if [[ -z "${name}" ]]; then
    pick_remote || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi
  
  if ! exists "${name}"; then
    echo "No remote ${name} has been found"
    return 2
  fi

  if is_mounted "${name}"; then
    unmount_remote "${name}"
  fi

  rclone config delete "${name}"

  if [[ $? -ne 0 ]]; then
    echo 'Failed to delete remote'
    return 2
  fi
  
  echo "Remote ${name} has been deleted"
}

# Mounts the remote with the given name to the disk.
# Arguments:
#  name: the name of the remote
mount_remote () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_remote "unmounted" || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi
  
  if ! exists "${name}"; then
    echo "No remote ${name} has been found"
    return 2
  elif is_mounted "${name}"; then
    echo "Remote ${name} is already mounted"
    return 2
  fi

  echo "Mounting remote ${name}..."

  local mount_folder="${HOME}/mounts/cloud/${name}"

  mkdir -p "${mount_folder}" &&
  rclone mount "${name}:" "${mount_folder}" \
    --umask=002 --gid=$(id -g) --uid=$(id -u) --timeout=1h \
    --poll-interval=15s --dir-cache-time=1000h --vfs-cache-mode=full \
    --vfs-cache-max-size=150G --vfs-cache-max-age=12h --daemon
  
  if [[ $? -ne 0 ]]; then
    echo 'Failed to mount remote'
    find "${mount_folder}" -maxdepth 0 -empty -exec rm -rf {} \;
    return 2
  fi

  echo "Remote ${name} mounted to ${mount_folder}"
}

# Unmounts the remote with the given name from the disk.
# Arguments:
#  name: the name of the remote
unmount_remote () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_remote "mounted" || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi
  
  if ! exists "${name}"; then
    echo "No remote ${name} has been found"
    return 2
  elif ! is_mounted "${name}"; then
    echo "Remote ${name} is not mounted"
    return 2
  fi

  echo "Unmounting remote ${name}..."

  local remote=''
  remote="$(find_remote "${name}")" || return 1

  local mount_point=''
  mount_point="$(get "${remote}" ".mount_point")" || return 1

  fusermount -uz "${mount_point}"

  if [[ $? -ne 0 ]]; then
    echo 'Failed to unmount remote'
    return 2
  fi

  find "${mount_point}" -maxdepth 0 -empty -exec rm -rf {} \;

  echo "Remote ${name} has been unmounted"
}

# Mounts all the synced remotes.
# Arguments:
#  None
mount_all () {
  local remotes=''
  remotes="$(find_remotes)"

  if [[ $? -ne 0 ]]; then
    echo 'Unable to read remotes'
    return 2
  fi

  local len=0
  len="$(count "${remotes}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo 'No remotes have been found'
    return 2
  fi

  # Iterate over remote names and mount remotes one by one
  remotes="$(echo "${remotes}" | jq -cr '.[]|.name')" || return 1

  local failed='false'
  local remote=''

  while read -r remote; do
    mount_remote "${remote}"

    if [[ $? -ne 0 ]]; then
      echo "Failed to mount remote ${remote}"
      failed='true'
    else
      echo "Remote ${remote} has been mounted"
    fi
  done <<< "${remotes}"

  if [[ "${failed}" == "true" ]]; then
    echo 'Failed to mount all remotes'
    return 2
  fi

  echo 'All remotes have been mounted'
}

