#!/bin/bash

set -o pipefail

source /opt/stack/utils

# Returns the list of any wallpapers found under
# the wallpapers home.
# Arguments:
#  None
# Outputs:
#  A json array of image objects.
find_wallpapers () {
  if [[ ! -d  "${WALLPAPERS_HOME}" ]]; then
    echo '[]'
    return 0
  fi

  local wallpaper=''
  wallpaper+='"\"name\": \""$1"\","'
  wallpaper+='"\"type\": \""$2"\","'
  wallpaper+='"\"resolution\": \""$3"\","'
  wallpaper+='"\"bit\": \""$5"\","'
  wallpaper+='"\"color\": \""$6"\","'
  wallpaper+='"\"size\": \""$7"\""'
  wallpaper="\"{\"${wallpaper}\"},\""

  local wallpapers=''
  wallpapers="$(identify -quiet "${WALLPAPERS_HOME}/*" 2> /dev/null |
    awk '{
      if ($1 ~ /.(jpg|jpeg|png)$/) {
        n=split($1,a,"/")
        $1=a[n]
        print '"${wallpaper}"'
      }
    }'
  )"
  
  # Remove the extra comma after the last array element
  if [[ -n "${wallpapers}" ]]; then
    wallpapers="${wallpapers::-1}"
  fi

  echo "[${wallpapers}]"
}

# Shows a menu asking the user to select one wallpaper,
# where the answer is kept in the global var REPLY.
# Arguments:
#  None
# Outputs:
#  A menu of wallpaper filenames.
pick_wallpaper () {
  local query='{key: .name, value: "\(.name) [\(.resolution)]"}'
  query="[.[]|${query}]"

  local wallpapers=''
  wallpapers="$(find_wallpapers | jq -cer "${query}")"

  if [[ $? -ne 0 ]]; then
    echo 'Unable to find wallpaper files'
    return 2
  fi

  local len=0
  len="$(count "${wallpapers}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo 'No wallpaper files have found'
    return 2
  fi

  pick_one 'Select a wallpaper:' "${wallpapers}" vertical || return $?
}

# Returns the list of pointing devices currently
# connected to the system.
# Arguments:
#  None
# Outputs:
#  A json array of pointing device objects.
find_pointers () {
  local pointers=''
  pointers="$(xinput --list | awk '{
    if ($0 ~ "Virtual core pointer") {
      next
    } else if ($0 ~ "Virtual core keyboard") {
      exit
    }

    match($0, ".*â†³ (.*)id=([0-9]+).*", a)
    gsub(/^[ \t]+/,"",a[1])
    gsub(/[ \t]+$/,"",a[1])
    gsub(/^[ \t]+/,"",a[2])
    gsub(/[ \t]+$/,"",a[2])

    schema="\"id\": \"%s\","
    schema=schema"\"name\": \"%s\""
    schema="{"schema"},"

    printf schema, a[2], a[1]
  }')" || return 1

  # Remove the extra comma after the last element
  if [[ -n "${pointers}" ]]; then
    pointers="${pointers::-1}"
  fi

  echo "[${pointers}]"
}

# Returns the pointing device with the given id.
# Arguments:
#  id: the id of the pointing device
# Outputs:
#  A json object of pointing device.
find_pointer () {
  local id="${1}"

  local name=''
  name="$(find_pointers |
    jq -cer ".[]|select(.id == \"${id}\")|.name")" || return 1

  local pointer=''
  pointer+="\"id\":\"${id}\","
  pointer+="\"name\":\"${name}\","

  pointer+="$(xinput --list-props "${id}" | awk '{
    match($0, "(.*)\\([0-9]{3}\\):(.*)", a)
    gsub(/^[ \t]+/,"",a[1])
    gsub(/[ \t]+$/,"",a[1])
    gsub(/^[ \t]+/,"",a[2])
    gsub(/[ \t]+$/,"",a[2])
    key=a[1];value=a[2]

    if (key == "Device Node") {
      key="node"
      gsub(/"/,"",value)
    } else if (key == "Device Enabled") {
      key="enabled"
    } else if (key == "libinput Accel Speed") {
      key="accel_speed"
    } else if (key == "libinput Accel Profile Enabled") {
      key="accel"
    } else if (key == "Device Accel Constant Deceleration") {
      key="const_decel"
    } else if (key == "Device Accel Adaptive Deceleration") {
      key="adapt_decel"
    } else if (key == "Device Accel Velocity Scaling") {
      key="velocity"
    } else {
      next
    }

    print "\""key"\":\""value"\","
  }')" || return 1

  # Remove the extra comma after the last element
  if [[ -n "${pointer}" ]]; then
    pointer="${pointer::-1}"
  fi

  echo "{${pointer}}"
}

# Shows a menu asking the user to select one pointing device,
# where the answer is kept in the global var REPLY.
# Arguments:
#  None
# Outputs:
#  A menu of pointing devices.
pick_pointer () {
  local pointers=''
  pointers="$(find_pointers)"

  if [[ $? -ne 0 ]]; then
    echo 'Unable to find pointers'
    return 2
  fi

  local len=0
  len="$(count "${pointers}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo 'No pointers have found'
    return 2
  fi

  local query='[.[]|{key: .id, value: "\(.id):\(.name)"}]'
  pointers="$(echo "${pointers}" | jq -cer "${query}")" || return 1

  pick_one 'Select a pointer:' "${pointers}" vertical || return $?
}

# Returns the list of stylus-pen devices currently
# connected to the system.
# Arguments:
#  None
# Outputs:
#  A json array of stylus-pen device objects.
find_tablets () {
  local tablets=''
  tablets="$(xsetwacom --list devices | awk '{
    match($0, "(.*)id:(.*)type:(.*)", a)
    gsub(/^[ \t]+/,"",a[1])
    gsub(/[ \t]+$/,"",a[1])
    gsub(/^[ \t]+/,"",a[2])
    gsub(/[ \t]+$/,"",a[2])
    gsub(/^[ \t]+/,"",a[3])
    gsub(/[ \t]+$/,"",a[3])

    schema="\"id\": \"%s\","
    schema=schema"\"name\": \"%s\","
    schema=schema"\"type\": \"%s\","
    schema=schema"\"vendor\": \"wacom\""
    schema="{"schema"},"

    printf schema, a[2], a[1], a[3]
  }')" || return 1

  # Remove the extra comma after the last element
  if [[ -n "${tablets}" ]]; then
    tablets="${tablets::-1}"
  fi

  echo "[${tablets}]"
}

# Returns the tablet device with the given name.
# Arguments:
#  name: the name of the tablet device
# Outputs:
#  A json object of tablet device.
find_tablet () {
  local name="${1}"

  local query=".[]|select(.name == \"${name}\")"

  local tablet=''
  tablet="$(find_tablets | jq -cer "${query}")" || return 1

  local vendor=''
  vendor="$(get "${tablet}" '.vendor')" || return 1

  # Merge properties specific to wacom devices
  if [[ "${vendor}" == "wacom" ]]; then
    local props=''
    props="$(xsetwacom --get "${name}" all 2>&1 | awk '/^Option/{
      match($0, "Option \"(.*)\" \"(.*)\"", a)
      print "\""a[1]"\": \""a[2]"\","
    }')" || return 1

    # Remove the extra comma after the last key/value pair
    if [[ -n "${props}" ]]; then
      props="${props::-1}"
    fi

    tablet="$(echo "${tablet}" | jq -cer --argjson p "{${props}}" '. + $p')" || return 1
  fi

  echo "${tablet}"
}

# Checks if the given name corresponds to an
# existing tablet device.
# Arguments:
#  name: the name of a tablet device
# Returns:
#  0 if it is a tablet otherwise 1.
is_tablet () {
  local name="${1}"

  local query=".[]|select(.name == \"${name}\")"

  local tablet=''
  tablet="$(find_tablets | jq -cer "${query}")" || return 1

  if [[ -n "${tablet}" ]]; then
    return 0
  else
    return 1
  fi
}

# Checks if the tablet device with the given name
# has a scalable and mappable area.
# Arguments:
#  name: the name of a tablet device
# Returns:
#  0 if it is scalable otherwise 1.
is_scalable () {
  local name="${1}"

  local area=''
  area="$(find_tablet "${name}" | jq -cer '.Area')" || return 1

  if [[ -n "${area}" ]]; then
    return 0
  else
    return 1
  fi
}

# Shows a menu asking the user to select one tablet device,
# where the answer is kept in the global var REPLY.
# Arguments:
#  None
# Outputs:
#  A menu of tablet devices.
pick_tablet () {
  local tablets=''
  tablets="$(find_tablets)"

  if [[ $? -ne 0 ]]; then
    echo 'Unable to find tablets'
    return 2
  fi

  local len=0
  len="$(count "${tablets}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo 'No tablets have found'
    return 2
  fi

  local query='[.[]|{key: .name, value: .name}]'
  tablets="$(echo "${tablets}" | jq -cer "${query}")" || return 1

  pick_one 'Select a tablet:' "${tablets}" vertical || return $?
}

