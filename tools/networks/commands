#!/bin/bash

set -o pipefail

source /opt/stack/utils
source /opt/stack/networks/helpers

SETTINGS_FILE="${CONFIG_HOME}/networks.json"
SHELLRC_FILE="${HOME}/.bashrc"
PROXY_ENV_FILE="${HOME}/.config/environment.d/proxy.conf"
DOCKER_PROXY_FILE='/etc/systemd/system/docker.service.d/http-proxy.conf'

# Shows the current status of the system networking.
# Arguments:
#  None
# Outputs:
#  A long list of networking data.
show_status () {
  systemctl status --lines 0 --no-pager NetworkManager.service |
    awk '{
      if ($0 ~ / *Active/) {
        l = "Service"
        v = $2" "$3
      } else l = ""

      if (l) printf "%-12s %s\n",l":",v
    }' || return 1

  local devices=''
  devices="$(find_devices)"

  if [[ $? -ne 0 ]]; then
    echo 'Unable to read network devices'
    return 2
  fi

  local query=''
  query+='\([$d[]|select((.type == "wifi" or .type == "ethernet") and .state == "connected")]'
  query+=' |if .|length == 0 then "local" else .[0]|.device end|'
  query+='"Network:     \(.)\n")'
  query+='State:       \(.state) [\(.connectivity)]\n'
  query+='WiFi:        \(.wifi)\(if .wifi_hw then " [HW]" else "" end)'
  query="\"${query}\""

  find_status | jq -cer --argjson d "${devices}" "${query}" || return 1

  local query=''
  query+='ISP:         \(.as|split(" ")|"\(.[1]) \(.[2])") [\(.isp)]\n'
  query+='Public IP:   \(.query)\n'
  query+='Country:     \(.city|if . then "\(.), " else "" end)\(.country)'

  curl -s 'http://ip-api.com/json' | jq -cer "\"${query}\""

  if [[ $? -ne 0 ]]; then
    echo 'ISP:         Unavailable'
  fi

  local proxy=''
  if [[ -f "${PROXY_ENV_FILE}" ]]; then
    proxy="$(cat "${PROXY_ENV_FILE}" | awk -F'=' '/export http_proxy=/ {
      split($2,a,"http://")
      if (a[2] ~ /@/) {
        split(a[2],b,"@")
        print b[2]
      } else print a[2]
    }' | tr -d '"/')" || return 1
  fi

  if [[ -n "${proxy}" ]]; then
    echo "Proxy:       ${proxy}"
  fi

  query=''
  query+='.[]|select(.type|test("(^ethernet|wifi|vpn)$"))|.name'

  local connections=''
  connections="$(nmcli connection show --active | jc --nmcli | jq -cr "${query}")" || return 1

  if [[ -z "${connections}" ]]; then
    return 0
  fi

  query=''
  query+='Connection:  \(.connection_id)\(if .default == "yes" then " [default]" else "" end)'
  query+='\(."802_11_wireless_ssid"|if . then "\nSSID:        \(.)" else "" end)'
  query+='\nDevice:      \(if .connection_type == "vpn" then .ip_iface else .connection_interface_name end)'
  query+='\(if .freq then "\nFreq:        \(.freq)GHz [\(.rate)Mb/s]" else "" end)'
  query+='\(if .quality then "\nSignal:      \(.quality) [\(.signal)dBm]" else "" end)'
  query+='\nType:        \(.connection_type)\(.vpn_type|if . then " [\(.)]" else "" end)'
  query+='\(if .connection_type == "vpn" then "\nHost:        \(.vpn_gateway)" else "" end)'
  query+='\(if .vpn_username then "\nUser:        \(.vpn_username)" else "" end)'
  query+='\(."802_11_wireless_security_key_mgmt"|if . then "\nSecurity:    \(.|ascii_upcase)" else "" end)'
  query+='\(if .ip4_address_1 then "\nIPv4:        \(.ip4_address_1)" else "" end)'
  query="\"${query}\""

  local connection=''
  while read -r connection; do
    echo
    find_connection "${connection}" | jq -cer "${query}" || return 1
  done <<< "${connections}"
}

# Shows the data of the network device with the given name.
# Arguments:
#  name: the name of a device
# Outputs:
#  A long list of device data.
show_device () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_device || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate device "${name}"; then
    echo 'Invalid or unknown device'
    return 2
  fi

  local query=''
  query+='Name:        \(.device)\n'
  query+='Type:        \(.type)\n'
  query+='MAC:         \(.hwaddr)\n'
  query+='\(if .freq then "Freq:        \(.freq)GHz [\(.rate)Mb/s]\n" else "" end)'
  query+='\(if .quality then "Signal:      \(.quality) [\(.signal)dBm]\n" else "" end)'
  query+='\(.state_text|if . then "State:       \(.)\n" else "" end)'
  query+='MTU:         \(.mtu)'
  query+='\(.ip4_address_1|if . then "\nIPv4:        \(.)" else "" end)'
  query+='\(.ip4_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip4_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query+='\(.ip4_dns_1|if . then "\nDNS:         \(.)" else "" end)'
  query+='\(.ip4_dns_2|if . then ", \(.)" else "" end)'
  query+='\(.ip6_address_1|if . then "\nIPv6:        \(.)" else "" end)'
  query+='\(.ip6_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip6_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query+='\(.connection|if . then "\nConnection:  \(.)" else "" end)'
  query="\"${query}\""

  find_device "${name}" | jq -cer "${query}" || return 1
}

# Shows the data of the network connection with the
# given name.
# Arguments:
#  name: the name of a connection
# Outputs:
#  A long list of connection data.
show_connection () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_connection || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate connection "${name}"; then
    echo 'Invalid or unknown connection'
    return 2
  fi

  local query=''
  query+='Connection:  \(.connection_id)\(if .default == "yes" then " [default]" else "" end)'
  query+='\(."802_11_wireless_ssid"|if . then "\nSSID:        \(.)" else "" end)'
  query+='\(.connection_uuid|if . then "\nUUID:        \(.)" else "" end)'
  query+='\nDevice:      \(if .connection_type == "vpn"'
  query+=' then "\(.ip_iface|if . then . else "none" end)" else .connection_interface_name end)'
  query+='\(if .freq then "\nFreq:        \(.freq)GHz [\(.rate)Mb/s]" else "" end)'
  query+='\(if .quality then "\nSignal:      \(.quality) [\(.signal)dBm]" else "" end)'
  query+='\(.state|if . then "\nState:       \(.)" else "" end)'
  query+='\nAuto:        \(.connection_autoconnect)'
  query+='\nType:        \(.connection_type)\(.vpn_type|if . then " [\(.)]" else "" end)'
  query+='\(if .connection_type == "vpn" and .vpn_gateway then "\nHost:        \(.vpn_gateway)" else "" end)'
  query+='\(if .vpn_username then "\nUser:        \(.vpn_username)" else "" end)'
  query+='\(."802_11_wireless_security_key_mgmt"|if . then "\nSecurity:    \(.|ascii_upcase)" else "" end)'
  query+='\(.ip4_address_1|if . then "\nIPv4:        \(.)" else "" end)'
  query+='\(.ip4_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip4_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query+='\(.ip4_dns_1|if . then "\nDNS:         \(.)" else "" end)'
  query+='\(.ip4_dns_2|if . then ", \(.)" else "" end)'
  query+='\(.ip6_address_1|if . then "\nIPv6:        \(.)" else "" end)'
  query+='\(.ip6_gateway|if . then "\nGateway:     \(.)" else "" end)'
  query+='\(.ip6_route_1|if . then "\nRoute:       \(.dst)" else "" end)'
  query="\"${query}\""

  find_connection "${name}" | jq -cer "${query}" || return 1
}

# Shows the list of networking devices.
# Arguments:
#  None
# Outputs:
#  A list of network devices.
list_devices () {
  local devices=''
  devices="$(find_devices)"

  if [[ $? -ne 0 ]]; then
    echo 'Unable to read network devices'
    return 2
  fi

  local len=0
  len="$(count "${devices}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo 'No network devices have found'
    return 0
  fi

  local query=''
  query+='Name:        \(.device)\n'
  query+='Type:        \(.type)\n'
  query+='State:       \(.state|if . then . else "none" end)\n'
  query+='Connection:  \(.connection|if . then . else "none" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${devices}" | jq -cer "${query}" || return 1
}

# Shows the list of networking connections.
# Arguments:
#  None
# Outputs:
#  A list of network connections.
list_connections () {
  local connections=''
  connections="$(find_connections)"

  if [[ $? -ne 0 ]]; then
    echo 'Unable to read network connections'
    return 2
  fi

  local len=0
  len="$(count "${connections}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo 'No network connections have found'
    return 0
  fi

  local query=''
  query+='Name:    \(.name)\n'
  query+='Type:    \(.type)\n'
  query+='Device:  \(.device|if . then . else "none" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${connections}" | jq -cer "${query}" || return 1
}

# Detects the available wifi networks in the local area
# with signal strength at least the given limit.
# Arguments:
#  device: the name of a wifi device
#  singal: a signal limitation value
# Outputs:
#  The list of wifi networks.
list_wifis () {
  local device="${1}"
  local signal="${2:-"0"}"

  if [[ -z "${device}" ]]; then
    pick_device wifi || return $?
    [[ -n "${REPLY}" ]] && device="${REPLY}" || return 0
  fi

  if ! validate device "${device}"; then
    echo 'Invalid or unknown device'
    return 2
  fi

  if [[ ! "${signal}" =~ ^[0-9][0-9]{,2}$ ]]; then
    echo 'Invalid signal limit value'
    return 2
  elif (( ${signal} < 0 || ${signal} > 100 )); then
    echo 'Signal limit value out of range'
    return 2
  fi

  echo 'Detecting available wifi networks...'

  local networks=''
  networks="$(find_wifis "${device}" "${signal}")"

  if [[ $? -ne 0 ]]; then
    echo 'Unable to detect wifi networks'
    return 2
  fi

  local len=0
  len="$(count "${networks}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo 'No wifi networks have been detected'
    return 0
  fi

  local query=''
  query+='Name:      \(.ssid)\n'
  query+='Signal:    \(.signal) [\(.channel)]\n'
  query+='Security:  \(.security|'
  query+='if . and . != "" then .|ascii_upcase else "none" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${networks}" | jq -cer "${query}" || return 1
}

# Enables the device or connection with the given name.
# Arguments:
#  object: device or connection
#  name:   the name of a device or connection
up () {
  local object="${1}"
  local name="${2}"

  if [[ -z "${name}" ]]; then
    if [[ "${object}" == "device" ]]; then
      pick_device || return $?
    elif [[ "${object}" == "connection" ]]; then
      pick_connection || return $?
    else
      echo 'Invalid or unknown network object'
      return 2
    fi

    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "${object}" "${name}"; then
    echo 'Invalid or unknown network object'
    return 2
  fi

  echo "Enabling ${object} ${name}..."

  if [[ "${object}" == "device" ]]; then
    nmcli device connect "${name}" &> /dev/null
  elif [[ "${object}" == "connection" ]]; then
    nmcli connection up "${name}" --ask
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to enable ${object}"
    return 2
  fi

  echo "${object^} ${name} has been enabled"
}

# Disables the device or connection with the given name.
# Arguments:
#  object: device or connection
#  name:   the name of a device or connection
down () {
  local object="${1}"
  local name="${2}"

  if [[ -z "${name}" ]]; then
    if [[ "${object}" == "device" ]]; then
      pick_device || return $?
    elif [[ "${object}" == "connection" ]]; then
      pick_connection || return $?
    else
      echo 'Invalid or unknown network object'
      return 2
    fi

    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate "${object}" "${name}"; then
    echo 'Invalid or unknown network object'
    return 2
  fi

  echo "Disabling ${object} ${name}..."

  if [[ "${object}" == "device" ]]; then
    nmcli device disconnect "${name}" &> /dev/null
  elif [[ "${object}" == "connection" ]]; then
    nmcli connection down "${name}" &> /dev/null
  fi

  if [[ $? -ne 0 ]]; then
    echo "Failed to disable ${object}"
    return 2
  fi

  echo "${object^} ${name} has been disabled"
}

# Removes the software device with the given name.
# Arguments:
#  name: the name of a device
remove_device () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_device || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate device "${name}"; then
    echo 'Invalid or unknown device'
    return 2
  fi

  echo "Removing device ${name}..."

  nmcli device delete "${name}" &> /dev/null

  if [[ $? -ne 0 ]]; then
    echo 'Failed to remove device'
    return 2
  fi

  echo "Device ${name} has been removed"
}

# Removes the connection with the given name.
# Arguments:
#  name: the name of a connection
remove_connection () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    pick_connection || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  if ! validate connection "${name}"; then
    echo 'Invalid or unknown connection'
    return 2
  fi

  echo "Removing connection ${name}..."

  nmcli connection delete "${name}" &> /dev/null

  if [[ $? -ne 0 ]]; then
    echo 'Failed to remove connection'
    return 2
  fi

  echo "Connection ${name} has been removed"
}

# Adds a new ethernet connection.
# Arguments:
#  None
add_ethernet_connection () {
  ask 'Enter the connection name:' '.+' || return $?
  local name="${REPLY}"

  if find_connection "${name}" &> /dev/null; then
    echo "Connection ${name} already exists"
    return 2
  fi

  local device=''
  pick_device ethernet || return $?
  [[ -n "${REPLY}" ]] && device="${REPLY}" || return 0

  local dhcp=''
  confirm 'Want to enable DHCP mode?' || return $?
  [[ -n "${REPLY}" ]] && dhcp="${REPLY}" || return 0

  echo "Creating ethernet connection ${name}..."

  if [[ "${dhcp}" == "yes" ]]; then
    nmcli connection add type ethernet \
      con-name "${name}" ifname "${device}" ipv4.method auto
  else
    local re='^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$'

    ask 'Enter the static ip:' "${re}" || return $?
    local ip="${REPLY}"

    ask 'Enter the gateway:' "${re}" || return $?
    local gateway="${REPLY}"

    ask 'Enter the primary DNS:' "${re}" || return $?
    local dns="${REPLY}"

    ask 'Enter the secondary DNS:' "${re}" || return $?
    dns="${dns} ${REPLY}"

    nmcli connection add type ethernet \
      con-name "${name}" ifname "${device}" ipv4.method "manual" \
      ipv4.addresses "${ip}/24" ipv4.gateway "${gateway}" ipv4.dns "${dns}"
  fi

  if [[ $? -ne 0 ]]; then
    echo 'Failed to create ethernet connection'
    return 2
  fi

  echo "Ethernet connection ${name} has been created"
}

# Adds a wifi connection to wireless network.
# Arguments:
#  None
add_wifi_connection () {
  local device=''
  pick_device wifi || return $?
  [[ -n "${REPLY}" ]] && device="${REPLY}" || return 0

  echo 'Detecting available wifi networks...'

  local networks=''
  networks="$(find_wifis "${device}")" || return 1

  local len=0
  len="$(count "${networks}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo 'No wifi networks have been detected'
    return 0
  fi

  local query='{key: .ssid, value: "[\(.signal)] \(.ssid)"}'
  query="[.[]|${query}]"

  networks="$(echo "${networks}" | jq -cer "${query}")" || return 1

  local ssid=''
  pick_one 'Select a wifi network:' "${networks}" vertical || return $?
  [[ -n "${REPLY}" ]] && ssid="${REPLY}" || return 0

  ask_secret 'Enter the private key:' || return $?
  local key="${REPLY}"

  echo "Connecting to network ${ssid}..."

  local result=''
  result="$(nmcli device wifi connect "${ssid}" password "${key}" \
    ifname "${device}" hidden yes 2> /dev/null)"
  
  if [[ $? -ne 0 ]] || [[ "${result}" =~ (E|e)rror ]]; then
    echo "Failed to connect to ${ssid}"
    return 2
  fi

  echo "Connection to ${ssid} has been established"
}

# Adds a new vpn connection.
# Arguments:
#  None
add_vpn_connection () {
  ask 'Enter the path to ovpn file:' '^/.+' || return $?
  local file_path="${REPLY}"

  if [[ ! -f "${file_path}" ]]; then
    echo "Invalid or unknown ${file_path} file"
    return 2
  fi

  local name=$(basename -- "${file_path}")
  local extension="${name##*.}"
  name="${name%.*}"

  if [[ "${extension}" != "ovpn" ]]; then
    echo 'Invalid ovpn file type'
    return 2
  fi

  ask 'Enter the username:' '.+' || return $?
  local username="${REPLY}"

  ask_secret 'Enter the password:' '.+' || return $?
  local password="${REPLY}"

  echo "Creating VPN connection ${name}..."

  nmcli connection import type openvpn file "${file_path}"

  if [[ $? -ne 0 ]]; then
    echo 'Failed to create VPN connection'
    return 2
  fi

  nmcli connection modify "${name}" +vpn.data username="${username}" || return 1
  nmcli connection modify "${name}" +vpn.secrets password="${password}" || return 1

  echo "VPN connection ${name} has been created"
}

# Adds a new proxy profile with the given host,
# port and authentication info.
# Arguments:
#  name: the name of the proxy profile
add_proxy () {
  local name="${1}"

  if [[ -z "${name}" ]]; then
    echo 'Missing the proxy profile name'
    return 2
  fi

  if [[ -f "${SETTINGS_FILE}" ]]; then
    local query=''
    query+=".proxies|if . then .[]|select(.name == \"${name}\") else empty end"
  
    local exists=''
    exists="$(jq -cr "${query}" "${SETTINGS_FILE}")" || return 1

    if [[ -n "${exists}" ]]; then
      echo "Proxy profile ${name} already exists"
      return 2
    fi
  fi

  ask 'Enter the host:' '.+' || return $?
  local host="${REPLY}"

  ask 'Enter the port:' '^[0-9]+$' || return $?
  local port="${REPLY}"

  confirm 'Is this an authenticated proxy?' || return $?
  [[ -z "${REPLY}" ]] && return 0

  if [[ "${REPLY}" == "yes" ]]; then
    ask 'Enter the username:' '.+' || return $?
    local username="${REPLY}"

    ask_secret 'Enter the password:' '.+' || return $?
    local password="${REPLY}"
  fi

  local no_proxy='[]'
  confirm 'Want to set no proxy hosts?' || return $?
  [[ -z "${REPLY}" ]] && return 0

  if [[ "${REPLY}" == "yes" ]]; then
    ask 'Enter no proxy hosts:' '.*' || return $?

    local query='[split(" ")|.[]|if . and .!="" then . else empty end]'
    no_proxy="$(echo "\"${REPLY}\"" | jq -cer "${query}")" || return 1
  fi

  local proxy=''
  proxy+="\"name\": \"${name}\","
  proxy+="\"host\": \"${host}\","
  proxy+="\"port\": \"${port}\","
  proxy+="\"no_proxy\": ${no_proxy}"

  if [[ -n "${username}" ]]; then
    proxy+=",\"username\": \"${username}\""
    proxy+=",\"password\": \"${password}\""
  fi

  proxy="{${proxy}}"

  local settings='{}'
  if [[ -f "${SETTINGS_FILE}" ]]; then
    settings="$(jq -e ".proxies += [${proxy}]" "${SETTINGS_FILE}")" || return 1
  else
    settings="$(echo "{\"proxies\": [${proxy}]}" | jq -e '.')" || return 1
  fi

  mkdir -p "${CONFIG_HOME}"
  echo "${settings}" > "${SETTINGS_FILE}"
  
  echo "Proxy profile ${name} has been added"
}

# Removes the proxy profile with the given name.
# Arguments:
#  name: the name of the proxy profile
remove_proxy () {
  local name="${1}"

  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo 'No proxy profiles have found'
    return 0
  fi

  if [[ -z "${name}" ]]; then
    pick_proxy || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local exists=''
  exists="$(jq ".proxies|if . then .[]|select(.name == \"${name}\") else empty end" "${SETTINGS_FILE}")"

  if [[ -z "${exists}" ]]; then
    echo "Cannot find proxy profile ${name}"
    return 2
  fi

  local settings=''
  settings="$(jq -e "del(.proxies[]|select(.name == \"${name}\"))" "${SETTINGS_FILE}")"

  if [[ $? -ne 0 ]]; then
    echo "Failed to delete proxy profile ${name}"
    return 2
  fi

  echo "${settings}" > "${SETTINGS_FILE}"
  
  echo "Proxy profile ${name} has been deleted"
}

# Shows the list of all proxy profiles stored in the
# settings file.
# Arguments:
#  None
# Outputs:
#  A list of proxy profiles.
list_proxies () {
  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo 'No proxy profiles have found'
    return 0
  fi

  local proxies=''
  proxies="$(jq -cer '.proxies|if length>0 then . else [] end' "${SETTINGS_FILE}")" || return 1
  
  local len=0
  len="$(count "${proxies}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo 'No proxy profiles have found'
    return 0
  fi

  local query=''
  query+='Name:    \(.name)\n'
  query+='Host:    \(.host)\n'
  query+='Port:    \(.port)'
  query+='\(.username|if . and .!="" then "\nAuth:    \(.)" else "" end)'
  query+='\(.no_proxy|if .|length>0 then "\nIgnore:  \([.[]]|join(", "))" else "" end)'
  query="[.[]|\"${query}\"]|join(\"\n\n\")"

  echo "${proxies}" | jq -cer "${query}" || return 1
}

# Sets system-wise proxy server to settings with the
# given profile name.
# Arguments:
#  name: the name of a proxy profile
set_proxy () {
  local name="${1}"

  if [[ ! -f "${SETTINGS_FILE}" ]]; then
    echo 'No proxy profiles have found'
    return 2
  fi

  if [[ -z "${name}" ]]; then
    pick_proxy || return $?
    [[ -n "${REPLY}" ]] && name="${REPLY}" || return 0
  fi

  local proxy=''
  proxy="$(jq ".proxies|if . then .[]|select(.name == \"${name}\") else empty end" "${SETTINGS_FILE}")"

  if [[ -z "${proxy}" ]]; then
    echo "Cannot find proxy profile ${name}"
    return 2
  fi

  local query=''
  query+='\(if .username then "\(.username):\(.password)@" else "" end)'
  query+='\(.host):\(.port)'
  query="\"${query}\""

  local uri=''
  uri="$(echo "${proxy}" | jq -cer "${query}")" || return 1

  local no_proxy=''
  no_proxy="$(echo "${proxy}" | jq -cer '[.no_proxy][]|join(",")')" || return 1

  mkdir -p "${HOME}/.config/environment.d"

  echo "export http_proxy=\"http://${uri}/\"" > "${PROXY_ENV_FILE}" &&
  echo "export HTTP_PROXY=\"http://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export https_proxy=\"https://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export HTTPS_PROXY=\"https://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export ftp_proxy=\"ftp://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export FTP_PROXY=\"ftp://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export rsync_proxy=\"rsync://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export RSYNC_PROXY=\"rsync://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export all_proxy=\"https://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export ALL_PROXY=\"https://${uri}/\"" >> "${PROXY_ENV_FILE}" &&
  echo "export no_proxy=\"${no_proxy}\"" >> "${PROXY_ENV_FILE}" &&
  echo "export NO_PROXY=\"${no_proxy}\"" >> "${PROXY_ENV_FILE}" &&
  sed -i "\|source \"${PROXY_ENV_FILE}\"|d" "${SHELLRC_FILE}" &&
  echo "source \"${PROXY_ENV_FILE}\"" >> "${SHELLRC_FILE}" ||
    echo 'Failed to set environment proxy variables'

  if which git &> /dev/null; then
    git config --global http.proxy "http://${uri}/" &&
    git config --global https.proxy "https://${uri}/" ||
      echo 'Failed to set git proxy settings'
  fi

  if which npm &> /dev/null; then
    npm config set proxy "http://${uri}/" &&
    npm config set https-proxy "https://${uri}/" ||
      echo 'Failed to set npm proxy settings'
  fi
  
  if which yarn &> /dev/null; then
    yarn config set proxy "http://${uri}/" &&
    yarn config set https-proxy "https://${uri}/" ||
      echo 'Failed to set yarn proxy settings'
  fi

  if which docker &> /dev/null; then
    sudo mkdir -p /etc/systemd/system/docker.service.d

    printf '%s\n%s%s%s%s' \
      '[Service]' \
      'Environment=' \
      "\"HTTP_PROXY=http://${uri}/\" " \
      "\"HTTPS_PROXY=https://${uri}/\" " \
      "\"NO_PROXY=${no_proxy}\"" | sudo tee "${DOCKER_PROXY_FILE}" > /dev/null &&
    sudo systemctl daemon-reload ||
      echo 'Failed to set docker proxy settings'
  fi

  local host=''
  host="$(get "${proxy}" ".host")" || return 1

  local port=''
  port="$(get "${proxy}" ".port")" || return 1

  gsettings set org.gnome.system.proxy mode manual
  gsettings set org.gnome.system.proxy.http host "${host}"
  gsettings set org.gnome.system.proxy.http port "${port}"
  gsettings set org.gnome.system.proxy.https host "${host}"
  gsettings set org.gnome.system.proxy.https port "${port}"
  gsettings set org.gnome.system.proxy.ftp host "${host}"
  gsettings set org.gnome.system.proxy.ftp port "${port}"
  gsettings set org.gnome.system.proxy.socks host "${host}"
  gsettings set org.gnome.system.proxy.socks port "${port}"

  local username=''
  username="$(get "${proxy}" ".username")" || return 1

  local password=''
  password="$(get "${proxy}" ".password")" || return 1

  if [[ -n "${username}" ]]; then
    gsettings set org.gnome.system.proxy.http use-authentication true
    gsettings set org.gnome.system.proxy.http authentication-user "${username}"
    gsettings set org.gnome.system.proxy.http authentication-password "${password}"
  else
    gsettings set org.gnome.system.proxy.http use-authentication false
    gsettings set org.gnome.system.proxy.http authentication-user ''
    gsettings set org.gnome.system.proxy.http authentication-password ''
  fi

  local query='.no_proxy|if .|length > 0'
  query+=" then \"[\([.[]|\"'\(.)'\"]|join(\",\"))]\" else [] end"

  local no_proxy=''
  no_proxy="$(echo "${proxy}" | jq -cer "${query}")" || return 1

  gsettings set org.gnome.system.proxy ignore-hosts "${no_proxy}"
  
  echo 'Proxy settings have been applied'
}

# Reverts any proxy settings have been applied to
# the system.
# Arguments:
#  None
unset_proxy () {
  rm -f "${PROXY_ENV_FILE}" &&
  sed -i "\|source \"${PROXY_ENV_FILE}\"|d" "${SHELLRC_FILE}" ||
    echo 'Failed to unset environment proxy variables'

  if which git &> /dev/null &&
    git config --global --get http.proxy &> /dev/null; then
    git config --global --unset http.proxy &&
    git config --global --unset https.proxy ||
      echo 'Failed to unset git proxy settings'
  fi

  if which npm &> /dev/null; then
    npm config delete proxy &&
    npm config delete https-proxy ||
      echo 'Failed to set npm proxy settings'
  fi
  
  if which yarn &> /dev/null; then
    yarn config delete proxy &&
    yarn config delete https-proxy ||
      echo 'Failed to unset yarn proxy settings'
  fi

  if which docker &> /dev/null; then
    sudo rm -f "${DOCKER_PROXY_FILE}" &&
    sudo systemctl daemon-reload ||
      echo 'Failed to unset docker proxy settings'
  fi

  gsettings set org.gnome.system.proxy mode none
  gsettings set org.gnome.system.proxy.http host ''
  gsettings set org.gnome.system.proxy.http port 0
  gsettings set org.gnome.system.proxy.https host ''
  gsettings set org.gnome.system.proxy.https port 0
  gsettings set org.gnome.system.proxy.ftp host ''
  gsettings set org.gnome.system.proxy.ftp port 0
  gsettings set org.gnome.system.proxy.socks host ''
  gsettings set org.gnome.system.proxy.socks port 0
  gsettings set org.gnome.system.proxy.http use-authentication false
  gsettings set org.gnome.system.proxy.http authentication-user ''
  gsettings set org.gnome.system.proxy.http authentication-password ''
  gsettings set org.gnome.system.proxy ignore-hosts '[]'

  echo 'Proxy settings have been unset'
}

# Sets the system networking to on or off.
# Arguments:
#  mode: on or off
power_network () {
  local mode="${1}"

  if [[ -z "${mode}" ]]; then
    echo 'Missing mode value'
    return 2
  elif [[ ! "${mode}" =~ ^(on|off)$ ]]; then
    echo 'Invalid mode value'
    return 2
  fi

  echo "Powering network ${mode}..."

  nmcli networking "${mode}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to power network ${mode}"
    return 2
  fi

  echo "Network power set to ${mode}"
}

# Sets the wifi to on or off.
# Arguments:
#  mode: on or off
power_wifi () {
  local mode="${1}"

  if [[ -z "${mode}" ]]; then
    echo 'Missing mode value'
    return 2
  elif [[ ! "${mode}" =~ ^(on|off)$ ]]; then
    echo 'Invalid mode value'
    return 2
  fi

  echo "Powering wifi ${mode}..."

  nmcli radio wifi "${mode}"

  if [[ $? -ne 0 ]]; then
    echo "Failed to power wifi ${mode}"
    return 2
  fi

  echo "Wifi power set to ${mode}"
}

