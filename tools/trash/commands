#!/bin/bash

set -o pipefail

source /opt/stack/utils
source /opt/stack/trash/helpers

# Show the list of trashed files filtered by the given
# value. If the filter is an integer number the filter
# selects only the files trashed within the given days,
# if the number is prefixed with + the filter selects
# the files trashed more than the given days ago and if
# the filter is a date YYYY-MM-dd the filter selects
# the files trashed the exact given date.
# Arguments:
#  filter: number of days or a certain date
# Outputs:
#  A list of trashed files.
list_files () {
  local filter="${1}"

  local query=''

  if [[ "${filter}" =~ ^[0-9]+$ ]]; then
    query="[.[]|select((now - .epoch) / 86400 < ${filter})]"
  elif [[ "${filter}" =~ ^\+[0-9]+$ ]]; then
    filter="$(echo "${filter}" | tr -d '+')"
    query="[.[]|select((now - .epoch) / 86400 > ${filter})]"
  elif [[ "${filter}" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] && date -d "${filter}" &> /dev/null; then
    filter="$(date -d ${filter} +%s)"
    query="[.[]|select(${filter} - .epoch_date == 0)]"
  elif [[ -z "${filter}" ]]; then
    query='.'
  else
    echo 'Invalid filter value'
    return 2
  fi

  local files=''
  files="$(find_files | jq -cer "${query}")"

  if [[ $? -ne 0 ]]; then
    echo 'Unable to read trashed files'
    return 2
  fi

  local len=0
  len="$(count "${files}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo 'No trashed files have found'
    return 0
  fi

  query='.[]|"\(.date) \(.time) \(.path)"'

  echo "${files}" | jq -cer "${query}" || return 1
}

# Restores trashed files starting from the root
# directory or the given path.
# Arguments:
#  path: the absolute path to restore files from
restore_files () {
  local path="${1:-"/"}"

  # Find the eligible trashed files for restore
  local files=''
  files="$(trash-restore "${path}" <<< "" | awk '/^ *[0-9]+ /{
    schema="\"key\": \"%s\","
    schema=schema"\"value\": \"%s\""
    schema="{"schema"},"

    path=""
    for (i = 4; i <= NF; i++) {
      path=path$i
      if (i < NF) path=path" "
    }

    printf schema, $1, path
  }')"

  if [[ $? -ne 0 ]]; then
    echo 'Unable to read trashed files'
    return 2
  fi

  # Remove the extra comma after the last element
  if [[ -n "${files}" ]]; then
    files="${files::-1}"
  fi
  
  files="[${files}]"

  local len=0
  len="$(count "${files}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo 'No trashed files found'
    return 2
  fi

  local selected=''
  pick_many 'Select which trashed files to restore:' "${files}" '1,' vertical || return $?
  selected="${REPLY}"

  if [[ -z "${selected}" ]]; then
    echo 'No trashed files selected'
    return 2
  fi

  selected="$(echo "${selected}" | jq -rec 'join(",")')" || return 1

  len="$(find_files | jq -cer 'length')" || return 1

  trash-restore "${path}" &> /dev/null <<< "${selected}"

  if [[ $? -ne 0 ]]; then
    echo 'Failed to restore trashed files'
    return 2
  fi

  local post_len=0
  post_len="$(find_files | jq -cer 'length')" || return 1
  len=$((len - post_len))

  if [[ ${len} -eq 0 ]]; then
    echo 'No trashed files restored'
    return 2
  fi

  echo "${len} file(s) have been restored"
}

# Removes the trashed files, given as a list of paths.
# Arguments:
#  paths: a space delimited list of paths
remove_files () {
  local paths=("$@")

  local files=''
  files="$(find_files)"

  if [[ $? -ne 0 ]]; then
    echo 'Unable to read trashed files'
    return 2
  fi

  local len=0
  len="$(count "${files}")" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo 'No trashed files found'
    return 2
  fi

  if [ "${#paths[@]}" -eq 0 ]; then
    local query='[.[]|{key: .path, value: "\(.date) \(.path)"}]'
    files="$(echo "${files}" | jq -cer "${query}")" || return 1

    pick_many 'Select which trashed files to remove:' "${files}" '1,' vertical || return $?

    if [[ -z "${REPLY}" ]]; then
      echo 'No trashed files selected'
      return 2
    fi

    readarray -t paths < <(echo "${REPLY}" | jq -cr '.[]')
  fi

  confirm 'File(s) will be gone forever, proceed?' || return $?
  
  if [[ "${REPLY}" != "yes" ]]; then
    echo 'No trashed files removed'
    return 2
  fi

  local index=0
  for ((index = 0; index < ${#paths[@]}; index++)); do
    local path="${paths[index]}"

    trash-rm "${path}"
  done

  local post_len=0
  post_len="$(find_files | jq -cer 'length')" || return 1
  len=$((len - post_len))

  if [[ ${len} -eq 0 ]]; then
    echo 'No trashed files removed'
    return 2
  fi
  
  echo "${len} trashed file(s) removed"
}

# Empties the trash from files trashed more than
# the given days ago.
# Arguments:
#  days: a positive integer number
empty_files () {
  local days="${1}"
  
  if [[ -n "${days}" ]] && [[ ! "${days}" =~ ^[0-9]+$ ]]; then
    echo 'Invalid days filter'
    return 2
  fi

  local len=0
  len="$(find_files | jq -cer 'length')" || return 1

  if [[ ${len} -eq 0 ]]; then
    echo 'No trashed files found'
    return 2
  fi
  
  local prompt=''

  if [[ -z "${days}" ]]; then
    prompt='ALL trashed files will be gone, proceed?'
  else
    prompt="Files trashed more than ${days} days ago will be gone, proceed?"
  fi
  
  confirm "${prompt}" || return $?

  if [[ "${REPLY}" != "yes" ]]; then
    echo 'No trashed files removed'
    return 2
  fi

  trash-empty -f "${days:-0}"

  if [[ $? -ne 0 ]]; then
    echo 'Failed to remove trashed files'
    return 2
  fi

  local post_len=0
  post_len="$(find_files | jq -cer 'length')" || return 1
  len=$((len - post_len))

  if [[ ${len} -eq 0 ]]; then
    echo 'No trashed files removed'
    return 2
  fi

  echo "${len} trashed file(s) removed"
}

